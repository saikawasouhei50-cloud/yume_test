<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-auth-compat.js"></script> <title>YUMECAN!_</title>
    <!-- Tailwind CSS를 사용하여 빠르고 멋진 디자인을 적용합니다 -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>

		/* gacha.html의 .iso-floor 스타일 수정 */

		/* 시간대별 필터 효과 */

/* 기본(밤) - 원본 이미지 그대로 */
.time-night {
    filter: none;
}

/* 아침 - 약간 푸르스름하고 밝으며 채도가 낮음 */
.time-morning {
    filter: brightness(1.1) sepia(0.2) hue-rotate(180deg) saturate(0.8);
}

/* 낮 - 가장 밝고 선명함 */
.time-day {
    filter: brightness(1.2) contrast(1.1) saturate(1.1);
}

/* 저녁(노을) - 붉은 톤(Sepia)과 따뜻한 색감 */
.time-evening {
    filter: brightness(0.9) sepia(0.5) hue-rotate(-20deg) saturate(1.3) contrast(1.1);
}

/* 배경 이미지 전환 애니메이션 (부드럽게 바뀌도록) */
#room-background {
    transition: filter 2s ease-in-out;
}

.room-wrapper {
    width: 100%;
    
    /* [수정] 800px -> 1200px (또는 100%)로 변경하여 전체 틀을 확실하게 키웁니다 */
    max-width: 100%; 
    
    margin: 0 auto;
    position: relative;
    aspect-ratio: 1.6 / 1;
    position: relative;
    
    /* ✨ 핵심: 가로/세로 비율을 1.6 (16:10)으로 고정 */
    /* 배경 이미지 비율에 따라 1.6, 1.5, 1.33 등으로 조절 가능 */
    aspect-ratio: 1.6 / 1; 
    
    /* 구형 브라우저 호환용 (aspect-ratio가 안 먹힐 때 대비) */
    @supports not (aspect-ratio: 1.6 / 1) {
        padding-bottom: 62.5%; /* 100 / 1.6 = 62.5% */
        height: 0;
    }
}

/* ==========================================================================
   🎨 YUMECAN! Gothic Theme (Dark & Serious)
   ========================================================================== */

/* 1. 폰트 변경: 귀여운 'Jua' -> 진지하고 고딕한 'Noto Serif KR' (명조체) */
@import url('https://fonts.googleapis.com/css2?family=Noto+Serif+KR:wght@300;500;700;900&display=swap');

/* 2. 전체 배경 및 기본 설정 */
body {
    font-family: 'Noto Serif KR', serif; /* 명조체 적용 */
    
    /* 배경: 깊은 밤하늘과 붉은 기운이 감도는 어두운 그라데이션 */
    background: radial-gradient(circle at 50% 10%, #2b1010 0%, #000000 100%);
    background-attachment: fixed; /* 스크롤해도 배경 고정 */
    color: #d1d5db; /* 기본 글자색: 밝은 회색 */
}

body.loading {
    pointer-events: none;
}

/* 3. UI 창 디자인 변경 (Glassmorphism -> Dark Gothic) */
/* 기존의 밝은 투명창들을 아주 진한 검정+회색 테두리로 강제 변환 */
.bg-white\/10, .bg-black\/20, .bg-black\/30, .bg-black\/40, .bg-gray-800, .bg-gray-900 {
    background-color: rgba(10, 10, 15, 0.9) !important; /* 거의 불투명한 검정 */
    border: 1px solid #3f3f46 !important; /* 차가운 회색 테두리 */
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.8) !important;
}

/* 4. 버튼 스타일 재정의 (동글동글함 제거 & 어두운 톤) */
.gacha-button, .sub-tab-button, button, .tab-button {
    border-radius: 4px !important; /* 둥근 모서리 -> 살짝 각진 모서리 */
    font-family: 'Noto Serif KR', serif;
    letter-spacing: 0.05em; /* 자간 넓힘 */
    transition: all 0.3s ease;
}

/* 버튼 호버 효과 */
.gacha-button:hover:not(:disabled) {
    transform: translateY(-2px);
    box-shadow: 0 0 15px rgba(100, 0, 0, 0.6); /* 붉은 그림자 */
    filter: brightness(1.2);
}

/* 탭 버튼 활성화 스타일 (보라/파랑 -> 검붉은색) */
.tab-button.active, .sub-tab-button.active {
    background: linear-gradient(to bottom, #7f1d1d, #450a0a) !important; /* 붉은색 그라데이션 */
    border: 1px solid #fca5a5 !important; /* 연한 붉은 테두리 */
    color: #fca5a5 !important; /* 텍스트: 연한 붉은색 */
    box-shadow: 0 0 15px rgba(220, 38, 38, 0.6) !important;
    font-weight: 700;
    transform: scale(1.02);
}

/* 정렬/필터 버튼 활성화 */
.sort-button.active, .filter-button.active {
    background-color: #9f1239 !important; /* Rose-800 */
    color: white !important;
    border: 1px solid #fda4af !important;
}

/* 5. 텍스트 색상 테마 변경 (강제 적용) */
.text-yellow-300 { color: #fbbf24 !important; text-shadow: 0 2px 4px rgba(0,0,0,0.8); } /* 앰버 골드 */
.text-pink-300 { color: #fda4af !important; } /* 채도 낮춘 핑크 */
.text-blue-300 { color: #94a3b8 !important; } /* 차가운 블루그레이 */
.text-green-400 { color: #84cc16 !important; } /* 올리브 그린 */

/* 타이틀 스타일 */
#global-header h1 {
    color: #9f1239; /* 핏빛 붉은색 */
    text-shadow: 2px 2px 0px #000, 0 0 20px rgba(255, 0, 0, 0.5);
    font-weight: 900;
    font-style: italic;
    font-family: 'Noto Serif KR', serif;
}

/* --- ✨ 등급별 이미지 글로우 효과 (유지) ✨ --- */
.rarity-glow-N { filter: drop-shadow(0 0 5px rgba(255, 255, 255, 0.4)); }
.rarity-glow-R { filter: drop-shadow(0 0 7px rgba(0, 180, 255, 0.8)); }
.rarity-glow-SR { filter: drop-shadow(0 0 9px rgba(200, 0, 255, 0.9)); }
.rarity-glow-SSR { filter: drop-shadow(0 0 14px rgba(255, 220, 0, 1.0)); }

/* 등급별 카드 배경 (채도 낮춤) */
.rarity-N { background: linear-gradient(to top, #374151, #4b5563) !important; color: #d1d5db; }
.rarity-R { background: linear-gradient(to top, #1e3a8a, #1e40af) !important; color: #bfdbfe; }
.rarity-SR { background: linear-gradient(to right, #4c1d95, #5b21b6) !important; color: #e9d5ff; }
.rarity-SSR { background: linear-gradient(to right, #78350f, #92400e) !important; color: #fde68a; border: 1px solid #fbbf24; }

/* --- 🏠 마이룸 스타일 (유지 및 보완) --- */
#room-container {
    position: absolute;
    top: 0; left: 0; width: 100%; height: 100%;
    background-color: #0f0f10; /* 더 어두운 배경 */
    border-radius: 0.5rem; /* 덜 둥글게 */
    overflow: hidden;
    box-shadow: 0
    </style>
</head>
<body class="min-h-screen flex items-center justify-center p-4">

    <button id="global-home-button" onclick="switchTab('home')" 
        class="hidden fixed top-4 left-4 z-[9999] bg-yellow-500 hover:bg-yellow-400 text-black font-bold py-2 px-4 rounded-full shadow-lg border-2 border-white flex items-center gap-2 transition-transform hover:scale-105">
        <span>🏠</span>
        <span class="hidden md:inline">로비로 복귀</span> 
    </button>

    <div id="loading-overlay" class="fixed inset-0 bg-black/80 flex flex-col justify-center items-center z-50">
        <div class="text-yellow-300 text-2xl font-bold animate-pulse">YUMECAN!_</div>
        <p class="text-white mt-2">데이터를 불러오는 중입니다...</p>
    </div>

    <div class="w-full max-w-5xl bg-white/10 backdrop-blur-md rounded-2xl shadow-xl text-white p-6 md:p-8">
        
        <header id="global-header" class="text-center mb-2 md:mb-4">
            <h1 class="text-3xl md:text-5xl font-bold tracking-wider text-yellow-300" style="text-shadow: 2px 2px 4px rgba(0,0,0,0.5);">YUMECAN!_</h1>
        </header>

        <div id="global-info-bar" class="bg-black/20 p-2 md:p-3 rounded-lg mb-2 md:mb-4 flex flex-wrap justify-between items-center gap-2">
            <div id="login-view" class="flex flex-wrap items-center gap-2 justify-center w-full md:w-auto">
                <input type="text" id="nickname-input" placeholder="닉네임" class="bg-gray-700 text-white px-2 py-1 rounded-md text-xs md:text-sm w-20 md:w-24">
                <input type="email" id="email-input" placeholder="이메일" class="bg-gray-700 text-white px-2 py-1 rounded-md text-xs md:text-sm w-20 md:w-24">
                <input type="password" id="password-input" placeholder="비번" class="bg-gray-700 text-white px-2 py-1 rounded-md text-xs md:text-sm w-16 md:w-20">
                
                <button id="login-button" class="gacha-button bg-blue-500 hover:bg-blue-600 text-white font-bold py-1 px-2 rounded-full text-xs md:text-sm">로그인</button>
                <button id="register-button" class="gacha-button bg-green-500 hover:bg-green-600 text-white font-bold py-1 px-2 rounded-full text-xs md:text-sm">가입</button>
            </div>
            
            <div id="logged-in-view" class="hidden flex items-center gap-2 justify-center w-full md:w-auto">
                <p class="font-bold text-xs md:text-base">환영합니다, <span id="nickname-display" class="text-yellow-300"></span>님!</p>
                <button id="logout-button" class="gacha-button bg-red-600 hover:bg-red-700 text-white font-bold py-0.5 px-2 md:py-1 md:px-3 rounded-full text-xs md:text-sm">로그아웃</button>
            </div>
        </div>
        
        <div id="global-currency-bar" class="flex flex-wrap items-center justify-center md:justify-end gap-1.5 md:gap-3 mb-4 md:mb-6">
            <button onclick="openMailbox()" class="relative gacha-button bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-1 px-3 md:py-2 md:px-4 rounded-full text-xs md:text-sm flex items-center gap-1">
                <span>📩</span>
                <span class="hidden md:inline">우편함</span>
                <span id="mail-badge" class="hidden absolute -top-1 -right-1 bg-red-500 text-white text-[10px] w-4 h-4 rounded-full flex items-center justify-center border border-white animate-bounce">N</span>
            </button>

            <div class="text-xs md:text-xl font-bold text-cyan-300 bg-black/20 py-1 px-2 md:py-2 md:px-4 rounded-full inline-flex items-center">
                🔖 <span id="bookmark-display" class="ml-1">10</span>/<span id="max-bookmark-display">10</span><span id="bookmark-timer-container" class="ml-1"></span>
            </div>
            
            <div class="text-xs md:text-2xl font-bold text-yellow-300 bg-black/20 py-1 px-2 md:py-2 md:px-6 rounded-full inline-flex items-center">
                💎 <span id="currency-display" class="ml-1">100</span>
            </div>
            
            <div class="text-xs md:text-xl font-bold text-gray-300 bg-black/20 py-1 px-2 md:py-2 md:px-4 rounded-full inline-flex items-center">
                🖋️ <span id="fountainpen-display" class="ml-1">500</span>
            </div>
            
            <div class="text-xs md:text-xl font-bold text-fuchsia-400 bg-black/20 py-1 px-2 md:py-2 md:px-4 rounded-full inline-flex items-center">
                💧 <span id="inkwell-display" class="ml-1">0</span>
            </div>
            
            
        </div> <main>
			<div id="message-area" class="text-center text-lg h-8 mb-4 transition-opacity duration-300"></div>

             <div id="storage-warning" class="hidden text-center bg-red-500 p-2 rounded-lg mb-4">
                <strong>경고:</strong> 게임 진행 상황을 저장할 수 없습니다. 브라우저가 시크릿 모드이거나 저장 기능이 비활성화되었는지 확인해주세요.
            </div>

            <div id="home-view" class="relative w-full h-[85vh] overflow-hidden">
    <div class="absolute inset-0 flex items-center justify-start pr-6 md:justify-start md:items-center z-0 pb-44 md:pb-0 md:pl-10 md:-translate-y-12 pointer-events-none">
    
    <div id="home-character-container" class="relative h-full flex items-center md:items-center justify-center pointer-events-auto cursor-pointer group transition-transform duration-300 hover:scale-[1.02]">
        
        <img id="home-character-image" src="" alt="대표 캐릭터" class="max-h-[60%] md:max-h-[85%] object-contain drop-shadow-2xl transition-all">
        
        <div id="home-dialogue-container" class="absolute top-[15%] right-[-10%] md:top-[10%] md:-right-40 bg-white/95 text-black p-3 md:p-6 rounded-xl rounded-bl-none shadow-xl max-w-[160px] md:max-w-xs hidden group-hover:block transition-opacity duration-300 animate-fadeIn z-20 border-2 border-blue-100">
            <p id="home-character-name" class="font-bold text-blue-600 mb-1 text-sm md:text-xl"></p>
            <p id="home-character-dialogue" class="text-xs md:text-base font-medium leading-relaxed"></p>
        </div>
    </div>
    
    <div id="home-default-message" class="text-xl md:text-3xl text-gray-300 hidden font-bold drop-shadow-md absolute">
        당신의 서고에서 대표 등장인물을 설정해주세요!
    </div>
</div>

    <div class="absolute z-20 pointer-events-none 
            bottom-[6.5rem] left-0 w-full flex flex-row items-end justify-center gap-1 px-1
            md:top-4 md:bottom-28 md:left-auto md:right-0 md:w-1/3 md:min-w-[280px] md:flex-col md:items-end md:gap-1 md:pr-8">
    
    
    <button id="btn-lobby-deck" onclick="switchTab('deck')" class="pointer-events-auto 
        w-24 flex-1 h-14 text-sm 
        md:flex-none md:w-[90%] md:max-w-[280px] md:h-20 md:text-3xl 
        bg-gradient-to-r from-gray-700 to-gray-800 text-white font-bold transform -skew-x-12 
        hover:scale-105 hover:bg-gray-600 transition-all shadow-lg 
        flex flex-col md:flex-row items-center justify-center 
        border border-white/20 
        border-b-2 md:border-b-0 md:border-l-4 border-blue-400 
        mb-1 md:mb-1 mr-0.5 md:mr-0 gap-0.5 md:gap-2"> <span class="transform skew-x-12 text-lg md:text-3xl mb-0.5 md:mb-0">📝</span>
    <span class="transform skew-x-12 text-sm md:text-2xl leading-none">편찬</span>
</button>


<button id="btn-lobby-inventory" onclick="switchTab('inventory')" class="pointer-events-auto 
        w-24 flex-1 h-14 text-sm 
        md:flex-none md:w-[90%] md:max-w-[280px] md:h-20 md:text-3xl 
        bg-gradient-to-r from-gray-700 to-gray-800 text-white font-bold transform -skew-x-12 
        hover:scale-105 hover:bg-gray-600 transition-all shadow-lg 
        flex flex-col md:flex-row items-center justify-center 
        border border-white/20 
        border-b-2 md:border-b-0 md:border-l-4 border-green-400 
        mb-1 md:mb-1 mr-0.5 md:mr-0 gap-0.5 md:gap-2"> <span class="transform skew-x-12 text-lg md:text-3xl mb-0.5 md:mb-0">📚</span>
    <span class="transform skew-x-12 text-sm md:text-2xl leading-none">서고</span>
</button>
<button id="btn-lobby-breeding" onclick="switchTab('breeding')" class="pointer-events-auto 
        w-24 flex-1 h-14 text-sm 
        md:flex-none md:w-[90%] md:max-w-[280px] md:h-20 md:text-3xl 
        bg-gradient-to-r from-gray-700 to-gray-800 text-white font-bold transform -skew-x-12 
        hover:scale-105 hover:bg-gray-600 transition-all shadow-lg 
        flex flex-col md:flex-row items-center justify-center 
        border border-white/20 
        border-b-2 md:border-b-0 md:border-l-4 border-gray-400 
        mb-1 md:mb-1 gap-0.5 md:gap-2"> 
    <span class="transform skew-x-12 text-lg md:text-3xl mb-0.5 md:mb-0">💡</span>
    <span class="transform skew-x-12 text-sm md:text-2xl leading-none">영감</span>
</button>

<button id="btn-lobby-gacha" onclick="switchTab('gacha')" class="pointer-events-auto 
        w-24 flex-1 h-14 text-sm 
        md:flex-none md:w-[90%] md:max-w-[280px] md:h-20 md:text-3xl 
        bg-gradient-to-r from-gray-700 to-gray-800 text-white font-bold transform -skew-x-12 
        hover:scale-105 hover:bg-gray-600 transition-all shadow-lg 
        flex flex-col md:flex-row items-center justify-center 
        border border-white/20 
        border-b-2 md:border-b-0 md:border-l-4 border-purple-400 
        mb-1 md:mb-1 gap-0.5 md:gap-2"> <span class="transform skew-x-12 text-lg md:text-3xl mb-0.5 md:mb-0">✨</span>
    <span class="transform skew-x-12 text-sm md:text-2xl leading-none">소환</span>
</button>

<button onclick="switchTab('story')" class="pointer-events-auto 
        w-8 h-10 text-[8px] 
        md:w-[90%] md:max-w-[135px] md:h-14 md:text-lg 
        bg-indigo-900/80 hover:bg-indigo-800 text-white font-bold transform -skew-x-12 shadow-lg 
        flex flex-col md:flex-row items-center justify-center border border-white/20 
        mb-1 md:mb-1"> <span class="transform skew-x-12 text-xs md:text-xl mb-0.5 md:mb-0">📖</span>
    <span class="transform skew-x-12 text-[8px] md:text-lg leading-none">스토리</span>
</button>

<button onclick="switchTab('trade')" class="pointer-events-auto 
        w-8 h-10 text-[8px] 
        md:w-[90%] md:max-w-[135px] md:h-14 md:text-lg 
        bg-blue-900/80 hover:bg-blue-800 text-white font-bold transform -skew-x-12 shadow-lg 
        flex flex-col md:flex-row items-center justify-center border border-white/20 
        mb-1 md:mb-1"> 
		<span id="trade-badge" class="hidden absolute -top-1 -right-1 md:top-0 md:right-0 bg-red-500 text-white text-[9px] font-bold px-1.5 py-0.5 rounded-full border border-black animate-bounce z-10 transform skew-x-12">N</span>
		<span class="transform skew-x-12 text-xs md:text-xl mb-0.5 md:mb-0">⚖️</span>
    <span class="transform skew-x-12 text-[8px] md:text-lg leading-none">교환</span>
</button>

<button onclick="switchTab('myroom')" class="pointer-events-auto 
        w-8 h-10 text-[8px] 
        md:w-[90%] md:max-w-[135px] md:h-14 md:text-lg 
        bg-pink-900/80 hover:bg-pink-800 text-white font-bold transform -skew-x-12 shadow-lg 
        flex flex-col md:flex-row items-center justify-center border border-white/20 
        mb-1 md:mb-1"> <span class="transform skew-x-12 text-xs md:text-xl mb-0.5 md:mb-0">☕</span>
    <span class="transform skew-x-12 text-[8px] md:text-lg leading-none">객실</span>
</button>

    <button id="btn-lobby-combat" onclick="switchTab('combat')" class="pointer-events-auto group 
            order-last md:order-none
            w-20 h-16 text-sm
            md:w-full md:max-w-[320px] md:h-24 md:text-4xl 
            bg-gradient-to-r from-yellow-500 to-orange-600 text-white font-black italic transform -skew-x-12 
            hover:scale-105 hover:brightness-110 transition-all 
            shadow-[2px_2px_0px_rgba(0,0,0,0.5)] md:shadow-[6px_6px_0px_rgba(0,0,0,0.5)] border-2 border-yellow-300 
            flex flex-col md:flex-row items-center justify-center gap-0.5 md:gap-2">
        <span class="transform skew-x-12 inline-block text-xl md:text-5xl">⚔️</span>
        <span class="transform skew-x-12 inline-block text-xs md:text-4xl">안정화</span>
        <span class="absolute -bottom-2 -right-2 text-6xl opacity-20 transform skew-x-12 text-black hidden md:block">COMBAT</span>
    </button>

    <div class="hidden md:flex gap-2 w-[90%] max-w-[280px] justify-end absolute bottom-0 right-8 pointer-events-none opacity-0"></div>

</div>

    <div class="absolute bottom-10 md:bottom-4 left-0 w-full px-1 md:px-4 flex justify-between items-end z-10 pointer-events-none">
    
    <div class="pointer-events-auto">
        <button id="event-banner" onclick="switchTab('event-home')" class="bg-gradient-to-r from-pink-600 to-rose-700 text-white px-3 py-2 md:px-10 md:py-4 rounded-tr-2xl rounded-bl-xl shadow-lg hover:brightness-110 flex items-center gap-2 md:gap-4 border-2 border-pink-400 transition-transform hover:scale-105">
            <span class="text-2xl md:text-5xl animate-bounce">🎉</span>
            <div class="text-left">
                <p class="text-[10px] md:text-base text-pink-200 font-bold tracking-widest">EVENT</p>
                <p id="event-banner-text" class="font-bold text-sm md:text-2xl text-shadow">이벤트 확인</p> 
            </div>
        </button>
    </div>

    <div class="flex gap-0.5 md:gap-1 pointer-events-auto bg-black/60 backdrop-blur-md p-1 md:p-2 rounded-xl border border-white/10">
        
        <button onclick="switchTab('friends')" class="relative hover:bg-white/20 p-1 md:p-2 rounded-lg transition-colors text-white" title="친구">
            <span id="main-friend-badge" class="hidden absolute top-0 right-0 bg-red-500 text-white text-[9px] font-bold px-1.5 py-0.5 rounded-full border border-black animate-bounce">0</span>
            <div class="text-base md:text-xl">🤝</div>
            <div class="text-[9px] md:text-[10px] text-center text-gray-300 leading-none mt-0.5">친구</div>
        </button>
        
        <button onclick="switchTab('collection')" class="hover:bg-white/20 p-1 md:p-2 rounded-lg transition-colors text-white" title="도감">
            <div class="text-base md:text-xl">📒</div>
            <div class="text-[9px] md:text-[10px] text-center text-gray-300 leading-none mt-0.5">도감</div>
        </button>
        
        <button onclick="switchTab('achievements')" class="relative hover:bg-white/20 p-1 md:p-2 rounded-lg transition-colors text-white" title="업적">
            <span id="achievement-badge" class="hidden absolute top-0 right-0 bg-red-500 text-white text-[9px] font-bold px-1.5 py-0.5 rounded-full border border-black animate-bounce">0</span>
            <div class="text-base md:text-xl">🏆</div>
            <div class="text-[9px] md:text-[10px] text-center text-gray-300 leading-none mt-0.5">업적</div>
        </button>

        <button onclick="switchTab('profile')" class="hover:bg-white/20 p-1 md:p-2 rounded-lg transition-colors text-white" title="프로필">
            <div class="text-base md:text-xl">👤</div>
            <div class="text-[9px] md:text-[10px] text-center text-gray-300 leading-none mt-0.5">프로필</div>
        </button>

    </div>
</div>
</div>
            
			<div id="event-home-view" class="hidden">
    <div class="flex flex-col md:flex-row gap-6">

        <div class="md:w-1/2 flex flex-col gap-4">
            
            <div class="flex flex-col items-center">
                <img id="event-home-banner-image" src="https://placehold.co/600x200/ff6347/ffffff?text=Event+Banner" alt="Event Banner" class="w-full rounded-lg shadow-lg mb-3">
                <p id="event-home-duration" class="text-sm text-gray-400"></p>
            </div>
            
            <div class="grid grid-cols-2 gap-4 w-full">
                <button id="goto-event-story" class="gacha-button bg-gradient-to-r from-purple-500 to-pink-500 hover:from-purple-600 hover:to-pink-600 text-white font-bold py-3 px-4 rounded-lg shadow-lg text-base">
                    이벤트 스토리
                </button>
                <button id="goto-event-gacha" class="gacha-button bg-gradient-to-r from-red-500 to-yellow-500 hover:from-red-600 hover:to-yellow-600 text-white font-bold py-3 px-4 rounded-lg shadow-lg text-base">
                    이벤트 서가
                </button>
            </div>

            <div class="bg-black/20 p-4 rounded-lg shadow-lg flex-col">
                <p id="event-home-description" class="text-gray-200 mb-4 text-center"></p>
                
                <button id="goto-event-shop" class="gacha-button bg-gradient-to-r from-green-500 to-teal-500 hover:from-green-600 hover:to-teal-600 text-white font-bold py-3 px-6 rounded-lg shadow-lg text-lg w-full mb-3">
                    이벤트 상점
                </button>
                
                <div class="flex gap-2">
                    <button id="goto-event-battle" class="flex-1 gacha-button bg-gradient-to-r from-yellow-400 to-orange-500 hover:from-yellow-500 hover:to-orange-600 text-black font-bold py-5 px-6 rounded-lg shadow-lg text-xl">
                        이벤트 전투
                    </button>
                    <button id="goto-event-raid" class="flex-1 gacha-button bg-gradient-to-r from-red-600 to-rose-900 hover:from-red-700 hover:to-rose-950 text-white font-bold py-5 px-6 rounded-lg shadow-lg text-xl animate-pulse">
                        월드 레이드
                    </button>
                </div>
            </div>
        </div> 

        <div class="md:w-1/2 flex flex-col gap-4">

            <div class="bg-black/20 p-4 rounded-lg shadow-lg">
                <h3 class="text-xl font-bold text-yellow-300 mb-3">이벤트 Pt 현황</h3>
                
                <div class="flex justify-between items-center mb-2 px-2">
                    <span class="text-gray-300 font-bold">💎 현재 보유</span>
                    <span class="text-2xl font-bold text-white">
                        <span id="display-holding-points">0</span> P
                    </span>
                </div>

                <div class="flex justify-between items-center bg-black/30 p-3 rounded-lg border border-white/10">
                    <span class="text-sm text-gray-400">🏆 누적 획득</span>
                    <span class="text-lg font-bold text-yellow-300">
                        <span id="display-cumulative-points">0</span> P
                    </span>
                </div>
            </div> 
            <button onclick="openRankingModal()" class="w-full gacha-button bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-4 rounded-lg shadow-lg flex items-center justify-center gap-2">
                🏆 실시간 랭킹 확인
            </button>

            <div class="bg-black/20 p-4 rounded-lg shadow-lg">
                <h3 class="text-lg font-bold text-gray-200 mb-3 ml-1">🎖️ 명예의 전당 (Top 3)</h3>
                <div id="ranking-preview-container" class="space-y-2">
                    <p class="text-center text-gray-500 text-sm py-2">랭킹 불러오는 중...</p>
                </div>
            </div>

        </div> 
    </div> 
</div>

<div id="event-view" class="hidden">
    
    <div class="w-full flex justify-start mb-2 px-2">
        <button onclick="switchTab('event-home')" class="gacha-button bg-gray-700 hover:bg-gray-600 text-white font-bold py-1 px-4 rounded-full text-sm flex items-center gap-1 border border-gray-500">
            <span>⬅</span> 이벤트 홈으로
        </button>
    </div>

    <div class="bg-black/20 rounded-full p-1 flex justify-center items-center mb-4 max-w-lg mx-auto">
        <button id="event-sub-tab-battle" class="sub-tab-button active w-1/4 font-bold py-2 px-2 md:px-4 rounded-full text-sm md:text-base">전투</button>
        <button id="event-sub-tab-raid" class="sub-tab-button w-1/4 font-bold py-2 px-2 md:px-4 rounded-full text-sm md:text-base text-red-400">레이드</button>
        <button id="event-sub-tab-story" class="sub-tab-button w-1/4 font-bold py-2 px-2 md:px-4 rounded-full text-sm md:text-base">스토리</button>
        <button id="event-sub-tab-shop" class="sub-tab-button w-1/4 font-bold py-2 px-2 md:px-4 rounded-full text-sm md:text-base">상점</button>
    </div>

    <div class="flex justify-center mb-4">
        <div id="event-point-display" class="hidden text-xl font-bold text-pink-300 bg-black/20 py-2 px-4 rounded-full">EVENT P: <span id="event-points">0</span></div>
    </div>
    
    <div id="event-battle-view">
        <p class="text-center text-gray-200 mb-4">이벤트 스테이지에 도전하여 이벤트 포인트를 획득하세요!</p>
        <div id="event-dungeon-list-container" class="grid grid-cols-2 md:grid-cols-5 gap-4"></div>
    </div>

    <div id="event-raid-view" class="hidden">
        <div class="text-center mb-6">
            <h2 class="text-3xl font-bold text-red-500 animate-pulse">⚠ 긴급 토벌 작전 ⚠</h2>
            <p class="text-gray-300 text-sm">모든 탐정과 협력하여 보스를 처치하세요!</p>
        </div>

        <div class="bg-black/40 p-6 rounded-xl border-2 border-red-600 relative overflow-hidden max-w-2xl mx-auto">
            <div class="absolute inset-0 bg-red-900/20 animate-pulse pointer-events-none"></div>
            <div class="flex flex-col items-center z-10 relative">
                <h3 id="raid-boss-name" class="text-2xl md:text-3xl font-bold text-white mb-2">LOADING...</h3>
                <img id="raid-boss-image" src="" class="w-48 h-48 md:w-64 md:h-64 object-contain drop-shadow-[0_0_15px_rgba(255,0,0,0.6)] mb-4 transition-transform duration-500 hover:scale-105">
                <div class="w-full bg-gray-800 h-6 md:h-8 rounded-full border border-gray-600 relative overflow-hidden mb-2 shadow-inner">
                    <div id="raid-boss-hp-bar" class="h-full bg-gradient-to-r from-red-600 to-red-400 transition-all duration-500" style="width: 100%"></div>
                    <p id="raid-boss-hp-text" class="absolute inset-0 flex items-center justify-center text-xs md:text-sm font-bold text-white drop-shadow-md">Loading...</p>
                </div>
                <p class="text-xs text-gray-400 mb-2">체력은 모든 유저에게 실시간 공유됩니다.</p>
                <div id="raid-count-display" class="text-sm font-bold text-yellow-300 mb-6">오늘의 레이드: 0 / 5회</div>
                <button id="raid-start-btn" onclick="startRaidBattle()" class="gacha-button bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-10 rounded-full text-lg md:text-xl shadow-[0_0_15px_rgba(220,38,38,0.5)]">⚔️ 전투 개시</button>
            </div>
        </div>

        <div class="mt-8 bg-black/40 p-4 rounded-xl border-2 border-gray-600 max-w-2xl mx-auto shadow-2xl">
            <h3 class="text-xl font-bold text-yellow-300 mb-4 text-center">⚔️ 기여도 순위 (Top 5)</h3>
            <div id="raid-ranking-preview-container" class="space-y-3"></div>
        </div>
    </div> 

    <div id="event-story-view" class="hidden">
        <p class="text-center text-gray-200 mb-4">이벤트 스테이지를 클리어하고 스토리를 해금하세요.</p>
        <div class="bg-black/20 rounded-full p-1 flex justify-center items-center mb-4 max-w-sm mx-auto">
            <button id="event-story-sub-tab-part1" class="sub-tab-button active w-1/2 font-bold py-2 px-6 rounded-full">전반부</button>
            <button id="event-story-sub-tab-part2" class="sub-tab-button w-1/2 font-bold py-2 px-6 rounded-full">후반부</button>
        </div>
        <div id="event-story-part1-container" class="space-y-3 max-h-[60vh] overflow-y-auto bg-black/20 p-4 rounded-xl"></div>
        <div id="event-story-part2-container" class="hidden space-y-3 max-h-[60vh] overflow-y-auto bg-black/20 p-4 rounded-xl">
            <p class="text-center text-gray-400 mt-10">후반부 스토리는 준비 중입니다.</p>
        </div>
    </div>

    <div id="event-shop-view" class="hidden">
    <div class="sticky top-0 z-10 bg-gradient-to-r from-gray-900 to-gray-800 p-4 rounded-xl mb-4 border border-pink-500/50 shadow-lg flex justify-between items-center">
        <div class="flex items-center gap-2">
            <span class="text-2xl animate-pulse">💎</span>
            <div>
                <p class="text-xs text-pink-300 font-bold">CURRENT POINTS</p>
                <p class="text-white font-bold text-lg">보유 포인트</p>
            </div>
        </div>
        <div class="text-right">
            <span id="shop-event-point-display" class="text-3xl font-black text-yellow-300 drop-shadow-[0_2px_2px_rgba(0,0,0,0.8)]">0</span>
            <span class="text-gray-400 font-bold ml-1">P</span>
        </div>
    </div>

    <p class="text-center text-gray-200 mb-4 text-sm">획득한 이벤트 포인트로 특별한 보상을 교환하세요!</p>
    <div id="event-shop-container" class="grid grid-cols-1 md:grid-cols-2 gap-4 pb-4"></div>
</div>

</div>

            <div id="gacha-view" class="hidden">
                <p class="text-center text-gray-200 mt-2 mb-4">운명을 시험하여 당신의 등장인물을 만나보세요.</p>
                <div class="bg-black/20 rounded-full p-1 flex justify-center items-center mb-4 max-w-sm mx-auto">
                    <button id="gacha-tab-normal" class="sub-tab-button active w-1/2 font-bold py-2 px-6 rounded-full">일반 서가</button>
                    <button id="gacha-tab-event" class="sub-tab-button w-1/2 font-bold py-2 px-6 rounded-full hidden">이벤트 서가</button>
                </div>
                <div id="normal-gacha-view">
                    <div class="flex flex-col sm:flex-row justify-center items-center gap-4 mb-4">
                        <button id="pull-one" class="gacha-button w-full sm:w-auto bg-blue-500 hover:bg-blue-600 disabled:opacity-50 disabled:cursor-not-allowed text-white font-bold py-3 px-8 rounded-full shadow-lg">💎 1회 뽑기 (10)</button>
                        <button id="pull-ten" class="gacha-button w-full sm:w-auto bg-purple-600 hover:bg-purple-700 disabled:opacity-50 disabled:cursor-not-allowed text-white font-bold py-3 px-8 rounded-full shadow-lg">💎💎 10회 뽑기 (100)</button>
						<button onclick="openGachaPoolModal('normal')" class="gacha-button w-full sm:w-auto bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-6 rounded-full shadow-lg text-sm mt-2">
    등장인물 목록 (획득 가능)
</button>
                    </div>
                </div>
                <div id="event-gacha-view" class="hidden">
    
    <div class="flex justify-end mb-2">
        <button onclick="switchTab('event-home')" class="text-xs font-bold text-pink-300 hover:text-white bg-pink-900/30 px-3 py-1 rounded-full border border-pink-500/30 transition-colors">
            🏠 이벤트 홈으로 이동
        </button>
    </div>

    <div id="event-gacha-info" class="text-center p-2 mb-2 rounded-lg bg-yellow-500/20">
        <p class="font-bold text-yellow-300"></p>
    </div>
    
    <div class="flex flex-col sm:flex-row justify-center items-center gap-4 mb-4">
        <button id="pull-one-event" class="gacha-button w-full sm:w-auto bg-gradient-to-r from-red-500 to-yellow-500 hover:from-red-600 hover:to-yellow-600 disabled:opacity-50 disabled:cursor-not-allowed text-white font-bold py-3 px-8 rounded-full shadow-lg">🔥 1회 뽑기 (10)</button>
        <button id="pull-ten-event" class="gacha-button w-full sm:w-auto bg-gradient-to-r from-pink-500 to-purple-600 hover:from-pink-600 hover:to-purple-700 disabled:opacity-50 disabled:cursor-not-allowed text-white font-bold py-3 px-8 rounded-full shadow-lg">🔥🔥 10회 뽑기 (100)</button>
        
        <button onclick="openGachaPoolModal('event')" class="gacha-button w-full sm:w-auto bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-6 rounded-full shadow-lg text-sm mt-2">
            등장인물 목록 (획득 가능)
        </button>
    </div>
</div>
                <div id="results-container" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-4 min-h-[200px] bg-black/20 p-4 rounded-xl"></div>
            </div>

<div id="breeding-view" class="hidden">
    <div class="text-center mb-6">
        <h2 class="text-3xl font-bold text-yellow-300 mb-2">💡 영감의 방</h2>
        <p class="text-gray-300">두 가지 <span class="text-white font-bold">모티브</span>를 조합하여 새로운 아이디어를 구상합니다.</p>
    </div>

    <div class="flex flex-col md:flex-row justify-center items-center gap-8 mb-8">
        <div class="flex flex-col items-center">
            <p class="text-blue-300 font-bold mb-2">📘 모티브 1 (외형/대사)</p>
            <div id="breeding-slot-a" onclick="clearBreedingSlot('a')" class="breeding-slot w-32 h-48 border-2 border-dashed border-blue-400 rounded-lg flex items-center justify-center cursor-pointer relative">
                <span class="text-gray-500 text-sm pointer-events-none">선택 대기</span>
            </div>
        </div>

        <div class="flex flex-col items-center justify-center">
            <div class="text-4xl animate-pulse text-yellow-200 mb-2">⚡</div>
            <div class="text-xs text-gray-400">동일 등급만<br>가능</div>
        </div>

        <div class="flex flex-col items-center">
            <p class="text-pink-300 font-bold mb-2">📕 모티브 2 (진영)</p>
            <div id="breeding-slot-b" onclick="clearBreedingSlot('b')" class="breeding-slot w-32 h-48 border-2 border-dashed border-pink-400 rounded-lg flex items-center justify-center cursor-pointer relative">
                <span class="text-gray-500 text-sm pointer-events-none">선택 대기</span>
            </div>
        </div>
    </div>

    <div class="bg-black/40 p-4 rounded-xl max-w-lg mx-auto text-center border border-gray-600 mb-6">
        <p class="text-gray-300 text-sm mb-2">필요한 영감: <span class="text-gray-500">등급별 상이</span></p>
        <p id="breeding-prediction" class="text-green-400 text-sm font-bold mb-4">모티브를 선택하면 예상 결과가 분석됩니다.</p>
        
        <button id="btn-execute-breeding" onclick="executeBreeding()" class="gacha-button bg-gradient-to-r from-yellow-600 to-orange-600 hover:from-yellow-500 hover:to-orange-500 text-white font-bold py-3 px-10 rounded-full text-lg shadow-[0_0_15px_rgba(234,179,8,0.6)] disabled:opacity-50 disabled:cursor-not-allowed" disabled>
            💡 구상 시작
        </button>
    </div>

    <div class="bg-black/20 p-4 rounded-xl">
        <h3 class="text-white font-bold mb-3 border-b border-gray-600 pb-2">📚 참고할 원고 목록 (클릭하여 등록)</h3>
        <div id="breeding-inventory-container" class="grid grid-cols-3 sm:grid-cols-4 md:grid-cols-5 lg:grid-cols-6 gap-3 max-h-[40vh] overflow-y-auto p-2">
            </div>
    </div>
</div>


            <div id="inventory-view" class="hidden">
     <div class="text-center mb-4 relative">
    <p class="text-gray-200">지금까지 수집한 등장인물입니다.</p>
    
    <button onclick="switchTab('deck')" class="absolute right-0 top-0 gacha-button bg-gray-700 hover:bg-gray-600 text-white text-xs px-3 py-1 rounded-full border border-gray-500 flex items-center gap-1">
        <span>📝</span> 편찬으로 이동
    </button>

    <div class="mt-2 flex justify-center items-center gap-4">
        <p id="inventory-status" class="text-lg font-bold bg-black/20 py-2 px-4 rounded-full"></p>
        <button id="expand-inventory" class="gacha-button bg-yellow-500 hover:bg-yellow-600 disabled:opacity-50 disabled:cursor-not-allowed text-black font-bold py-2 px-4 rounded-full shadow-lg text-sm">칸 확장 (💎50)</button>
    </div>


		<div id="dismantle-multi-ui" class="hidden mt-4 bg-black/30 p-3 rounded-lg space-y-2">
    <div class="flex justify-between items-center">
        <div class="flex items-center gap-4">
            <p class="text-sm text-gray-300">선택된 카드: <span id="selected-card-count" class="font-bold text-white">0장</span></p>
            <button id="select-all-filtered-button" class="gacha-button bg-blue-500 hover:bg-blue-600 text-white font-bold py-1 px-3 rounded-full text-sm">필터된 원고 전체 선택</button>
        </div>
        <div class="flex items-center gap-2">
            <button id="exit-multi-mode" class="gacha-button bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-full shadow-lg text-sm">나가기</button>
            <button id="dismantle-selected-button" class="gacha-button bg-red-600 hover:bg-red-700 disabled:opacity-50 text-white font-bold py-2 px-4 rounded-full shadow-lg text-sm" disabled>선택된 원고 파쇄</button>
        </div>
    </div>
</div>
<div class="flex justify-center mt-4 mb-4">
    <button id="enter-multi-mode" class="gacha-button bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-6 rounded-full shadow-lg">일괄 파쇄</button>
</div>

<div id="inventory-sort-buttons" class="mt-4 flex justify-center gap-2">
    <button data-sort="rarity" class="gacha-button sort-button bg-gray-600 hover:bg-gray-700 text-white font-bold py-1 px-4 rounded-full text-sm">등급<span class="sort-indicator"></span></button>
    <button data-sort="level" class="gacha-button sort-button bg-gray-600 hover:bg-gray-700 text-white font-bold py-1 px-4 rounded-full text-sm">퇴고<span class="sort-indicator"></span></button>
    <button data-sort="revision" class="gacha-button sort-button bg-gray-600 hover:bg-gray-700 text-white font-bold py-1 px-4 rounded-full text-sm">개정<span class="sort-indicator"></span></button>
    <button data-sort="name" class="gacha-button sort-button bg-gray-600 hover:bg-gray-700 text-white font-bold py-1 px-4 rounded-full text-sm">이름<span class="sort-indicator"></span></button>
</div>
		 
        <div id="inventory-filter-buttons" class="mt-2 flex justify-center gap-2">
    <button data-filter="All" class="gacha-button filter-button bg-gray-600 hover:bg-gray-700 text-white font-bold py-1 px-4 rounded-full text-sm">전체</button>
    <button data-filter="N" class="gacha-button filter-button bg-gray-600 hover:bg-gray-700 text-white font-bold py-1 px-4 rounded-full text-sm">N</button>
    <button data-filter="R" class="gacha-button filter-button bg-gray-600 hover:bg-gray-700 text-white font-bold py-1 px-4 rounded-full text-sm">R</button>
    <button data-filter="SR" class="gacha-button filter-button bg-gray-600 hover:bg-gray-700 text-white font-bold py-1 px-4 rounded-full text-sm">SR</button>
    <button data-filter="SSR" class="gacha-button filter-button bg-gray-600 hover:bg-gray-700 text-white font-bold py-1 px-4 rounded-full text-sm">SSR</button>
</div>
    </div>
    <div id="inventory-container" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-4 min-h-[400px] max-h-[60vh] overflow-y-auto bg-black/20 p-4 rounded-xl"></div>
</div>

            <div id="deck-view" class="hidden">
                <div class="text-center mb-4 relative">
    <p class="text-gray-200">등장인물들과 함께 안정화를 준비하세요. (5장 필수)</p>
    
    <button onclick="switchTab('inventory')" class="absolute right-0 top-0 gacha-button bg-gray-700 hover:bg-gray-600 text-white text-xs px-3 py-1 rounded-full border border-gray-500 flex items-center gap-1">
        <span>📚</span> 서고로 이동
    </button>

    <div class="mt-2 flex justify-center items-center gap-4">
        <div id="deck-status" class="text-lg font-bold text-yellow-300"></div>
        <button id="auto-fill-deck" class="gacha-button bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-full shadow-lg text-sm">자동 편성</button>
    </div>
</div>
                <div id="deck-slots-container" class="grid grid-cols-5 gap-4 mb-6 bg-black/20 p-4 rounded-xl"></div>
                <div class="text-center mb-4">
                    <h3 class="text-lg font-bold text-yellow-300">활성 인연 효과</h3>
                    <div id="synergy-list" class="mt-2 text-gray-200 text-sm min-h-[24px]">
                        </div>
                </div>
				<div id="deck-inventory-container" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-4 min-h-[250px] max-h-[40vh] overflow-y-auto bg-black/20 p-4 rounded-xl"></div>
            </div>
            
            <div id="combat-view" class="hidden">
                <div class="text-center mb-4">
                    <p class="text-gray-200">편찬한 책으로 안정화에 도전하여 보상을 획득하세요!</p>
                    <p class="text-xl font-bold">현재 책 전투력: <span id="deck-power-display" class="text-yellow-300">0</span></p>
                </div>
                <div class="flex flex-col md:flex-row gap-4">
                    <div id="chapter-list-container" class="md:w-1/3 space-y-2">
                        </div>
                    <div id="stage-list-container" class="md:w-2/3 grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-2 bg-black/20 p-2 rounded-xl">
                        </div>
                </div>
            </div>

            <div id="combat-in-progress-view" class="hidden">
                <div class="grid grid-cols-3 gap-4 items-center">
                    <div id="combat-player-deck" class="col-span-1 space-y-2"></div>
                    <div id="combat-monster-area" class="col-span-2 flex flex-col items-center"></div>
                </div>

                <div class="flex justify-end items-center gap-2 mt-4">
                    <button id="speed-1x" class="speed-button active bg-gray-600 text-white font-bold py-1 px-3 rounded-full text-sm">1x</button>
                    <button id="speed-2x" class="speed-button bg-gray-600 text-white font-bold py-1 px-3 rounded-full text-sm">2x</button>
                    <button id="speed-4x" class="speed-button bg-gray-600 text-white font-bold py-1 px-3 rounded-full text-sm">4x</button>
                    
                    <button id="combat-run-button" class="gacha-button bg-yellow-600 hover:bg-yellow-700 text-black font-bold py-1 px-3 rounded-full text-sm ml-2">항복</button>
                </div>
                <div id="combat-log-container" class="mt-2 bg-black/30 p-4 rounded-lg h-40 overflow-y-auto">
                    <div id="combat-log"></div>
                </div>
                 
            </div>

             <div id="collection-view" class="hidden">
    <div class="flex flex-col md:flex-row gap-4 min-h-[70vh]">
        <div class="md:w-1/4 bg-black/20 p-3 rounded-lg max-h-[70vh] overflow-y-auto">
            <h3 class="text-lg font-bold text-yellow-300 mb-2 text-center">등장인물</h3>
            <div id="collection-character-list" class="space-y-1">
                </div>
        </div>
        
        <div id="collection-character-detail-view" class="md:w-3/4 bg-black/20 p-4 rounded-lg hidden">
            <div class="flex flex-col md:flex-row gap-4 mb-4">
                <img id="collection-profile-image" src="" class="w-full md:w-1/3 rounded-lg shadow-lg">
                <div class="md:w-2/3">
                    <h2 id="collection-profile-name" class="text-3xl font-bold text-yellow-300"></h2>
                    <p class="text-lg mt-1"><span class="font-bold text-gray-400">나이:</span> <span id="collection-profile-age"></span></p>
                    <p class="text-lg mt-1"><span class="font-bold text-gray-400">직업:</span> <span id="collection-profile-job"></span></p>
                    <p class="text-sm mt-3 text-gray-300 leading-relaxed" id="collection-profile-description"></p>
                </div>
            </div>
            
            <div class="bg-black/20 rounded-full p-1 flex justify-center items-center mb-4 max-w-sm mx-auto">
                <button id="collection-sub-tab-cards" class="sub-tab-button active w-1/2 font-bold py-2 px-6 rounded-full">카드 모음</button>
                <button id="collection-sub-tab-dialogues" class="sub-tab-button w-1/2 font-bold py-2 px-6 rounded-full">대사 모음</button>
            </div>
            
            <div id="collection-cards-view">
                <div id="collection-container" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-4 max-h-[40vh] overflow-y-auto bg-black/10 p-2 rounded-xl">
                    </div>
            </div>
            
            <div id="collection-dialogues-view" class="hidden">
                <div id="collection-dialogues-list" class="space-y-3 max-h-[40vh] overflow-y-auto bg-black/10 p-4 rounded-xl">
                    </div>
            </div>
        </div>
        
        <div id="collection-default-message" class="md:w-3/4 flex items-center justify-center bg-black/20 p-4 rounded-lg">
            <p class="text-2xl text-gray-400">왼쪽에서 등장인물을 선택하세요.</p>
        </div>
    </div>
</div>

			<div id="achievements-view" class="hidden">
                <div class="text-center mb-4">
                    <p class="text-gray-200">다양한 목표를 달성하고 특별한 보상을 획득하세요.</p>
                </div>
                <div id="achievements-container" class="space-y-3 max-h-[60vh] overflow-y-auto bg-black/20 p-4 rounded-xl">
                    </div>
            </div>
            
            <div id="story-view" class="hidden">
                <div class="text-center mb-4">
                    <p class="text-gray-200">안정화를 통해 해금한 스토리를 열람합니다.</p>
                </div>
			
                
                 <div class="bg-black/20 rounded-full p-1 flex justify-center items-center mb-4 max-w-sm mx-auto">
    <button id="story-sub-tab-main" class="sub-tab-button active w-1/2 font-bold py-2 px-6 rounded-full">메인 스토리</button>
    <button id="story-sub-tab-archive" class="sub-tab-button w-1/2 font-bold py-2 px-6 rounded-full">지난 이벤트</button>
</div>

<div id="main-story-container" class="space-y-3 max-h-[60vh] overflow-y-auto bg-black/20 p-4 rounded-xl"></div>

<div id="event-archive-container" class="hidden space-y-3 max-h-[60vh] overflow-y-auto bg-black/20 p-4 rounded-xl"></div>
            </div>
			
			<div id="trade-view" class="hidden">
    <div class="text-center mb-4">
        <p class="text-gray-200">다른 탐정들과 등장인물을 교환하세요.</p>
    </div>

    <div class="bg-black/20 rounded-full p-1 flex justify-center items-center mb-4 max-w-sm mx-auto">
        <button id="trade-sub-tab-market" class="sub-tab-button active w-1/2 font-bold py-2 px-6 rounded-full">거래소 목록</button>
        <button id="trade-sub-tab-register" class="sub-tab-button w-1/2 font-bold py-2 px-6 rounded-full">거래 등록</button>
    </div>

    <div id="trade-market-view">
        <div class="flex justify-end mb-2">
            <button onclick="loadTradeList()" class="text-sm text-blue-300 hover:text-white">🔄 목록 새로고침</button>
        </div>
        <div id="trade-list-container" class="grid grid-cols-1 md:grid-cols-2 gap-4 max-h-[60vh] overflow-y-auto bg-black/20 p-4 rounded-xl">
            </div>
    </div>

    <div id="trade-register-view" class="hidden">
        <div class="bg-black/30 p-4 rounded-lg mb-4">
            <h3 class="text-yellow-300 font-bold mb-2">1단계: 보낼 카드 선택</h3>

<div id="trade-filter-buttons" class="flex flex-wrap gap-2 mb-2">
    <button data-filter="All" class="trade-filter-button bg-blue-500 text-white font-bold py-1 px-3 rounded-full text-xs hover:bg-blue-600 transition-colors">전체</button>
    <button data-filter="N" class="trade-filter-button bg-gray-600 text-white font-bold py-1 px-3 rounded-full text-xs hover:bg-gray-700 transition-colors">N</button>
    <button data-filter="R" class="trade-filter-button bg-gray-600 text-white font-bold py-1 px-3 rounded-full text-xs hover:bg-gray-700 transition-colors">R</button>
    <button data-filter="SR" class="trade-filter-button bg-gray-600 text-white font-bold py-1 px-3 rounded-full text-xs hover:bg-gray-700 transition-colors">SR</button>
    <button data-filter="SSR" class="trade-filter-button bg-gray-600 text-white font-bold py-1 px-3 rounded-full text-xs hover:bg-gray-700 transition-colors">SSR</button>
</div>

<div id="trade-inventory-container" class="grid grid-cols-4 sm:grid-cols-5 gap-2 max-h-60 overflow-y-auto bg-black/20 p-2 rounded mb-4">
</div>
            
            <div id="trade-selected-card-preview" class="hidden text-center mb-4 border border-blue-500 p-2 rounded">
                <p class="text-gray-300 text-sm">선택된 카드</p>
                <p id="trade-selected-name" class="font-bold text-xl text-white"></p>
            </div>

            <h3 class="text-green-300 font-bold mb-2">2단계: 원하는 카드 선택</h3>

<div class="flex flex-col gap-3 mb-4">
    <div>
        <label class="text-xs text-gray-400 ml-1">등장인물</label>
        <select id="trade-target-basename" class="w-full bg-gray-700 text-white px-3 py-2 rounded-md border border-gray-600 focus:border-blue-500 outline-none">
            <option value="">등장인물을 선택하세요</option>
        </select>
    </div>

    <div class="flex gap-2">
        <div class="w-1/3">
            <label class="text-xs text-gray-400 ml-1">등급</label>
            <select id="trade-target-rarity-select" class="w-full bg-gray-700 text-white px-3 py-2 rounded-md border border-gray-600 focus:border-blue-500 outline-none" disabled>
                <option value="">-</option>
            </select>
        </div>

        <div class="w-2/3">
            <label class="text-xs text-gray-400 ml-1">카드 (칭호 포함)</label>
            <select id="trade-target-specific-card" class="w-full bg-gray-700 text-white px-3 py-2 rounded-md border border-gray-600 focus:border-blue-500 outline-none" disabled>
                <option value="">-</option>
            </select>
        </div>
    </div>
</div>

<p class="text-xs text-gray-400 mb-4">* 선택한 카드를 정확히 구하는 거래가 등록됩니다.</p>

<button id="btn-register-trade" class="gacha-button bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 w-full rounded-full shadow-lg">
    거래 등록하기 (수수료: 💎10)
</button>
        </div>
        
        <div class="mt-8">
            <h3 class="text-white font-bold mb-2">내가 등록한 거래</h3>
            <div id="my-trade-list" class="space-y-2"></div>
        </div>
    </div>
</div>

<div id="profile-view" class="hidden">
    <div class="text-center mb-6">
        <p class="text-gray-200">다른 탐정들에게 보여질 당신의 프로필을 설정하세요.</p>
    </div>

    <div class="flex flex-col md:flex-row gap-6 items-start justify-center max-w-4xl mx-auto">
        
        <div class="w-full md:w-1/3 flex flex-col items-center">
            <div class="relative w-full aspect-[2/3] bg-black/30 rounded-lg overflow-hidden border-2 border-gray-600 shadow-xl mb-4 group cursor-pointer" onclick="openProfileCardSelector()">
                <img id="profile-rep-image" src="https://placehold.co/400x600/000000/ffffff?text=No+Card" class="w-full h-full object-cover">
                <div class="absolute inset-0 bg-black/50 flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity">
                    <span class="text-white font-bold border border-white px-4 py-2 rounded-full">카드 변경</span>
                </div>
            </div>
            <p class="text-yellow-300 font-bold text-lg" id="profile-rep-name">선택된 카드 없음</p>
        </div>

        <div class="w-full md:w-2/3 bg-black/20 p-6 rounded-xl space-y-6">
            
            <div>
                <label class="block text-gray-400 text-sm font-bold mb-2">닉네임</label>
                <input type="text" id="profile-nickname-edit" class="w-full bg-gray-700 text-white border border-gray-600 rounded p-3 focus:outline-none focus:border-blue-500 font-bold text-lg" placeholder="닉네임을 입력하세요">
            </div>

            <div>
                <label class="block text-gray-400 text-sm font-bold mb-2">한마디 (최대 50자)</label>
                <textarea id="profile-message-edit" maxlength="50" rows="3" class="w-full bg-gray-700 text-white border border-gray-600 rounded p-3 focus:outline-none focus:border-blue-500 resize-none" placeholder="자신을 소개하는 한마디를 입력하세요."></textarea>
                <p class="text-right text-xs text-gray-500 mt-1"><span id="profile-msg-count">0</span>/50</p>
            </div>

            <button onclick="saveProfileData()" class="gacha-button w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 rounded-lg shadow-lg transition-transform transform hover:scale-105">
                프로필 저장
            </button>

            <div class="mt-12 pt-6 border-t border-gray-600">
                <h4 class="text-red-400 font-bold mb-2 text-sm flex items-center gap-2">
                    <span>⚠ 위험 구역</span>
                </h4>
                <p class="text-xs text-gray-500 mb-3">
                    계정을 초기화하면 모든 데이터(카드, 재화, 친구 등)가 영구적으로 삭제됩니다.
                </p>
                <button id="reset-game" class="gacha-button w-full bg-red-900/50 hover:bg-red-700 border border-red-600 text-red-100 font-bold py-3 rounded-lg shadow-lg text-sm transition-all" data-confirming="false">
                    계정 초기화
                </button>
            </div>

        </div>
    </div>
</div>

<div id="profile-card-selector-modal" class="hidden fixed inset-0 bg-black/80 flex items-center justify-center z-50">
    <div class="bg-gray-800 p-6 rounded-lg max-w-3xl w-full max-h-[80vh] flex flex-col">
        <div class="flex justify-between items-center mb-4">
            <h3 class="text-xl font-bold text-white">프로필 대표 카드 선택</h3>
            <button onclick="document.getElementById('profile-card-selector-modal').classList.add('hidden')" class="text-gray-400 hover:text-white text-2xl">&times;</button>
        </div>
        
        <div id="profile-card-list" class="grid grid-cols-3 sm:grid-cols-4 md:grid-cols-5 gap-3 overflow-y-auto p-2 bg-black/20 rounded-lg">
            </div>
    </div>
</div>
<div id="friends-view" class="hidden">
    <div class="text-center mb-6">
        <p class="text-gray-200">동료 탐정을 찾아 서고를 구경해보세요.</p>
    </div>

    <div class="flex flex-col md:flex-row gap-6 h-[70vh]">
        
        <div class="md:w-1/3 bg-black/20 p-4 rounded-xl flex flex-col h-full">
            
            <div id="friend-request-section" class="hidden mb-4 border-b border-gray-600 pb-2">
                <h3 class="text-sm font-bold text-pink-400 mb-2 flex items-center gap-2">
                    📩 도착한 요청 <span id="request-count" class="bg-red-500 text-white text-[10px] px-1.5 rounded-full">0</span>
                </h3>
                <div id="friend-request-list" class="space-y-2 max-h-40 overflow-y-auto">
                    </div>
            </div>
            <h3 class="text-xl font-bold text-yellow-300 mb-4">내 친구 목록</h3>
            <div id="friend-list-container" class="flex-1 overflow-y-auto space-y-2 pr-2">
                <p class="text-center text-gray-500 mt-10">친구가 없습니다.</p>
            </div>
        </div>

        <div class="md:w-2/3 bg-black/20 p-4 rounded-xl">
            <h3 class="text-xl font-bold text-blue-300 mb-4">탐정 검색</h3>
            <div class="flex gap-2 mb-6">
                <input type="text" id="friend-search-input" placeholder="닉네임 정확히 입력" class="flex-1 bg-gray-700 text-white px-4 py-3 rounded-lg border border-gray-600 focus:border-blue-500 outline-none">
                <button onclick="searchUserByName()" class="gacha-button bg-blue-600 hover:bg-blue-700 text-white px-6 rounded-lg font-bold">검색</button>
            </div>
            
            <div id="friend-search-result" class="hidden bg-gray-800 p-4 rounded-lg border border-gray-600 flex items-center justify-between">
                <div class="flex items-center gap-3">
                    <img id="search-result-img" src="" class="w-12 h-12 rounded bg-black object-cover">
                    <div>
                        <p id="search-result-name" class="font-bold text-white text-lg"></p>
                        <p id="search-result-msg" class="text-xs text-gray-400 italic"></p>
                    </div>
                </div>
                <div id="search-result-action"></div>
            </div>
            <p id="friend-search-msg" class="text-center text-gray-400 mt-4"></p>
        </div>

    </div>
</div>

<div id="visit-mode-overlay" class="hidden fixed bottom-6 left-1/2 -translate-x-1/2 z-40 flex flex-col items-center">
    <button onclick="exitVisitMode()" class="gacha-button bg-red-500 hover:bg-red-600 text-white px-6 py-2 rounded-full font-bold shadow-lg border-2 border-white transition-transform transform hover:scale-105">
        내 객실로 돌아가기
    </button>
</div>
            
            <div id="myroom-view" class="hidden">
				<div id="furniture-shop-modal" class="hidden fixed inset-0 bg-black/80 flex items-center justify-center z-50">
    <div class="bg-gray-800 p-6 rounded-lg max-w-2xl w-full relative">
        <button id="close-furniture-shop" class="absolute top-3 right-4 text-white text-3xl font-bold hover:text-gray-400">&times;</button>
        
        <h3 class="text-2xl font-bold text-yellow-300 mb-4">가구 상점</h3>
        <p class="text-gray-400 mb-4 text-sm">보석을 사용하여 객실을 꾸밀 가구를 구매하세요.</p>
        
        <div id="furniture-list" class="grid grid-cols-3 sm:grid-cols-4 gap-4 max-h-96 overflow-y-auto mb-4 bg-black/20 p-4 rounded-lg min-h-[100px]">
        </div>
    </div>
</div>
                <div class="text-center mb-4">
                    <p class="text-gray-200">객실을 꾸미고 등장인물들의 휴식을 지켜보세요.</p>
                </div>

                <div class="room-wrapper">
    <div id="room-container">
        
        <div class="absolute inset-0 bg-center bg-no-repeat" 
     style="background-image: url('https://i.imgur.com/aOL46H8.png');">
</div>
        
        <div class="iso-floor"></div>
        
        <div id="room-layer" class="relative w-full h-full z-10 pointer-events-none">
            <style> #room-layer > * { pointer-events: auto; } </style>
        </div>

    </div> </div> <div class="flex justify-center gap-4 mt-6">
    <button onclick="openMyRoomCharacterSelector()" class="gacha-button bg-pink-500 hover:bg-pink-600 text-white font-bold py-2 px-6 rounded-full">👥 방문객 관리</button>
    
    <button id="open-furniture-shop" onclick="openFurnitureShop()" class="gacha-button bg-yellow-500 hover:bg-yellow-600 text-black font-bold py-2 px-6 rounded-full">🪑 가구 상점</button>
    <button id="open-furniture-storage" class="hidden gacha-button bg-purple-500 hover:bg-purple-600 text-white font-bold py-2 px-6 rounded-full">📦 보관함</button>
    <button id="myroom-edit-mode" class="gacha-button bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-6 rounded-full">🔨 배치 모드</button>
</div>

<div id="furniture-storage-modal" class="hidden fixed inset-0 bg-black/80 flex items-center justify-center z-50">
    <div class="bg-gray-800 p-6 rounded-lg max-w-2xl w-full">
        <h3 class="text-2xl font-bold text-purple-300 mb-4">가구 보관함</h3>
        <p class="text-gray-400 mb-4 text-sm">배치하지 않은 가구들이 여기에 보관됩니다.</p>
        
        <div id="storage-list" class="grid grid-cols-3 gap-4 max-h-96 overflow-y-auto mb-4 bg-black/20 p-4 rounded-lg min-h-[100px]">
            </div>
        
        <button id="close-furniture-storage" class="gacha-button bg-red-500 text-white py-2 px-4 rounded-full w-full">닫기</button>
    </div>
</div>
            </div>

            <div id="toast-notification" class="hidden fixed bottom-10 left-1/2 -translate-x-1/2 bg-yellow-400 text-black font-bold py-3 px-6 rounded-full shadow-lg transition-all duration-300 z-50">
                🎉 업적 달성!
            </div>


            <div id="card-detail-modal" class="hidden fixed inset-0 bg-black/70 flex items-center justify-center z-30">
    <div class="bg-gray-800 p-6 rounded-lg max-w-lg w-full relative mx-4 max-h-[90vh] overflow-y-auto">
        <button id="close-card-detail" class="absolute top-3 right-4 text-white text-3xl font-bold hover:text-gray-400">&times;</button>
        
        <div class="flex flex-col gap-4">
            <div class="w-full md:w-3/5 mx-auto">
                <img id="detail-card-image" src="" alt="Card Image" class="w-full rounded-lg shadow-lg">
            </div>

            <div class="w-full">
                <h2 id="detail-card-name" class="text-3xl font-bold text-center"></h2>
                <div class="flex items-center justify-center gap-4 my-4">
    <p id="detail-card-rarity" class="font-bold text-2xl"></p>
    <p id="detail-card-faction" class="font-bold text-lg px-3 py-1 rounded-full"></p>
</div>

<div id="detail-parents-wrapper" class="hidden text-center mb-4 bg-white/5 p-2 rounded-lg mx-2">
    <p class="text-xs text-gray-400 mb-2">🧬 영감의 원천 (모티브)</p>
    <div id="detail-parents-container" class="flex justify-center items-center gap-6">
        </div>
</div>
<div id="enhancement-container" class="bg-black/20 p-4 rounded-lg">
    <h3 class="font-bold text-lg mb-2 text-yellow-300">등장인물 퇴고</h3>
                    <div class="flex items-center justify-between">
                        <div>
                            <p>현재 퇴고: <span id="detail-card-level" class="font-bold text-xl"></span></p>
                            <p id="enhancement-preview" class="text-sm text-green-400"></p>
                        </div>
                        <button id="enhance-card-button" class="gacha-button bg-blue-600 hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed text-white font-bold py-3 px-6 rounded-full shadow-lg">
                            퇴고하기
                            <span id="enhancement-cost" class="block text-xs"></span>
                        </button>
                    </div>
                </div>
                
                <div id="revision-container" class="mt-4 bg-black/20 p-4 rounded-lg">
    <h3 class="font-bold text-lg mb-2 text-yellow-300">개정판 제작</h3>
    
    <div class="flex justify-between items-center mb-2">
        <p>현재 단계: <span id="detail-card-revision" class="font-bold text-xl text-white"></span></p>
        <p id="revision-preview" class="text-sm text-green-400"></p>
    </div>

    <div class="mb-3 border-b border-gray-600 pb-3">
        <p class="text-xs text-gray-400 mb-1">방법 1: 동일한 원고(카드) 사용</p>
        <div class="flex gap-2">
            <select id="revision-material-select" class="flex-1 bg-gray-700 text-white p-2 rounded border border-gray-600 text-sm">
                <option value="">원본 카드 선택</option>
            </select>
            <button id="revise-card-button" class="gacha-button bg-purple-600 hover:bg-purple-700 disabled:opacity-50 disabled:cursor-not-allowed text-white font-bold py-1 px-4 rounded shadow-lg text-sm whitespace-nowrap">
                합치기
            </button>
        </div>
    </div>

    <div>
        <p class="text-xs text-gray-400 mb-1">방법 2: 특수 잉크 사용</p>
        <div class="flex justify-between items-center bg-fuchsia-900/30 p-2 rounded border border-fuchsia-500/30">
            <div class="text-sm">
                <span class="text-fuchsia-300 font-bold">💧 잉크병</span>
                <span id="inkwell-cost-display" class="text-white ml-1">0 / 0</span>
            </div>
            <button id="revise-with-inkwell-button" class="gacha-button bg-fuchsia-600 hover:bg-fuchsia-700 disabled:opacity-50 disabled:cursor-not-allowed text-white font-bold py-1 px-4 rounded shadow-lg text-sm whitespace-nowrap">
                사용하기
            </button>
        </div>
    </div>
</div>

				<div id="publication-container" class="hidden mt-4 bg-gradient-to-r from-indigo-900 to-purple-900 p-4 rounded-lg border border-yellow-400/30">
    <div class="flex justify-between items-center">
        <div>
            <h3 class="font-bold text-xl text-yellow-300 mb-1">✨ 정식 출판</h3>
            <p class="text-sm text-gray-300">완벽해진 원고를 상위 등급으로 출판합니다.</p>
            <p id="publication-target-name" class="text-sm font-bold text-white mt-1">Target: ???</p>
        </div>
        <button id="publish-card-button" class="gacha-button bg-yellow-500 hover:bg-yellow-400 text-black font-bold py-3 px-6 rounded-full shadow-[0_0_15px_rgba(234,179,8,0.5)] transition-all transform hover:scale-105">
            출판하기
        </button>
    </div>
</div>

                <div class="mt-4 bg-black/20 p-3 rounded-lg">
                    <h3 class="font-bold text-lg mb-2 text-yellow-300">능력치</h3>
                    <div class="grid grid-cols-3 gap-2 text-center">
                        <div><p class="text-sm text-gray-400">HP</p><p id="detail-stat-hp" class="font-bold text-lg"></p></div>
                        <div><p class="text-sm text-gray-400">ATK</p><p id="detail-stat-atk" class="font-bold text-lg"></p></div>
                        <div><p class="text-sm text-gray-400">DEF</p><p id="detail-stat-def" class="font-bold text-lg"></p></div>
                    </div>
                </div>
                <div class="mt-4 bg-black/20 p-3 rounded-lg">
                    <h3 class="font-bold text-lg mb-2 text-yellow-300">스킬</h3>
                    <div id="detail-skills-container" class="space-y-3"></div>
                </div>
            </div>
        </div>
        
        <div id="detail-card-story-container" class="mt-4 bg-black/20 p-4 rounded-lg">
            <h3 class="font-bold text-lg mb-2 text-yellow-300">등장인물 스토리</h3>
            <div id="detail-card-story" class="text-gray-300 text-sm story-content h-24 overflow-y-auto"></div>
            <div id="detail-story-pagination" class="flex justify-center items-center mt-2">
                <button id="detail-story-prev" class="gacha-button text-white font-bold py-1 px-4 rounded-full text-sm">&lt; 이전</button>
                <span id="detail-story-page-indicator" class="mx-4 text-sm"></span>
                <button id="detail-story-next" class="gacha-button text-white font-bold py-1 px-4 rounded-full text-sm">다음 &gt;</button>
            </div>
        </div>

        <div id="dismantle-container" class="mt-4 bg-red-800/20 p-4 rounded-lg flex justify-between items-center">
            <p class="font-bold text-md text-red-300">파쇄 (재료 회수)</p>
            <button id="dismantle-card-button" class="gacha-button bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-full shadow-lg text-sm">
                파쇄하기
            </button>
        </div>
    </div>
</div>

<div id="gacha-pool-modal" class="hidden fixed inset-0 bg-black/80 flex items-center justify-center z-[100]">
    <div class="bg-gray-800 p-6 rounded-lg max-w-2xl w-full relative h-[80vh] flex flex-col border border-yellow-500/50">
        <div class="flex justify-between items-center mb-4 border-b border-gray-600 pb-2">
            <h3 id="pool-modal-title" class="text-2xl font-bold text-yellow-300">획득 가능 목록</h3>
            <button onclick="document.getElementById('gacha-pool-modal').classList.add('hidden')" class="text-gray-400 hover:text-white text-3xl">&times;</button>
        </div>
        <div id="pool-list-container" class="flex-1 overflow-y-auto space-y-4 bg-black/20 p-4 rounded-lg">
            </div>
    </div>
</div>

<div id="mailbox-modal" class="hidden fixed inset-0 bg-black/80 flex items-center justify-center z-50">
    <div class="bg-gray-800 p-6 rounded-lg max-w-2xl w-full relative border border-indigo-400 h-[80vh] flex flex-col">
        
        <button onclick="document.getElementById('mailbox-modal').classList.add('hidden')" class="absolute top-3 right-4 text-gray-400 hover:text-white text-3xl font-bold z-10">&times;</button>
        
        <div class="flex justify-between items-center mb-2 border-b border-gray-600 pb-2 mr-8">
            <h3 class="text-2xl font-bold text-indigo-300 flex items-center gap-2">
                <span>📩</span> 우편함
            </h3>
        </div>

        <p class="text-gray-400 text-xs mb-2 text-center">* 우편은 최대 30일간 보관됩니다.</p>
        
        <div id="mailbox-list" class="flex-1 overflow-y-auto space-y-2 bg-black/20 p-2 rounded-lg pr-2 mb-4">
            </div>

        <div class="mt-auto border-t border-gray-600 pt-4 flex justify-center">
            <button onclick="claimAllMails()" class="gacha-button bg-yellow-500 hover:bg-yellow-600 text-black font-bold py-3 px-10 rounded-full text-lg shadow-lg w-full md:w-auto transform transition-transform hover:scale-105">
                🎁 모두 받기
            </button>
        </div>

    </div>
</div>
            
            <div id="dismantle-result-modal" class="hidden fixed inset-0 bg-black/70 flex justify-center items-center z-40">
                <div class="bg-gray-800 p-8 rounded-lg text-center max-w-sm w-full">
                    <h2 class="text-3xl font-bold mb-4 text-yellow-300">원고 파쇄 결과</h2>
                    <p class="text-lg mb-6 text-gray-300">파쇄가 완료되었습니다.</p>
                    
                    <div id="dismantle-rewards-list" class="space-y-3 mb-6 bg-black/30 p-4 rounded-lg">
                        </div>

                    <button id="close-dismantle-result" class="gacha-button bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-6 rounded-full">확인</button>
                </div>
            </div>
            
            <div id="interactive-story-modal" class="hidden fixed inset-0 bg-black/50 flex flex-col justify-end z-40">
                <div id="story-char-container" class="absolute inset-0 pointer-events-none overflow-hidden z-0">
    
    <img id="story-char-left" src="" alt="Left Character" 
         class="story-char absolute bottom-[30%] md:bottom-[20%] left-0 md:left-[5%] max-h-[70vh] md:max-h-[85vh] w-auto max-w-[65%] md:max-w-[45%] opacity-0 transition-all duration-500 transform translate-y-10 -scale-x-100 object-contain object-bottom">
    
    <img id="story-char-right" src="" alt="Right Character" 
         class="story-char absolute bottom-[30%] md:bottom-[20%] right-0 md:right-[5%] max-h-[70vh] md:max-h-[85vh] w-auto max-w-[65%] md:max-w-[45%] opacity-0 transition-all duration-500 transform translate-y-10 object-contain object-bottom">
</div>
                
                <div id="dialogue-box" class="relative bg-black/70 backdrop-blur-sm m-4 p-5 rounded-xl border border-white/20 text-white z-10">
                    <h3 id="speaker-name" class="font-bold text-2xl text-yellow-300 mb-2"></h3>
                    <p id="dialogue-text" class="text-lg leading-relaxed h-24 overflow-y-auto pr-2 custom-scrollbar"></p>
                    <div id="choice-buttons-container" class="mt-4 flex flex-col items-center gap-2"></div>
                    <button id="story-next-button" class="absolute bottom-4 right-5 text-xl animate-pulse">▼ 다음</button>
                </div>
                <button id="story-skip-button" class="absolute top-5 right-5 bg-black/50 text-white py-2 px-4 rounded-full z-20">스킵</button>
            </div>

            <div id="choice-stats-modal" class="hidden fixed inset-0 bg-black/80 flex items-center justify-center z-50">
                <div class="bg-gray-800 p-8 rounded-lg max-w-md w-full text-center">
                    <h2 class="text-2xl font-bold text-yellow-300 mb-6">다른 탐정들의 선택</h2>
                    <div id="stats-container" class="space-y-4">
                        </div>
                    <button id="close-stats-modal" class="gacha-button mt-8 bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-6 rounded-full">확인</button>
                </div>
            </div>

			<div id="trade-select-card-modal" class="hidden fixed inset-0 bg-black/80 flex items-center justify-center z-50">
    <div class="bg-gray-800 p-6 rounded-lg max-w-2xl w-full relative border border-gray-600">
        <h3 class="text-2xl font-bold text-yellow-300 mb-2">보낼 카드 선택</h3>
        <p class="text-gray-400 mb-4 text-sm">조건에 맞는 카드가 여러 장 있습니다.<br>상대방에게 보낼 카드를 선택해주세요.</p>
        
        <div id="trade-select-list" class="grid grid-cols-3 sm:grid-cols-4 gap-4 max-h-96 overflow-y-auto mb-4 bg-black/20 p-4 rounded-lg">
        </div>
        
        <button onclick="document.getElementById('trade-select-card-modal').classList.add('hidden')" class="gacha-button bg-red-500 hover:bg-red-600 text-white py-3 px-4 rounded-full w-full font-bold">취소</button>
    </div>
</div>

<div id="myroom-char-selector-modal" class="hidden fixed inset-0 bg-black/80 flex items-center justify-center z-50">
    <div class="bg-gray-800 p-6 rounded-lg max-w-2xl w-full h-[80vh] flex flex-col border border-pink-400">
        <div class="flex justify-between items-center mb-2">
            <h3 class="text-xl font-bold text-pink-300">객실 방문객 설정</h3>
            <span id="myroom-selected-count" class="text-white font-bold bg-pink-600 px-3 py-1 rounded-full text-sm">0 / 5</span>
        </div>
        <p class="text-gray-400 text-sm mb-2 text-center">객실에 머물게 할 등장인물을 선택하세요. (최대 5명)</p>
        
        <div id="myroom-filter-container" class="flex justify-center gap-2 mb-4">
            <button data-filter="All" class="myroom-filter-btn gacha-button bg-blue-500 text-white font-bold py-1 px-3 rounded-full text-xs hover:bg-blue-600">전체</button>
            <button data-filter="SSR" class="myroom-filter-btn gacha-button bg-gray-600 text-white font-bold py-1 px-3 rounded-full text-xs hover:bg-gray-700">SSR</button>
            <button data-filter="SR" class="myroom-filter-btn gacha-button bg-gray-600 text-white font-bold py-1 px-3 rounded-full text-xs hover:bg-gray-700">SR</button>
            <button data-filter="R" class="myroom-filter-btn gacha-button bg-gray-600 text-white font-bold py-1 px-3 rounded-full text-xs hover:bg-gray-700">R</button>
            <button data-filter="N" class="myroom-filter-btn gacha-button bg-gray-600 text-white font-bold py-1 px-3 rounded-full text-xs hover:bg-gray-700">N</button>
        </div>

        <div id="myroom-char-list" class="grid grid-cols-4 sm:grid-cols-5 gap-3 overflow-y-auto p-2 bg-black/20 rounded-lg flex-grow">
            </div>

        <div class="flex gap-2 mt-4">
            <button onclick="saveMyRoomCharacters()" class="flex-1 gacha-button bg-pink-600 hover:bg-pink-700 text-white font-bold py-3 rounded-lg shadow-lg">저장하기</button>
            <button onclick="document.getElementById('myroom-char-selector-modal').classList.add('hidden')" class="w-1/4 gacha-button bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 rounded-lg">취소</button>
        </div> </div> 
		<div id="combat-result-modal" class="hidden fixed inset-0 bg-black/70 flex justify-center items-center z-[9999]">
                    <div class="bg-gray-800 p-8 rounded-lg text-center">
                        <h2 id="combat-result-title" class="text-4xl font-bold mb-4"></h2>
                        <p id="combat-result-message" class="text-lg mb-6"></p>
                        <button id="close-combat-result" class="gacha-button bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-6 rounded-full">확인</button>
                    </div>
                </div>
		</main> </div> <script src="yumecan_data.js"></script>
	
    <script>
	
	const firebaseConfig = {
        apiKey: "AIzaSyDNradWwvrFqZHbmlfavgiN8a7ll_Jb2Sg",
        authDomain: "kside-5db33.firebaseapp.com",
        projectId: "kside-5db33",
        storageBucket: "kside-5db33.appspot.com",
        messagingSenderId: "381837651487",
        appId: "1:381837651487:web:447bff3a3f83abbde66f2a",
    };

    // Firebase 초기화
    firebase.initializeApp(firebaseConfig);
    const db = firebase.firestore();
    const auth = firebase.auth(); // 인증 서비스 변수 추가

    let currentCombatIndices = null; 
let currentCombatType = null;
raidBossDataSheet = null;
let currentCollectionGroup = '히어로 대 빌런: 각축전';
	// ▼▼▼ [수정] 도감 그룹 관리 변수 ▼▼▼
let currentCollectionSelection = null;
// 탭으로 만들 그룹 목록 (순서대로 나옵니다)
const COLLECTION_GROUPS = ['히어로 대 빌런: 각축전', '사제와 악마: 고해소', 'NPC'];

    // DOM이 모두 로드된 후 게임 스크립트 실행
    document.addEventListener('DOMContentLoaded', async () => {
	document.body.classList.add('loading');
	const eventSubTabBattle = document.getElementById('event-sub-tab-battle');
        const eventSubTabRaid = document.getElementById('event-sub-tab-raid');
        const eventSubTabStory = document.getElementById('event-sub-tab-story');
        const eventSubTabShop = document.getElementById('event-sub-tab-shop'); // ✨ 이제 shop 버튼을 찾을 수 있습니다.
		// ✨ [신규] 전투 항복 버튼 리스너
document.getElementById('combat-run-button').addEventListener('click', () => {
    if (confirm("정말로 항복하고 안정화를 중단하시겠습니까? (패배 처리됩니다)")) {
        fleeCombat();
    }
});
	await loadGameData();
	checkEndedEvents();
	const exitMultiModeButton = document.getElementById('exit-multi-mode');
    const enterMultiModeButton = document.getElementById('enter-multi-mode');

        // --- 인증 상태 감지 리스너 ---
        auth.onAuthStateChanged(user => {
            const loginView = document.getElementById('login-view');
            const loggedInView = document.getElementById('logged-in-view');
            
            if (user) {
                currentUser = user;
                loginView.classList.add('hidden');
                loggedInView.classList.remove('hidden');
                document.getElementById('nickname-display').textContent = user.displayName || user.email;

                loadGameFromFirebase(user.uid);
                
                // ✨ [추가] 친구 요청 실시간 감시 시작
                startFriendListener(user.uid);
				startMailListener(user.uid);
				startPeriodicMailCheck(user.uid);
				startTradeListener(user.uid);

            } else {
                // --- 유저가 로그아웃했을 때 ---
                currentUser = null;
                loginView.classList.remove('hidden');
                loggedInView.classList.add('hidden');
				startBookmarkRegenTimer();
                
                // ================== 👇 4. 로딩 상태 비활성화 👇 ==================
                // 로딩 화면을 숨겨서 로그인/회원가입을 할 수 있도록 합니다.
                document.getElementById('loading-overlay').classList.add('hidden');
                document.body.classList.remove('loading');
                // ===============================================================
				
				if (window.mailCheckInterval) clearInterval(window.mailCheckInterval);
            }
        });
		
		


	// gacha3.html - downloadSaveData 함수 (기존 함수 전체 교체)

function downloadSaveData() {
    const saveDataString = localStorage.getItem(SAVE_DATA_KEY);
    if (!saveDataString) {
        showMessage('저장된 게임 데이터가 없습니다!', 'text-red-400', messageArea);
        return;
    }

    try {
        // 1. 저장된 JSON 문자열을 UTF-8 안전 Base64로 인코딩
        const encodedData = utf8_to_b64(saveDataString); // ✨ 수정된 함수 사용 ✨

        // 2. 파일 생성 및 다운로드 링크 생성
        const blob = new Blob([encodedData], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        
        // 파일명: Kside_Save_20251019.txt (현재 날짜 사용)
        const now = new Date();
        const dateString = `${now.getFullYear()}${String(now.getMonth() + 1).padStart(2, '0')}${String(now.getDate()).padStart(2, '0')}`;
        a.download = `Kside_Save_${dateString}.txt`;
        
        // 3. 요소 추가, 클릭, 제거 및 URL 해제
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        alert('게임 데이터가 다운로드되었습니다.'); // ✅ 이 코드가 사용되었는지 확인합니다.
    } catch (e) {
        console.error("다운로드 처리 중 오류 발생:", e);
        alert("데이터 다운로드에 실패했습니다. (오류: 콘솔 확인)");
    }
}

			function utf8_to_b64(str) {
    return btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g,
        function toSolidBytes(match, p1) {
            return String.fromCharCode('0x' + p1);
    }));
}

// Base64를 UTF-8 문자열로 안전하게 디코딩하는 함수 (한글 처리)
function b64_to_utf8(str) {
    return decodeURIComponent(atob(str).split('').map(function(c) {
        return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
    }).join(''));
}
			
			function uploadSaveData(file) {
    const reader = new FileReader();
    
    reader.onload = function(event) {
        try {
            let encodedData = event.target.result;
            
            // ✨ 핵심 수정: 양쪽 끝의 공백, 줄바꿈 등을 제거하여 데이터 클리닝 ✨
            encodedData = encodedData.trim();
            
            // 1. Base64 안전 디코딩
            const jsonString = b64_to_utf8(encodedData); 
            
            // 2. JSON 파싱 테스트 (데이터 유효성 검사)
            const parsedData = JSON.parse(jsonString); 
            
            // 3. 유효성 추가 확인 (예: 인벤토리 키가 있는지 확인)
            if (!parsedData || !Array.isArray(parsedData.inventory)) {
                throw new Error("파싱된 데이터 구조가 유효하지 않습니다.");
            }
            
            // 4. 유효한 데이터이므로 localStorage에 저장하고 로드
            localStorage.setItem(SAVE_DATA_KEY, jsonString);
            
            alert("데이터 로드 성공! 게임이 새로고침됩니다.");
            location.reload();

        } catch (e) {
            console.error("데이터 로드 오류:", e);
            alert(`⚠️ 유효하지 않은 저장 파일입니다. 오류: ${e.message}`);
            // showMessage는 이 시점에서 DOM이 새로 로드되기 때문에 의미 없습니다.
            // alert만 표시하고 끝냅니다.
        }
    };
    
    reader.onerror = function() {
        alert("파일을 읽는 도중 오류가 발생했습니다.");
    };

    // FileReader는 이 시점에만 호출됩니다.
    reader.readAsText(file);
}
		const SAVE_DATA_KEY = 'gachaGameSaveData_v9';
const GRID_SIZE = 100; 
    const TILE_WIDTH_PERCENT = 9;  
    const TILE_HEIGHT_PERCENT = 5;
            

            // --- 게임 상태 ---
	// ✨ [신규] 등급별 잉크병 개정 비용 (잉크병 몇 개로 개정할 수 있는지)
const INKWELL_REVISION_COSTS = {
    'N': 1,    // N 등급은 1개
    'R': 3,    // R 등급은 3개
    'SR': 5,   // SR 등급은 5개
    'SSR': 10  // SSR 등급은 10개 (가장 비쌈)
};

// ✨ [신규] 레이드 토벌 보상 설정
const RAID_RANK_REWARDS = {
    1: { currency: 1000, fountainPens: 500, title: "레이드 기여도 1위 보상" },
    2: { currency: 700, fountainPens: 300, title: "레이드 기여도 2위 보상" },
    3: { currency: 500, fountainPens: 200, title: "레이드 기여도 3위 보상" },
    top5: { currency: 300, fountainPens: 100, title: "레이드 기여도 Top 5 보상" }, // 4~5위
    participation: { currency: 100, fountainPens: 50, title: "레이드 토벌 참가 보상" } // 그 외
};

// ✨ [신규] 이벤트 랭킹 보상 설정
const EVENT_RANK_REWARDS = {
    1: { currency: 3000, fountainPens: 1000, title: "이벤트 1위" },
    2: { currency: 2000, fountainPens: 800, title: "이벤트 2위" },
    3: { currency: 1500, fountainPens: 600, title: "이벤트 3위" },
    top10: { currency: 1000, fountainPens: 500, title: "이벤트 Top 10" },
    top50: { currency: 500, fountainPens: 300, title: "이벤트 Top 50" },
    participation: { currency: 200, fountainPens: 100, title: "이벤트 참가상" }
};
	
			const DISMANTLE_REWARDS = {
    'N': { fountainPens: 10, inkwells: 0 },
    'R': { fountainPens: 30, inkwells: 0 },
    'SR': { fountainPens: 50, inkwells: 1 },
    'SSR': { fountainPens: 100, inkwells: 3 }, // SSR 파쇄 시 잉크병 3개 지급
};
			const MAX_REVISION_LEVEL = 5; // ✨ 최대 개정 레벨
const STAT_INCREASE_PER_REVISION = 0.10; // ✨ 개정 1단계당 기본 능력치 10% 증가
			const MAX_ENHANCEMENT_LEVEL = 9;
const ENHANCEMENT_COSTS = [5, 10, 15, 25, 40, 60, 85, 115, 150]; // 레벨 0->1, 1->2, ..., 8->9 비용
			const ENHANCEMENT_BASE_COSTS = [5, 10, 15, 25, 40, 60, 85, 115, 150]; // 👈 이 코드를 추가
		// ✨ [추가] 퇴고 성공 확률 정의 (0->1, 1->2, ..., 8->9)
// 1.0은 100%, 0.5는 50%입니다.
const ENHANCEMENT_PROBABILITIES = [1.0, 0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2];
const RARITY_COST_MULTIPLIER = { // 👈 이 코드를 추가
    'N': 0.7,
    'R': 1.0,
    'SR': 1.3,
    'SSR': 1.6,
};
const STAT_INCREASE_PER_LEVEL = 0.05; // 레벨당 기본 능력치의 5% 증가
let currentUser = null; 
            let currentPlayerNickname = "익명의 탐정";
			// 전역 변수 선언부 (스크립트 맨 위쪽)
let playerProfile = { repCardId: null, statusMessage: "" }; // 반드시 초기값을 줘야 합니다!
			let currentTradeRarityFilter = 'All';
            let playerCurrency = 100;
			let playerChoices = {};
			let playerFountainPens = 500; // 🖋️
			let playerInkwells = 0;
			let currentEventChoice = null;
			let isMultiSelectMode = false; // ✨ 다중 선택 모드 상태 추가
            let selectedCardsToDismantle = new Set(); // ✨ 선택된 카드 ID Set 추가
            let playerInventory = [];
			let playerTutorialFinished = true;
			let collectedCardNames = new Set(); // 👈 이 줄을 추가하세요.
		let playerRoom = { furniture: [], characters: [] }; // 마이룸 데이터 (가구 배치, 캐릭터)
let ownedFurniture = []; // 보유한 가구 목록
			let isSortAscending = false; // ✨ 정렬 방향 변수 추가 (false: 내림차순, true: 오름차순)
            let playerDeck = [];
            let inventoryCapacity = 100;
            let representativeCharacter = null;
            let isCombatRunning = false;
            let combatSpeedMultiplier = 1;
            let lastCombatType = 'main'; // 마지막 전투 유형을 저장합니다.
            let clearedStages = [];
            let clearedEventDungeons = [];
			let isDismantling = false;
            let playerEventPoints = 0;
            let purchasedEventItems = {};
            let currentStoryPages = [];
            let currentStoryPageIndex = 0;
            let playerBookmarks = 10;
            const MAX_BOOKMARKS = 10;
			const HARD_MAX_BOOKMARKS = 30; // ✨ 최대 축적 한도 (이벤트/업적용)
            let lastBookmarkUpdateTime = Date.now();
            const BOOKMARK_REGEN_TIME = 5 * 60 * 1000; // 5 minutes
            let playerAchievements = {}; // { ach_001: 'unlocked' | 'claimed' }
            let playerStats = { totalPulls: 0 };
			let currentInteractiveStory = null; // 이 줄 추가
			let currentSceneIndex = 0; // 이 줄 추가
			let currentSortOrder = 'rarity';
			let currentRarityFilter = 'All'; // 👈 이 줄을 추가하세요.
			let clearedStageStories = []; 
			// [기존 변수들 아래에 추가]
let playerCumulativeEventPoints = 0; // 🏆 랭킹용 누적 포인트
let playerSystemMailHistory = []; // ✨ 이 줄이 있어야 합니다.
let playerRaidDailyCount = 0;
let playerRaidLastResetDate = null;
			let playerRaidDamage = 0;

            const DECK_CAPACITY = 5;
            const PULL_ONE_COST = 10;
            const PULL_TEN_COST = 100;
            const EXPAND_COST = 50;
            const EXPAND_AMOUNT = 10;
			
			let breedingSlots = { a: null, b: null }; // 슬롯 상태

// 등급별 구상 비용
const BREEDING_COSTS = {
    'N':   { gem: 10,  pen: 30 },
    'R':   { gem: 30,  pen: 100 },
    'SR':  { gem: 100, pen: 300 },
    'SSR': { gem: 300, pen: 1000 }
};

// 등급 순서 및 스탯 가중치 (등급 하락 시 스탯 페널티 계산용)
const RARITY_ORDER = ['N', 'R', 'SR', 'SSR'];
const RARITY_STATS_WEIGHT = {
    'SSR': 100,
    'SR': 70,
    'R': 45,
    'N': 25
};
// [신규] 등급 간 스탯 상승 배율 (N -> R -> SR -> SSR 순)
// 예: SR(70점)에서 SSR(100점)로 가면 약 1.42배 강해짐
const RARITY_MULTIPLIER = {
    'N': 1.0,
    'R': 1.8,   // N 대비 1.8배
    'SR': 2.8,  // N 대비 2.8배 (R 대비 약 1.5배)
    'SSR': 4.0  // N 대비 4.0배 (SR 대비 약 1.4배)
};
            

            // --- HTML 요소 가져오기 ---
			const dismantleMultiUI = document.getElementById('dismantle-multi-ui');

const selectedCardCountSpan = document.getElementById('selected-card-count');
const dismantleSelectedButton = document.getElementById('dismantle-selected-button');
			const fountainPenDisplay = document.getElementById('fountainpen-display');
            const currencyDisplay = document.getElementById('currency-display');
            const messageArea = document.getElementById('message-area');
            // 1. 전역 변수 선언 (자동으로 모든 탭과 뷰를 잡도록 설정)
            const allTabs = document.querySelectorAll('.tab-button');
            // 모달창을 제외한 메인 뷰들을 자동으로 모두 가져옵니다.
            const allViews = document.querySelectorAll(
              'main > div:not(#combat-result-modal):not(#card-detail-modal):not(#interactive-story-modal)'
            );
            const pullOneButton = document.getElementById('pull-one');
            const pullTenButton = document.getElementById('pull-ten');
            const pullOneEventButton = document.getElementById('pull-one-event');
            const pullTenEventButton = document.getElementById('pull-ten-event');
            const resultsContainer = document.getElementById('results-container');
            const inventoryContainer = document.getElementById('inventory-container');
            const inventoryStatus = document.getElementById('inventory-status');
            const expandInventoryButton = document.getElementById('expand-inventory');
            const deckStatus = document.getElementById('deck-status');
            const deckSlotsContainer = document.getElementById('deck-slots-container');
            const deckInventoryContainer = document.getElementById('deck-inventory-container');
            const autoFillDeckButton = document.getElementById('auto-fill-deck');
            const deckPowerDisplay = document.getElementById('deck-power-display');
            const combatMessageArea = document.getElementById('combat-message-area');
            const dungeonListContainer = document.getElementById('dungeon-list-container');
            const homeCharacterContainer = document.getElementById('home-character-container');
            const homeCharacterImage = document.getElementById('home-character-image');
            const homeDialogueContainer = document.getElementById('home-dialogue-container');
            const homeDefaultMessage = document.getElementById('home-default-message');
            const homeCharacterName = document.getElementById('home-character-name');
            const homeCharacterDialogue = document.getElementById('home-character-dialogue');
            const eventBanner = document.getElementById('event-banner');
            const eventBannerText = document.getElementById('event-banner-text');
            const gachaTabNormal = document.getElementById('gacha-tab-normal');
            const gachaTabEvent = document.getElementById('gacha-tab-event');
            const normalGachaView = document.getElementById('normal-gacha-view');
            const eventGachaView = document.getElementById('event-gacha-view');
            const eventGachaInfo = document.getElementById('event-gacha-info');
            const resetButton = document.getElementById('reset-game');
            const storageWarning = document.getElementById('storage-warning');
            const combatInProgressView = document.getElementById('combat-in-progress-view');
            const combatPlayerDeck = document.getElementById('combat-player-deck');
            const combatMonsterArea = document.getElementById('combat-monster-area');
            const combatLogContainer = document.getElementById('combat-log-container');
            const combatLog = document.getElementById('combat-log');
            const combatResultModal = document.getElementById('combat-result-modal');
            const combatResultTitle = document.getElementById('combat-result-title');
            const combatResultMessage = document.getElementById('combat-result-message');
            const closeCombatResultButton = document.getElementById('close-combat-result');
            const cardDetailModal = document.getElementById('card-detail-modal');
            const closeCardDetailButton = document.getElementById('close-card-detail');
            const speed1xButton = document.getElementById('speed-1x');
            const speed2xButton = document.getElementById('speed-2x');
            const speed4xButton = document.getElementById('speed-4x');
            const collectionContainer = document.getElementById('collection-container');
            const mainStoryContainer = document.getElementById('main-story-container');
            const eventTab = document.getElementById('tab-event');
            const eventPointDisplay = document.getElementById('event-point-display');
            const eventPointsSpan = document.getElementById('event-points');
            // ✨ 이벤트 뷰의 서브 탭 리스너 (중복 오류 방지용 수정)
        {
            const btnBattle = document.getElementById('event-sub-tab-battle');
            if (btnBattle) {
                btnBattle.onclick = function() {
                    displayEventView(); 
                    switchEventSubTab('battle'); 
                };
            }

            const btnRaid = document.getElementById('event-sub-tab-raid');
            if (btnRaid) {
                btnRaid.onclick = function() {
                    displayEventView(); 
                    switchEventSubTab('raid'); 
                    // 레이드 데이터 리스너가 필요하다면 여기서 호출
                    if (typeof initRaidListener === 'function') initRaidListener();
                };
            }

            const btnStory = document.getElementById('event-sub-tab-story');
            if (btnStory) {
                btnStory.onclick = function() {
                    displayEventView(); 
                    switchEventSubTab('story'); 
                };
            }

            const btnShop = document.getElementById('event-sub-tab-shop');
            if (btnShop) {
                btnShop.onclick = function() {
                    displayEventView(); 
                    switchEventSubTab('shop'); 
                };
            }
        }
            const eventBattleView = document.getElementById('event-battle-view');
            const eventStoryView = document.getElementById('event-story-view');
            const eventShopView = document.getElementById('event-shop-view');
            const eventDungeonListContainer = document.getElementById('event-dungeon-list-container');
            const eventStoryContainer = document.getElementById('event-story-container');
            const eventShopContainer = document.getElementById('event-shop-container');
            const bookmarkDisplay = document.getElementById('bookmark-display');
            const maxBookmarkDisplay = document.getElementById('max-bookmark-display');
            const bookmarkTimerContainer = document.getElementById('bookmark-timer-container'); 
            const achievementsContainer = document.getElementById('achievements-container'); // ✅ 여기서 명확하게 선언
            const toastNotification = document.getElementById('toast-notification');
			const synergyList = document.getElementById('synergy-list');
			const dismantleCardButton = document.getElementById('dismantle-card-button');
			const dismantleResultModal = document.getElementById('dismantle-result-modal');
const dismantleRewardsList = document.getElementById('dismantle-rewards-list');
const closeDismantleResultButton = document.getElementById('close-dismantle-result');

			// ✨ 파일 업로드 요소 추가 ✨
			const uploadFile = document.getElementById('upload-file'); // ✅ 이 라인을 추가하세요.
			
			// [수정] 스테이지 컨테이너 변수를 이벤트 아카이브 변수로 교체
const eventArchiveContainer = document.getElementById('event-archive-container'); // stageStoryContainer 대신 사용
const storySubTabMain = document.getElementById('story-sub-tab-main');
const storySubTabArchive = document.getElementById('story-sub-tab-archive'); // storySubTabStage 대신 사용
			const interactiveStoryModal = document.getElementById('interactive-story-modal');
			const storyCharLeft = document.getElementById('story-char-left');
			const storyCharRight = document.getElementById('story-char-right');
			const speakerName = document.getElementById('speaker-name');
			const dialogueText = document.getElementById('dialogue-text');
			const storyNextButton = document.getElementById('story-next-button');
			const storySkipButton = document.getElementById('story-skip-button');
			const detailStoryPrevButton = document.getElementById('detail-story-prev');
            const detailStoryNextButton = document.getElementById('detail-story-next');
			const storyView = document.getElementById('story-view');
            
            // --- 데이터 저장/불러오기 함수 ---
            function isStorageAvailable() {
                try {
                    const key = "__test_localstorage__";
                    localStorage.setItem(key, key);
                    localStorage.removeItem(key);
                    return true;
                } catch (e) {
                    return false;
                }
            }

            // [추가] undefined 값을 찾아서 null로 바꿔주는 안전장치 함수
function removeUndefined(obj) {
    // 배열일 경우 내부 요소 재귀 처리
    if (Array.isArray(obj)) {
        return obj.map(v => removeUndefined(v));
    }
    // 객체일 경우 내부 속성 재귀 처리
    else if (obj !== null && typeof obj === 'object') {
        return Object.keys(obj).reduce((acc, key) => {
            const value = obj[key];
            // 값이 undefined면 null로 변경, 아니면 재귀 호출
            acc[key] = (value === undefined) ? null : removeUndefined(value);
            return acc;
        }, {});
    }
    // 기본 자료형일 경우 undefined 체크
    return (obj === undefined) ? null : obj;
}

// [수정] 기존 saveGameToFirebase 함수 수정
async function saveGameToFirebase() {
    if (!currentUser) return;

    const currentProfile = playerProfile || {};

    const safeProfile = {
        repCardId: currentProfile.repCardId || null,
        statusMessage: currentProfile.statusMessage || ""
    };

    // 저장할 데이터 객체 생성
    const rawSaveData = {
        nickname: currentPlayerNickname || "익명의 탐정",
        currency: playerCurrency || 0,
        fountainPens: playerFountainPens || 0,
        inkwells: playerInkwells || 0,
        inventory: playerInventory || [],
        deck: playerDeck.map(card => card.id),
        capacity: inventoryCapacity || 100,
        representative: representativeCharacter ? representativeCharacter.name : null,
        clearedStages: clearedStages || [],
        currentEventId: (typeof CURRENT_EVENT_ID !== 'undefined') ? CURRENT_EVENT_ID : null,
        eventPoints: playerEventPoints || 0,
        cumulativeEventPoints: playerCumulativeEventPoints || 0,
        raidCumulativeDamage: playerRaidDamage || 0,
        raidDailyCount: playerRaidDailyCount || 0,
        // ✨ [핵심 수정 1] 누적 데미지 초기화 방지: 보스 ID 필드 추가
        lastRaidSpawnId: (typeof playerLastRaidSpawnId !== 'undefined') ? playerLastRaidSpawnId : 0,
        
        clearedEventDungeons: clearedEventDungeons || [],
        purchasedEventItems: purchasedEventItems || {},
        bookmarks: playerBookmarks || 0,
        lastBookmarkUpdate: lastBookmarkUpdateTime || Date.now(),
        achievements: playerAchievements || {},
        stats: playerStats || { totalPulls: 0 },
        clearedStageStories: clearedStageStories || [],
        playerChoices: playerChoices || {},
        collectedCardNames: Array.from(collectedCardNames || []),
        myRoom: playerRoom || { furniture: [], characters: [] },
        ownedFurniture: ownedFurniture || [],
        systemMailHistory: playerSystemMailHistory || [],
        
        // 프로필 데이터
        profile: safeProfile
    };

    // ✨ [핵심 수정 2] 날짜 저장 로직 개선 (Date 객체 여부와 상관없이 값이 있으면 저장 시도)
    if (playerRaidLastResetDate) {
        rawSaveData.raidLastResetDate = playerRaidLastResetDate;
    }

    // undefined를 null로 변환
    const finalSaveData = removeUndefined(rawSaveData);

    try {
        // merge: true 옵션을 추가하여 혹시 모를 필드 삭제 방지 (권장)
        await db.collection('users').doc(currentUser.uid).set(finalSaveData, { merge: true });
        console.log("게임 데이터가 Firebase에 저장되었습니다.");
    } catch (error) {
        console.error("Firebase 저장 중 오류 발생:", error);
    }
}

            // ✅ 이 코드로 기존 loadGame 함수를 통째로 교체해주세요.
           // ✅ 이 코드로 기존 loadGameFromFirebase 함수를 통째로 교체해주세요.
async function loadGameFromFirebase(uid) {
    const docRef = db.collection('users').doc(uid);
    const doc = await docRef.get();

    if (doc.exists) {
        console.log("Firebase에서 게임 데이터를 불러옵니다.");
        const savedData = doc.data();
        
        // 1. 기본 정보 로드
        currentPlayerNickname = savedData.nickname || currentUser.displayName || "익명의 탐정";
        document.getElementById('nickname-display').textContent = currentPlayerNickname;

        playerCurrency = savedData.currency ?? 100;
        playerFountainPens = savedData.fountainPens ?? 500;
        playerInkwells = savedData.inkwells ?? 0;
        
        // 2. 인벤토리 및 덱 로드
        const loadedInventory = savedData.inventory || [];
        playerInventory = loadedInventory.map(card => ({
            ...card,
            revision: (card.revision !== undefined && card.revision !== null) ? card.revision : 0,
            level: (card.level !== undefined && card.level !== null) ? card.level : 0
        }));

        collectedCardNames = new Set(savedData.collectedCardNames || []);
        playerInventory.forEach(card => collectedCardNames.add(card.name));

        const savedDeckIds = savedData.deck || [];
        playerDeck = savedDeckIds.map(id => playerInventory.find(card => card.id === id)).filter(Boolean);
        
        // 3. 마이룸 및 가구 로드
        playerRoom = savedData.myRoom || { furniture: [], characters: [] };
        if (!Array.isArray(playerRoom.furniture)) playerRoom.furniture = [];
        if (!Array.isArray(playerRoom.characters)) playerRoom.characters = [];
        ownedFurniture = savedData.ownedFurniture || [];
        
        inventoryCapacity = savedData.capacity ?? 100;
        if (savedData.representative) {
            representativeCharacter = findCharacter(savedData.representative) || null;
        }
        
        clearedStages = savedData.clearedStages || [];
        playerBookmarks = savedData.bookmarks ?? MAX_BOOKMARKS;
        lastBookmarkUpdateTime = savedData.lastBookmarkUpdate ?? Date.now();
        playerAchievements = savedData.achievements || {};
        playerStats = savedData.stats || { totalPulls: 0 };
        clearedStageStories = savedData.clearedStageStories || [];
        
        // ============================================================
        // ✨ [핵심 수정] 이벤트 및 레이드 데이터 로드
        // ============================================================
        
        playerEventPoints = savedData.eventPoints !== undefined ? savedData.eventPoints : 0;
        playerCumulativeEventPoints = savedData.cumulativeEventPoints !== undefined ? savedData.cumulativeEventPoints : playerEventPoints;
        
        playerRaidDamage = savedData.raidCumulativeDamage !== undefined ? savedData.raidCumulativeDamage : 0;
        // ✨ 여기서 저장된 보스 ID를 확실하게 불러옵니다.
        playerLastRaidSpawnId = savedData.lastRaidSpawnId || 0; 
        
        clearedEventDungeons = savedData.clearedEventDungeons || [];
        purchasedEventItems = savedData.purchasedEventItems || {};
        playerChoices = savedData.playerChoices || {};
        playerSystemMailHistory = savedData.systemMailHistory || [];

        // 4-1. 이벤트 ID 불일치 체크
        if (CURRENT_EVENT_ID && savedData.currentEventId !== CURRENT_EVENT_ID) {
            console.log(`새로운 이벤트[${CURRENT_EVENT_ID}] 감지. 점수판을 갱신합니다.`);
            playerEventPoints = 0;
            playerCumulativeEventPoints = 0;
            clearedEventDungeons = [];
            purchasedEventItems = {};
            playerChoices = {};
        }

        // 4-2. 레이드 횟수(Daily Count) 체크 (한국 시간 기준)
        const todayStr = getTodayDateString(new Date()); 
        const lastResetTimestamp = savedData.raidLastResetDate;
        let savedLastRaidDateStr = null;
        
        // ✨ [핵심 수정] Timestamp를 Date 객체로 변환하여 전역 변수에 저장합니다.
        if (lastResetTimestamp && typeof lastResetTimestamp.toDate === 'function') {
            const dateObj = lastResetTimestamp.toDate();
            savedLastRaidDateStr = getTodayDateString(dateObj);
            playerRaidLastResetDate = dateObj; // Date 객체로 변환해서 메모리에 저장
        } else {
            // 이미 Date 객체거나 null인 경우
            savedLastRaidDateStr = lastResetTimestamp ? getTodayDateString(new Date(lastResetTimestamp)) : null;
            playerRaidLastResetDate = lastResetTimestamp ? new Date(lastResetTimestamp) : null;
        }

        if (savedLastRaidDateStr !== todayStr) { 
            console.log(`날짜 변경 감지(KST): 횟수 초기화 (${savedLastRaidDateStr} -> ${todayStr})`);
            playerRaidDailyCount = 0; 
            // 날짜가 바뀌었으면 null로 두었다가, 공격 시점에 갱신하도록 함
            playerRaidLastResetDate = null; 
        } else {
            playerRaidDailyCount = savedData.raidDailyCount ?? 0;
        }

        // 프로필 데이터 로드
        playerProfile = savedData.profile || { repCardId: null, statusMessage: "" };
        const nickInput = document.getElementById('profile-nickname-edit');
        if(nickInput) nickInput.value = currentPlayerNickname;
		 playerTutorialFinished = (savedData.tutorialFinished !== undefined) ? savedData.tutorialFinished : true;

    } else {
        console.log("새로운 유저입니다. 초기 데이터로 시작합니다.");
        initializeNewGameData();
        await saveGameToFirebase(); 
    }

    calculateOfflineRegen();
    playerInventory.forEach(card => {
        if (!card.id) card.id = Date.now().toString(36) + Math.random().toString(36).substr(2);
    });
    
    await checkAndProcessSystemMails(uid);
    
    updateUI();
    updateRaidDailyCountUI();
    checkEventStatus();
    switchTab('home');
    checkAchievements();
    checkAndSpawnRaidBoss(); 
    updateAchievementBadge(); 

    document.getElementById('loading-overlay').classList.add('hidden');
    document.body.classList.remove('loading');
	if (playerTutorialFinished === false) {
        // 튜토리얼 안 끝났으면 0장 시작
        startIntroTutorial();
    } else {
        // 끝났으면 홈으로 이동
        switchTab('home');
    }
}



function saveGame() {
    saveGameToFirebase(); // <--- 이 함수가 비동기 호출을 보장해야 합니다.
}

			
            function initializeNewGameData() {
    // ✨ 게임 첫 시작 시 기본 지급 카드에 고유 ID와 레벨 부여
    addCardToInventory('[관리인] Ki');
    addCardToInventory('[관리인] Ai');
	collectedCardNames.add('[관리인] Ki');
                collectedCardNames.add('[관리인] Ai');
	playerCurrency = 100; // 💎 초기 보석 100개 지급
    playerFountainPens = 500; // 🖋️ 초기 펜 수량도 명시적으로 지정
    playerBookmarks = MAX_BOOKMARKS;
    lastBookmarkUpdateTime = Date.now();
	playerTutorialFinished = false; 
}


		

            // [수정] 게임 데이터 초기화 (리세마라 + 거래소 삭제 + 친구 관계 완전 삭제)
async function resetGame() {
    // 1. 확인 버튼 로직 (한 번 누르면 '확인?'으로 바뀜)
    if (resetButton.dataset.confirming === 'true') {
        try {
            if (currentUser) {
                console.log("🔥 계정 초기화 시작...");

                // =========================================================
                // 1단계: 거래소에 올려둔 내 매물 삭제
                // =========================================================
                const myTradesSnapshot = await db.collection('trades')
                    .where('senderUid', '==', currentUser.uid)
                    .get();

                const tradeBatch = db.batch();
                myTradesSnapshot.forEach(doc => {
                    tradeBatch.delete(doc.ref);
                });
                await tradeBatch.commit();
                console.log(`✅ 거래소 매물 ${myTradesSnapshot.size}건 삭제 완료.`);

                // =========================================================
                // 2단계: 친구 관계 끊기 (나 <-> 친구 양쪽 모두 삭제)
                // =========================================================
                const myFriendsSnapshot = await db.collection('users')
                    .doc(currentUser.uid)
                    .collection('friends')
                    .get();

                if (!myFriendsSnapshot.empty) {
                    const friendBatch = db.batch();
                    
                    myFriendsSnapshot.forEach(doc => {
                        const friendUid = doc.id;
                        
                        // 1. 상대방의 친구 목록에서 '나'를 삭제
                        const theirRef = db.collection('users').doc(friendUid)
                                           .collection('friends').doc(currentUser.uid);
                        friendBatch.delete(theirRef);

                        // 2. 내 친구 목록에서 '상대방'을 삭제 (사실 본체 삭제하면 같이 사라지지만 확실하게 처리)
                        friendBatch.delete(doc.ref);
                    });

                    await friendBatch.commit();
                    console.log(`✅ 친구 ${myFriendsSnapshot.size}명과의 관계 삭제 완료.`);
                }

                // =========================================================
                // 3단계: 내 유저 데이터(본체) 삭제
                // =========================================================
                await db.collection('users').doc(currentUser.uid).delete();
                console.log("✅ 유저 데이터 삭제 완료.");
            }

            // 4. 로컬 데이터 삭제 및 새로고침
            localStorage.removeItem(SAVE_DATA_KEY);

            alert("계정이 완벽하게 초기화되었습니다.\n(친구 목록, 거래소 매물, 게임 데이터 삭제 완료)");
            location.reload(); 

        } catch (e) {
            console.error("초기화 실패:", e);
            alert("초기화 중 오류가 발생했습니다: " + e.message);
        }
    } else {
        // 버튼 UI 변경 로직
        resetButton.textContent = '확인?';
        resetButton.dataset.confirming = 'true';
        resetButton.classList.remove('bg-red-600', 'hover:bg-red-700');
        resetButton.classList.add('bg-yellow-500', 'hover:bg-yellow-600');
        
        setTimeout(() => {
            resetButton.textContent = '초기화';
            resetButton.dataset.confirming = 'false';
            resetButton.classList.remove('bg-yellow-500', 'hover:bg-yellow-600');
            resetButton.classList.add('bg-red-600', 'hover:bg-red-700');
        }, 3000);
    }
}

            // --- 업적 관련 함수 ---
            function showToast() {
                toastNotification.classList.remove('hidden');
                setTimeout(() => {
                    toastNotification.classList.add('hidden');
                }, 2000); // 2초 후 사라짐
            }

            function checkAchievements() {
    // 업적 조건 함수가 rarity, level 등 모든 정보에 접근할 수 있도록
    // 인벤토리 데이터를 '풍부하게(rich)' 만듭니다.
    const richInventory = playerInventory.map(c => {
        const base = findCharacter(c.name); // (name, rarity, stats...)
        return { ...base, ...c }; // (name, rarity, stats, id, level, revision)
    });
    
    const currentState = {
        inventory: richInventory, // 👈 'playerInventory' 대신 'richInventory'를 전달
        stats: playerStats,
        clearedStages: clearedStages,
        capacity: inventoryCapacity,
        fountainPens: playerFountainPens,
    };
    let newAchievementUnlocked = false;
    achievements.forEach(ach => {
        // 아직 달성하지 않은 업적만 체크
        if (!playerAchievements[ach.id]) {
            // 업적 조건이 playerFountainPens를 사용하도록 수정합니다.
            if (ach.condition(currentState)) { 
                playerAchievements[ach.id] = 'unlocked';
                newAchievementUnlocked = true;
            }
        }
    });
    if (newAchievementUnlocked) {
        showToast();
        // 현재 업적 탭을 보고 있다면 UI를 즉시 갱신
        if (document.getElementById('achievements-view').classList.contains('hidden') === false) {
            displayAchievements();
        }
		
    }
	updateAchievementBadge();
}
            
            function displayAchievements() {
                achievementsContainer.innerHTML = '';
                achievements.forEach(ach => {
                    const status = playerAchievements[ach.id]; // 'unlocked' or 'claimed' or undefined
                    const achEl = document.createElement('div');
                    achEl.className = `p-4 rounded-lg flex justify-between items-center transition-all ${status ? 'bg-white/20' : 'bg-black/30 opacity-60'}`;
                    
                    let rewardText = '';
                    if (ach.reward.currency) rewardText += `💎 ${ach.reward.currency} `;
                    if (ach.reward.fountainPens) rewardText += `🖋️ ${ach.reward.fountainPens} `; // ✨ 이 줄의 로직이 만년필 보상을 추가합니다.
                    if (ach.reward.bookmarks) rewardText += `🔖 ${ach.reward.bookmarks} `;

                    let buttonHTML = '';
                    if (status === 'claimed') {
                        buttonHTML = `<button class="gacha-button bg-gray-600 text-white font-bold py-2 px-4 rounded-full text-sm" disabled>달성 완료</button>`;
                    } else if (status === 'unlocked') {
                        buttonHTML = `<button data-ach-id="${ach.id}" class="gacha-button bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-full text-sm">보상 받기</button>`;
                    } else {
                        buttonHTML = `<button class="gacha-button bg-gray-800 text-gray-400 font-bold py-2 px-4 rounded-full text-sm" disabled>진행 중</button>`;
                    }

                    achEl.innerHTML = `
                        <div>
                            <h3 class="text-lg font-bold ${status ? 'text-yellow-300' : 'text-gray-400'}">${ach.title}</h3>
                            <p class="text-sm text-gray-300">${ach.description} (보상: ${rewardText})</p>
                        </div>
                        ${buttonHTML}
                    `;
                    achievementsContainer.appendChild(achEl);
                });
            }
            
            function claimAchievement(achievementId) {
    const ach = achievements.find(a => a.id === achievementId);
    if (!ach || playerAchievements[ach.id] !== 'unlocked') return;

    // 보상 지급
    if (ach.reward.currency) playerCurrency += ach.reward.currency;
    if (ach.reward.fountainPens) playerFountainPens += ach.reward.fountainPens;
    // ✨ 업적 보상은 최대 30개까지 축적 가능
    if (ach.reward.bookmarks) playerBookmarks = Math.min(HARD_MAX_BOOKMARKS, playerBookmarks + ach.reward.bookmarks);
    
    playerAchievements[ach.id] = 'claimed'; // 상태 변경
    
    updateUI();
    displayAchievements(); // UI 갱신
    saveGame();
	updateAchievementBadge();
}
			
			// --- 인연(Synergy) 관련 함수 ---
            function calculateActiveSynergies(deck) {
    // 1. 덱의 각 카드 인스턴스를 해당하는 캐릭터 데이터로 변환
    const deckWithData = deck.map(cardInstance => {
        // findCharacter 함수는 game_data.js에 정의된 전체 character 데이터를 반환합니다.
        const charData = findCharacter(cardInstance.name); 
        if (!charData) return null;
        
        // 인연 조건 확인을 위해 필요한 'faction'과 'baseName'을 가진 객체 반환
        return {
            ...charData, // faction, baseName, rarity 등을 모두 포함
        };
    }).filter(Boolean); // 유효하지 않은 카드 제거

    // 2. 변환된 덱(characterData 배열)을 인연 조건 함수에 전달
    return synergies.filter(synergy => synergy.condition(deckWithData));
}

            function displaySynergies() {
                const activeSynergies = calculateActiveSynergies(playerDeck);
                if (activeSynergies.length > 0) {
                    synergyList.innerHTML = activeSynergies.map(s => `<span class="bg-black/30 px-3 py-1 rounded-full">${s.name}: ${s.description}</span>`).join(' ');
                } else {
                    synergyList.innerHTML = '활성화된 인연이 없습니다.';
                }
            }
            
            function applySynergyBonusesToDeck(deck) {
                const activeSynergies = calculateActiveSynergies(deck);
                if (activeSynergies.length === 0) return JSON.parse(JSON.stringify(deck));

                const bonusDeck = JSON.parse(JSON.stringify(deck)); // 원본 덱 수정을 방지하기 위한 깊은 복사
                bonusDeck.forEach(card => {
                    activeSynergies.forEach(synergy => {
                        synergy.applyBonus(card);
                    });
                });
                return bonusDeck;
            }

            // yumecan.html - switchTab 함수 (2137행 근처)

// yumecan.html - switchTab 함수 (2137행 근처)

// ========================================================
// ✅ [수정됨] 탭 전환 함수 (중복 선언 제거 & 상단바 제어 강화)
// ========================================================

let currentTab = 'home'; // ✨ 이 변수는 스크립트 전체에서 딱 한 번만 선언되어야 합니다!

// 2. 안정화된 탭 전환 함수 (거래소이전.html 기반 + 최신 기능 통합)
            function switchTab(tabName) {
                if (typeof isCombatRunning !== 'undefined' && isCombatRunning) return;
                
                // [초기화] 모든 뷰 숨기기 및 탭 버튼 비활성화
                if (allViews) {
                    allViews.forEach(view => {
                        if (view) view.classList.add('hidden'); 
                    });
                }
                
                if (allTabs) {
                    allTabs.forEach(tab => tab.classList.remove('active'));
                }
				const globalHomeBtn = document.getElementById('global-home-button');
                if (globalHomeBtn) {
                    if (tabName === 'home') {
                        globalHomeBtn.classList.add('hidden'); // 홈에서는 숨김
                    } else {
                        globalHomeBtn.classList.remove('hidden'); // 다른 곳에서는 보임
                    }
                }
                
                // [뷰 선택] 탭 이름에 맞는 뷰 찾기
                let targetView;

                if (tabName === 'event') {
                    // ✨ 핵심: 이벤트 탭 클릭 시 '전투'가 아닌 '이벤트 홈(안내)'을 보여줌
                    targetView = document.getElementById('event-home-view'); 
                } 
                else if (tabName === 'myroom') {
                    targetView = document.getElementById('myroom-view');
                }
                else {
                    // 그 외: trade -> trade-view, home -> home-view 등 규칙대로 연결
                    targetView = document.getElementById(`${tabName}-view`);
                }
                
                // [탭 버튼 선택]
                const targetTab = document.getElementById(`tab-${tabName}`);

                // 방어 코드: 뷰가 없으면 에러 로그만 남기고 중단 (멈춤 방지)
                if (!targetView) {
                    console.warn(`Warning: View for ${tabName} not found.`);
                    // 뷰가 없어도 코드는 계속 실행되게 하여 멈춤 현상 방지
                } else {
                    targetView.classList.remove('hidden');
                }

                if (targetTab) {
                    targetTab.classList.add('active');
                }
                
                // 전역 변수 업데이트 (중복 선언 방지를 위해 window 객체 사용 권장)
                window.currentTab = tabName;

                // [데이터 로드] 각 탭에 맞는 최신 데이터 불러오기
                if (tabName === 'home') displayHomeView();
                else if (tabName === 'inventory') displayInventory(); 
                else if (tabName === 'deck') displayDeckManagement();
                else if (tabName === 'combat') displayCombatView();
                else if (tabName === 'collection') displayCollectionView();
                else if (tabName === 'story') displayStoryView();
                else if (tabName === 'event') displayEventHomeView();
                else if (tabName === 'achievements') displayAchievements();
                else if (tabName === 'myroom') displayMyRoom();
				else if (tabName === 'breeding') displayBreedingView(); // 👈 [추가]
                // ✨ 누락되었던 최신 기능 연결 (친구, 교환소, 프로필)
                else if (tabName === 'friends' && typeof loadFriendList === 'function') loadFriendList();
                else if (tabName === 'trade' && typeof loadTradeList === 'function') loadTradeList();
                else if (tabName === 'profile' && typeof displayProfileView === 'function') displayProfileView();
            }
            
            // 전역 스코프에 등록
            window.switchTab = switchTab;

// ✅ [신규] 이벤트 탭 전용 전환 함수 (확실하게 하나만 보여줌)
function switchEventSubTab(tabName) {
    // 1. 모든 이벤트 서브 뷰 ID 목록
    const allViewIds = [
        'event-battle-view', 
        'event-raid-view', 
        'event-story-view', 
        'event-shop-view'
    ];
    
    // 2. 모든 뷰 숨기기 & 모든 버튼 비활성화
    allViewIds.forEach(id => {
        const view = document.getElementById(id);
        if (view) view.classList.add('hidden');
        
        // 버튼 ID는 뷰 ID에서 '-view'를 뺀 뒤 'sub-tab-'을 중간에 넣은 형태
        // 예: event-battle-view -> event-sub-tab-battle
        const btnId = id.replace('event-', 'event-sub-tab-').replace('-view', '');
        const btn = document.getElementById(btnId);
        if (btn) btn.classList.remove('active');
    });

    // 3. 선택된 뷰만 보이기
    const targetView = document.getElementById(`event-${tabName}-view`);
    if (targetView) targetView.classList.remove('hidden');

    // 4. 선택된 버튼 활성화
    const targetBtn = document.getElementById(`event-sub-tab-${tabName}`);
    if (targetBtn) targetBtn.classList.add('active');
}
            function switchSubTab(viewContainer, button) {
                Array.from(viewContainer.children).forEach(view => {
                    if(view.id.endsWith('-view')) view.classList.add('hidden');
                });
                Array.from(button.parentElement.children).forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');
                const viewId = button.id.replace('sub-tab-', '') + '-view';
                const viewElement = document.getElementById(viewId);
                if (viewElement) {
                    viewElement.classList.remove('hidden');
                }
            }

            function switchGachaTab(tabName) {
                if (tabName === 'normal') {
                    normalGachaView.classList.remove('hidden');
                    eventGachaView.classList.add('hidden');
                    gachaTabNormal.classList.add('active');
                    gachaTabEvent.classList.remove('active');
                } else {
                    normalGachaView.classList.add('hidden');
                    eventGachaView.classList.remove('hidden');
                    gachaTabNormal.classList.remove('active');
                    gachaTabEvent.classList.add('active');
                }
            }

            // [수정] 이벤트 상태 체크 (오류 수정판)
function checkEventStatus() {
    // 전역 변수 대신 함수 실행 시점에 요소를 다시 찾습니다.
    const banner = document.getElementById('event-banner'); 
    const evtTab = document.getElementById('tab-event');
    const gachaTab = document.getElementById('gacha-tab-event');
    const bannerText = document.getElementById('event-banner-text');
    const gachaInfo = document.getElementById('event-gacha-info');

    if (CURRENT_EVENT_ID && currentEventInfo) {
        // ✅ 이벤트 진행 중
        if (banner) banner.classList.remove('hidden');
        
        if (bannerText) {
            bannerText.textContent = `${currentEventInfo.title} 진행 중!`;
        }
        
        if (gachaInfo && currentEventInfo.gachaCharacterName) {
            const pTag = gachaInfo.querySelector('p');
            if (pTag) pTag.textContent = `[${currentEventInfo.gachaCharacterName}] 등장 확률 UP!`;
        }

        if (gachaTab) gachaTab.classList.remove('hidden');
        if (evtTab) evtTab.classList.remove('hidden');

    } else {
        // ❌ 진행 중인 이벤트 없음
        if (banner) banner.classList.add('hidden');
        if (gachaTab) gachaTab.classList.add('hidden');
        if (evtTab) evtTab.classList.add('hidden');
        
        // 강제 이동 로직
        if (document.getElementById('event-home-view') && !document.getElementById('event-home-view').classList.contains('hidden')) {
            switchTab('home');
        }
        if (gachaTab && gachaTab.classList.contains('active')) {
            switchGachaTab('normal');
        }
    }
}

            function displayHomeView(cycleDialogue = false) {
                if (representativeCharacter) {
                    homeCharacterContainer.classList.remove('hidden');
                    homeDialogueContainer.classList.remove('hidden');
                    homeDefaultMessage.classList.add('hidden');
                    homeCharacterImage.src = representativeCharacter.imageUrl;
                    homeCharacterName.textContent = representativeCharacter.name;
                    if (cycleDialogue) {
                        const currentDialogue = homeCharacterDialogue.textContent;
                        let newDialogue;
                        do {
                            newDialogue = representativeCharacter.dialogues[Math.floor(Math.random() * representativeCharacter.dialogues.length)];
                        } while (representativeCharacter.dialogues.length > 1 && newDialogue === currentDialogue);
                        homeCharacterDialogue.textContent = newDialogue;
                    } else {
                         homeCharacterDialogue.textContent = representativeCharacter.dialogues[0];
                    }
                } else {
                    homeCharacterContainer.classList.add('hidden');
                    homeDialogueContainer.classList.add('hidden');
                    homeDefaultMessage.classList.remove('hidden');
                }
            }


// ✅ '도감' 탭의 메인 함수 (캐릭터 목록 생성) - 수정됨
function displayCollectionView() {
    const charListContainer = document.getElementById('collection-character-list');
    charListContainer.innerHTML = '';

    // 1. [탭 버튼 영역]
    const tabContainer = document.createElement('div');
    tabContainer.className = 'flex flex-wrap gap-2 mb-4 justify-center';

    COLLECTION_GROUPS.forEach(groupName => {
        const tabBtn = document.createElement('button');
        const isActive = (groupName === currentCollectionGroup);
        tabBtn.className = `px-3 py-1 rounded-full text-xs font-bold transition-all ${
            isActive ? 'bg-yellow-400 text-black shadow-lg scale-105' : 'bg-gray-700 text-gray-300 hover:bg-gray-600'
        }`;
        tabBtn.textContent = groupName;
        tabBtn.onclick = (e) => {
            e.stopPropagation();
            currentCollectionGroup = groupName;
            displayCollectionView();
        };
        tabContainer.appendChild(tabBtn);
    });
    charListContainer.appendChild(tabContainer);

    // 2. [캐릭터 목록] 생성
    const collectedBaseNames = new Set();
    if (typeof collectedCardNames !== 'undefined') {
        collectedCardNames.forEach(cardName => {
            const charData = findCharacter(cardName);
            if (charData) collectedBaseNames.add(charData.baseName);
        });
    }

    const allBaseNames = Object.keys(characterProfiles);
    const filteredNames = allBaseNames.filter(baseName => {
        const profile = characterProfiles[baseName];
        return profile.group === currentCollectionGroup;
    });

    if (filteredNames.length === 0) {
        charListContainer.innerHTML += `<p class="text-center text-gray-500 py-4">해당 기수의 데이터가 없습니다.</p>`;
    } else {
        filteredNames.forEach(baseName => {
            const profile = characterProfiles[baseName];
            const isCollected = collectedBaseNames.has(baseName);
            
            // 현재 선택된 캐릭터인지 확인
            const isActiveChar = (baseName === currentCollectionSelection);
            
            const button = document.createElement('button');
            
            let bgClass = '';
            if (isActiveChar) {
                bgClass = 'bg-blue-600 text-white shadow-md ring-2 ring-blue-400'; 
            } else if (isCollected) {
                bgClass = 'bg-white/10 hover:bg-white/20 text-white'; 
            } else {
                bgClass = 'bg-black/30 text-gray-500'; 
            }

            // ✨ [핵심 수정] isActiveChar가 true면 'active' 클래스를 명시적으로 추가합니다!
            button.className = `w-full text-left font-bold py-3 px-4 rounded-lg transition-all duration-200 mb-2 focus:outline-none ${bgClass} ${isActiveChar ? 'active' : ''}`;
            
            button.textContent = isCollected ? profile.name : '?????';
            button.dataset.baseName = baseName;
            
            button.onclick = () => displayCharacterDetail(baseName);
            
            charListContainer.appendChild(button);
        });
    }
}

// ✅ (신규) 캐릭터 상세 정보 표시 함수
function displayCharacterDetail(baseName) {
    const profile = characterProfiles[baseName];
    if (!profile) return;
    
    // ✨ [핵심 수정] 현재 선택된 캐릭터 이름을 변수에 저장
    currentCollectionSelection = baseName;

    // 1. 상세 뷰 보이기
    document.getElementById('collection-character-detail-view').classList.remove('hidden');
    document.getElementById('collection-default-message').classList.add('hidden');
    
    // 2. 프로필 정보 채우기 (기존 코드 유지)
    let isCollected = false;
    if (typeof collectedCardNames !== 'undefined') {
        isCollected = Array.from(collectedCardNames).some(cardName => {
            const charData = findCharacter(cardName);
            return charData && charData.baseName === baseName;
        });
    }

    if (isCollected) {
        document.getElementById('collection-profile-image').src = profile.imageUrl;
        document.getElementById('collection-profile-name').textContent = profile.name;
        document.getElementById('collection-profile-age').textContent = profile.age;
        document.getElementById('collection-profile-job').textContent = profile.job;
        document.getElementById('collection-profile-description').textContent = profile.description;
    } else {
        document.getElementById('collection-profile-image').src = 'https://placehold.co/300x500/000000/ffffff?text=???';
        document.getElementById('collection-profile-name').textContent = '?????';
        document.getElementById('collection-profile-age').textContent = '??';
        document.getElementById('collection-profile-job').textContent = '?????';
        document.getElementById('collection-profile-description').textContent = '아직 이 등장인물에 대한 정보가 없습니다.';
    }
    
    // ✨ [핵심 수정] 버튼 스타일을 일일이 조작하는 대신, 목록 전체를 새로고침하여 깔끔하게 적용
    displayCollectionView();

    // 4. 서브 탭 초기화 (기존 코드 유지)
    document.getElementById('collection-sub-tab-cards').classList.add('active');
    document.getElementById('collection-sub-tab-dialogues').classList.remove('active');
    document.getElementById('collection-cards-view').classList.remove('hidden');
    document.getElementById('collection-dialogues-view').classList.add('hidden');
    
    // 5. 카드 모음 표시
    displayCharacterCards(baseName, isCollected);
}

// ✅ (신규) 특정 캐릭터의 '카드 모음' 표시 함수
function displayCharacterCards(baseName, isCollected) { 
    const cardContainer = document.getElementById('collection-container');
    cardContainer.innerHTML = '';
    
    // ✨ [수정됨] 이름에 '+' 기호가 포함된 카드는 목록에서 제외합니다.
    const characterVersions = characters.filter(c => 
        c.baseName === baseName && !c.name.includes('+')
    );

    characterVersions.forEach((character, index) => {
                    // 👇 isCardCollected를 collectedCardNames로 직접 확인
                    const isCardCollected = collectedCardNames.has(character.name); 
                    
                    const cardElement = createCard(character, { 
                        animationIndex: index, 
                        mode: 'collection', 
                        isCollected: isCardCollected,
                        // instance 정보는 기본값으로 전달 (파쇄된 카드 대응)
                        instance: { id: character.name, level: 0, revision: 0 } 
                    });

                    // 👇 data-unique-id 할당 로직 삭제 (파쇄된 카드는 클릭해도 상세 모달 X)
                    // if (isCardCollected) { ... } else { ... } 부분 삭제

                    cardContainer.appendChild(cardElement);
                });
            }


// ✅ (수정됨) 특정 캐릭터의 '대사 모음' 표시 함수 (카드 버전별 잠금)
function displayCharacterDialogues(baseName) {
    const dialogueList = document.getElementById('collection-dialogues-list');
    dialogueList.innerHTML = '';
    
    // 1. 이 캐릭터의 '모든' 버전을 가져옵니다.
    const allVersions = characters.filter(c => c.baseName === baseName);
    
    // 2. 이 캐릭터의 카드를 '하나라도' 수집했는지 확인합니다.
    const isAnyCardCollected = allVersions.some(character => collectedCardNames.has(character.name));

    // 이 탭 자체가 잠겨야 하는지 확인
    if (!isAnyCardCollected) {
        dialogueList.innerHTML = `<p class="text-gray-400 text-center py-4">등장인물을 수집하여 대사 탭을 잠금 해제하세요.</p>`;
        return; 
    }

    // 3. 화면에 표시할 때는 '개정판(+)'이 아닌 카드만 추려냅니다.
    const displayVersions = allVersions.filter(c => !c.name.includes('+'));

    // 4. 대사 출력 (수집 여부에 따라 잠금/해금)
    displayVersions.forEach(character => {
        const isCardCollected = collectedCardNames.has(character.name); // ✨ 이 버전의 카드를 수집했는지 확인

        // --- 헤더 출력 (수집 안 했으면 🔒 표시) ---
        let headerHTML;
        if (isCardCollected) {
            headerHTML = `<h4 class="text-lg font-bold text-yellow-300 mt-2">${character.name}</h4>`;
        } else {
            headerHTML = `<h4 class="text-lg font-bold text-gray-500 mt-2">🔒 ${character.name} (수집 필요)</h4>`;
        }
        dialogueList.innerHTML += headerHTML;
        
        if (isCardCollected) {
            // --- 해금된 경우: 대사 내용 출력 ---
            
            // 일반 대사
            if (character.dialogues) {
                character.dialogues.forEach(diag => { 
                    dialogueList.innerHTML += `<p class="pl-4 text-gray-300 mb-1">"${diag}"</p>`; 
                });
            }

            // 스킬 대사
            if (character.skills) {
                character.skills.forEach(skill => { 
                    dialogueList.innerHTML += `<p class="pl-4 text-cyan-300 mb-1"><span class="text-xs border border-cyan-500 px-1 rounded mr-1">스킬</span> "${skill.dialogue}"</p>`; 
                });
            }

            // 사망 대사
            if (character.deathDialogue) {
                dialogueList.innerHTML += `<p class="pl-4 text-red-400 mb-1"><span class="text-xs border border-red-500 px-1 rounded mr-1">사망</span> "${character.deathDialogue}"</p>`;
            }
            
        } else {
            // --- 잠긴 경우: 잠금 메시지 출력 ---
            dialogueList.innerHTML += `<p class="pl-4 text-gray-600 mb-1">해당 원고를 수집해야만 대사를 확인할 수 있습니다.</p>`;
        }
        
        dialogueList.innerHTML += `<hr class="border-gray-600 my-4">`;
    });
}

// ✅ displayEventView 함수 바로 위에 이 함수를 추가하세요.

// [수정] 이벤트 홈 화면 표시 (안전장치 추가)
function displayEventHomeView() {
    // ✨ 안전장치: 이벤트 정보가 없으면 아무것도 하지 않고 중단 (에러 방지)
    if (!currentEventInfo || !currentEventInfo.startDate) {
        console.warn("표시할 이벤트 정보가 없습니다.");
        return;
    }

    const options = { 
        year: 'numeric', 
        month: 'long', 
        day: 'numeric', 
        hour: '2-digit', 
        minute: '2-digit',
        hour12: false 
    };
    
    // 날짜 포맷팅
    const startDateStr = currentEventInfo.startDate.toLocaleDateString('ko-KR', options);
    const endDateStr = currentEventInfo.endDate.toLocaleDateString('ko-KR', options);
    
    // 텍스트 및 이미지 설정
    document.getElementById('event-home-duration').textContent = `${startDateStr} ~ ${endDateStr}`;
    document.getElementById('event-home-banner-image').src = currentEventInfo.bannerImageUrl;
    document.getElementById('event-home-description').textContent = currentEventInfo.description;
    
    // 포인트 표시
    const holdingEl = document.getElementById('display-holding-points');
    if (holdingEl) holdingEl.textContent = (playerEventPoints || 0).toLocaleString();

    const cumulativeEl = document.getElementById('display-cumulative-points');
    if (cumulativeEl) cumulativeEl.textContent = (playerCumulativeEventPoints || 0).toLocaleString();
    
    // 랭킹 로드
    loadRankingPreview();
}
			
            function displayEventView() {
                displayEventBattleView();
                displayEventStories(); // 👈 'displayEventStoryView'를 'displayEventStories'로 변경!
                displayEventShopView();
               
            }

            function displayEventBattleView() {
                eventDungeonListContainer.innerHTML = '';
                eventDungeons.forEach((dungeon, index) => {
                    const isUnlocked = index === 0 || clearedEventDungeons.includes(eventDungeons[index - 1].name);
                    const isCleared = clearedEventDungeons.includes(dungeon.name);
                    const dungeonEl = document.createElement('button');
                    dungeonEl.className = `p-4 rounded-lg transition-colors duration-300 text-center ${isUnlocked ? 'bg-white/20 hover:bg-white/30 cursor-pointer' : 'bg-black/30 text-gray-500 cursor-not-allowed'}`;
                    dungeonEl.disabled = !isUnlocked;
                    
                    dungeonEl.innerHTML = `
                        <h3 class="text-xl font-bold ${isUnlocked ? 'text-yellow-300' : ''}">${dungeon.name}</h3>
                        <p class="text-sm">보상: ${dungeon.eventPointReward} P ${isCleared ? '<span class="text-green-400">(클리어)</span>' : ''}</p>
                    `;
                    if(isUnlocked){
                        dungeonEl.onclick = () => challengeDungeon(index, 'event');
                    }
                    eventDungeonListContainer.appendChild(dungeonEl);
                });
            }
			
			function purchaseEventItem(itemId) {
    const item = eventShopItems.find(i => i.id === itemId);
    if (!item) return;

    const purchasedCount = purchasedEventItems[item.id] || 0;
    
    // 1. 구매 제한 체크
    if (purchasedCount >= item.limit) {
        showMessage('이미 최대 수량을 구매했습니다.', 'text-red-400', messageArea);
        return;
    }
    
    // 2. 포인트 부족 체크
    if (playerEventPoints < item.cost) {
        showMessage('이벤트 포인트가 부족합니다.', 'text-red-400', messageArea);
        return;
    }

    // 3. 포인트 차감 및 구매 횟수 증가
    playerEventPoints -= item.cost;
    purchasedEventItems[item.id] = purchasedCount + 1;

    // 4. 아이템 지급 로직
    if (item.type === 'card') {
        playerInventory.push(item.itemData);
        // 수집 도감 등록
        if (typeof collectedCardNames !== 'undefined') collectedCardNames.add(item.itemData.name);
        showMessage(`[${item.name}] 획득!`, 'text-green-300', messageArea);
    } 
    else if (item.type === 'currency') {
        playerCurrency += item.itemData;
        showMessage(`보석 ${item.itemData}개 획득!`, 'text-green-300', messageArea);
    }
    else if (item.type === 'fountainPen') {
        playerFountainPens += item.itemData;
        showMessage(`만년필 ${item.itemData}개 획득!`, 'text-gray-300', messageArea);
    }
    else if (item.type === 'inkwell') {
        playerInkwells += item.itemData;
        showMessage(`잉크병 ${item.itemData}개 획득!`, 'text-fuchsia-300', messageArea);
    }
    else if (item.type === 'bookmark') {
        // 책갈피는 한도 체크
        if (playerBookmarks >= HARD_MAX_BOOKMARKS) {
            // 포인트 환불
            playerEventPoints += item.cost;
            purchasedEventItems[item.id]--; 
            showMessage(`책갈피는 최대 ${HARD_MAX_BOOKMARKS}개까지만 소지할 수 있습니다.`, 'text-red-400', messageArea);
            return; 
        }
        playerBookmarks = Math.min(HARD_MAX_BOOKMARKS, playerBookmarks + item.itemData);
        showMessage(`책갈피 획득! (현재: ${playerBookmarks})`, 'text-cyan-300', messageArea);
    }

    // 5. UI 갱신 및 저장
    updateUI(); // 상단 글로벌 바 갱신
    displayEventShopView(); // ✨ 상점 UI 갱신 (이때 포인트 배너도 같이 갱신됨)
    saveGame();
}

            // [수정됨] 이벤트 상점 표시 함수 (포인트 배너 갱신 기능 추가)
function displayEventShopView() {
    // 1. 상단 포인트 배너 갱신
    const shopPointDisplay = document.getElementById('shop-event-point-display');
    if (shopPointDisplay) {
        shopPointDisplay.textContent = (playerEventPoints || 0).toLocaleString();
    }

    if (typeof eventPointsSpan !== 'undefined' && eventPointsSpan) {
        eventPointsSpan.textContent = playerEventPoints;
    }
    
    const container = document.getElementById('event-shop-container');
    container.innerHTML = '';
    
    // ✨ [핵심 필터링] 현재 진행 중인 이벤트 물품만 필터링!
    const currentItems = eventShopItems.filter(item => {
        // 1. 시트에 eventId가 비어있거나 'ALL'이면 상시 판매
        if (!item.eventId || item.eventId === 'ALL') return true;
        
        // 2. 아이템의 eventId가 현재 시스템의 CURRENT_EVENT_ID와 정확히 일치해야 함
        // (CURRENT_EVENT_ID는 datatest.js에서 날짜 기준으로 자동 계산됨)
        return item.eventId === CURRENT_EVENT_ID;
    });

    // 만약 팔 물건이 하나도 없다면?
    if (currentItems.length === 0) {
        container.innerHTML = '<p class="col-span-full text-center text-gray-500 py-10">현재 판매 중인 이벤트 상품이 없습니다.</p>';
        return;
    }
    
    // 필터링된 목록(currentItems)으로 루프를 돌립니다.
    currentItems.forEach(item => {
        const purchasedCount = purchasedEventItems[item.id] || 0;
        const isSoldOut = purchasedCount >= item.limit;
        const canAfford = playerEventPoints >= item.cost;

        const itemEl = document.createElement('div');
        itemEl.className = `bg-black/20 p-4 rounded-lg flex justify-between items-center border border-white/5 transition-colors hover:bg-black/30 ${isSoldOut ? 'opacity-50' : ''}`;
        
        let typeIcon = '';
        if (item.type === 'card') typeIcon = '🃏';
        else if (item.type === 'currency') typeIcon = '💎';
        else if (item.type === 'fountainPen') typeIcon = '🖋️';
        else if (item.type === 'inkwell') typeIcon = '💧';
        else if (item.type === 'bookmark') typeIcon = '🔖';

        let btnClass = '';
        let btnText = '구매';
        
        if (isSoldOut) {
            btnClass = 'bg-gray-600 cursor-not-allowed';
            btnText = '품절';
        } else if (!canAfford) {
            btnClass = 'bg-red-900/50 cursor-not-allowed opacity-70';
            btnText = '구매';
        } else {
            btnClass = 'bg-green-600 hover:bg-green-700 hover:scale-105 shadow-lg cursor-pointer';
            btnText = '구매';
        }

        itemEl.innerHTML = `
            <div>
                <h3 class="text-lg font-bold text-yellow-300 flex items-center gap-2">
                    <span>${typeIcon}</span> ${item.name}
                </h3>
                <p class="text-sm text-gray-300 font-bold mt-1">가격: <span class="text-pink-300">${item.cost.toLocaleString()} P</span></p>
                <p class="text-xs text-gray-400 mt-0.5">남은 횟수: <span class="text-white">${item.limit - purchasedCount}</span> / ${item.limit}</p>
            </div>
            <button data-item-id="${item.id}" class="gacha-button transition-all duration-200 text-white font-bold py-2 px-5 rounded-full text-sm ${btnClass}" ${isSoldOut || !canAfford ? 'disabled' : ''}>
                ${btnText}
            </button>
        `;
        container.appendChild(itemEl);
    });
}

            function calculateOfflineRegen() {
                if (playerBookmarks >= MAX_BOOKMARKS) {
                    lastBookmarkUpdateTime = Date.now();
                    return;
                }
                const now = Date.now();
                const timeDiff = now - lastBookmarkUpdateTime;
                const bookmarksToRegen = Math.floor(timeDiff / BOOKMARK_REGEN_TIME);

                if (bookmarksToRegen > 0) {
                    playerBookmarks = Math.min(MAX_BOOKMARKS, playerBookmarks + bookmarksToRegen);
                    lastBookmarkUpdateTime = lastBookmarkUpdateTime + bookmarksToRegen * BOOKMARK_REGEN_TIME;
                    saveGame();
                }
            }

            function startBookmarkRegenTimer() {
                setInterval(() => {
                    // 이 블록은 책갈피가 실제로 충전되는 로직입니다.
                    if (playerBookmarks < MAX_BOOKMARKS) {
                        const now = Date.now();
                        if (now - lastBookmarkUpdateTime >= BOOKMARK_REGEN_TIME) {
                            playerBookmarks++;
                            lastBookmarkUpdateTime = now; // 타이머를 현재 시간으로 초기화합니다.
                            updateUI();
                            saveGame();
                        }
                    }

                    // 이 블록은 남은 시간을 화면에 표시하는 로직입니다.
                    if (playerBookmarks < MAX_BOOKMARKS) {
                        const timeRemaining = BOOKMARK_REGEN_TIME - (Date.now() - lastBookmarkUpdateTime);
                        const minutes = Math.floor(timeRemaining / 60000);
                        const seconds = Math.floor((timeRemaining % 60000) / 1000);
                        
                        // MM:SS 형식으로 표시합니다. (예: 04:32)
                        bookmarkTimerContainer.textContent = `(${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')})`;
                        bookmarkTimerContainer.classList.remove('hidden');
                    } else {
                        // 책갈피가 가득 차면 타이머를 숨깁니다.
                        bookmarkTimerContainer.classList.add('hidden');
                    }
                }, 1000); // 1초마다 반복
            }


            function setRepresentative(cardName) {
                const cardData = findCharacter(cardName);
                if (cardData) {
                    representativeCharacter = cardData;
                    showMessage(`${cardData.name}(을)를 대표로 설정했습니다!`, 'text-blue-300', messageArea);
                    displayInventory();
                    saveGame();
                }
            }
            
            function handlePull(count, cost, gachaType = 'normal') {
                if (playerInventory.length + count > inventoryCapacity) {
                    showMessage('서고가 부족합니다!', 'text-yellow-400', messageArea); return;
                }
                if (playerCurrency >= cost) {
                    playerCurrency -= cost;
                    showMessage(`-💎${cost}`, 'text-red-400', messageArea);
                    performPulls(count, gachaType);
                } else {
                    showMessage('재화가 부족합니다!', 'text-red-400', messageArea);
                }
            }
            
            function expandInventory() {
                if (playerCurrency >= EXPAND_COST) {
                    playerCurrency -= EXPAND_COST; inventoryCapacity += EXPAND_AMOUNT;
                    showMessage(`서고가 ${inventoryCapacity}칸으로 확장되었습니다!`, 'text-green-300', messageArea);
                    updateUI(); displayInventory(); saveGame();
                    checkAchievements();
                } else {
                    showMessage('보석이 부족하여 확장할 수 없습니다.', 'text-red-400', messageArea);
                }
            }

            function updateUI() {
                currencyDisplay.textContent = playerCurrency;
                fountainPenDisplay.textContent = playerFountainPens; // 만년필 UI 업데이트
				document.getElementById('inkwell-display').textContent = playerInkwells;
                eventPointsSpan.textContent = playerEventPoints;
                bookmarkDisplay.textContent = playerBookmarks;
                maxBookmarkDisplay.textContent = MAX_BOOKMARKS;

                const buttons = [pullOneButton, pullTenButton, pullOneEventButton, pullTenEventButton];
                buttons.forEach(btn => {
                    if (btn.id.includes('ten')) btn.disabled = playerCurrency < PULL_TEN_COST;
                    else btn.disabled = playerCurrency < PULL_ONE_COST;
                });
                expandInventoryButton.disabled = playerCurrency < EXPAND_COST;
            }
			
            

            function showMessage(message, colorClass, element) {
    element.textContent = message;
    element.className = `text-center text-lg h-8 mb-4 transition-opacity duration-300 ${colorClass}`;
    setTimeout(() => { element.textContent = ''; }, 2000); // 2초 후 메시지를 지웁니다.
}
			
			function generateUniqueId() {
    return Date.now().toString(36) + Math.random().toString(36).substr(2);
}

function addCardToInventory(cardName) {
            const newCard = {
                id: generateUniqueId(),
                name: cardName,
                level: 0, 
                revision: 0 
            };
            playerInventory.push(newCard);
            
            // ✨ [추가] 수집 기록에 등록 (중복이어도 Set이라 상관없음)
            collectedCardNames.add(cardName); 
        }

            function performPulls(count, gachaType = 'normal') {
    const results = [];
                let guaranteedSR = (count === 10);
                for (let i = 0; i < count; i++) {
                    let pulledChar;
                    if (guaranteedSR && i === count - 1 && !results.some(c => c.rarity === 'SR' || c.rarity === 'SSR')) {
                        pulledChar = pullCharacter(['SR', 'SSR'], gachaType);
                    } else {
                        pulledChar = pullCharacter(null, gachaType);
                    }
                    results.push(pulledChar);
                    addCardToInventory(pulledChar.name);
                    playerStats.totalPulls++; // 이 줄 추가
                }
                displayResults(results); updateUI(); saveGame();
                checkAchievements(); // 이 줄 추가
            }
			
			function getEnhancedStats(cardInstance) {
    const baseCard = findCharacter(cardInstance.name);
    if (!baseCard) return null;

    // ✨ [변경] 유전된 스탯이 있으면 그것을 '기본 스탯'으로 사용
    const baseStats = (cardInstance.inherited && cardInstance.inherited.stats) 
                      ? cardInstance.inherited.stats 
                      : baseCard.stats;

    // '개정' 보너스
    const revisionBonus = 1 + (cardInstance.revision * STAT_INCREASE_PER_REVISION);
    const revisedStats = {
        hp: Math.floor(baseStats.hp * revisionBonus),
        atk: Math.floor(baseStats.atk * revisionBonus),
        def: Math.floor(baseStats.def * revisionBonus),
    };

    // '퇴고' 보너스
    const enhancementBonus = 1 + (cardInstance.level * STAT_INCREASE_PER_LEVEL);
    return {
        hp: Math.floor(revisedStats.hp * enhancementBonus),
        atk: Math.floor(revisedStats.atk * enhancementBonus),
        def: Math.floor(revisedStats.def * enhancementBonus),
    };
}

            // gacha1.html

function pullCharacter(allowedRarities = null, gachaType = 'normal') {
    const now = new Date();
    
    // ✨ [핵심 수정] currentEventInfo가 존재하는지 먼저 확인합니다!
    // (이벤트가 없으면 null이므로 뒤의 조건들은 검사하지 않고 false가 됩니다)
    const isEventActive = currentEventInfo && currentEventInfo.startDate && 
                          now >= currentEventInfo.startDate && now <= currentEventInfo.endDate;
    
    // gachaType이 'event'여도 이벤트 기간이 아니면 확률은 normal을 씀 (단, 풀은 gachaType을 따름)
    const useEventRates = gachaType === 'event' && isEventActive;
    const probabilities = useEventRates ? eventRarityProbabilities : rarityProbabilities;
    
    let selectedRarity = '';

    // 1. 등급(Rarity) 결정
    if (allowedRarities) {
        // 10회 뽑기 확정 등급 (SR 이상)
        const highTierProb = { 'SSR': probabilities['SSR'], 'SR': probabilities['SR'] };
        const totalProb = highTierProb.SSR + highTierProb.SR;
        // SSR/SR 비율에 맞춰 재추첨
        selectedRarity = (Math.random() * totalProb < highTierProb.SSR) ? 'SSR' : 'SR';
    } else {
        // 일반 확률 뽑기
        const rand = Math.random() * 100; 
        let cumulativeProb = 0;
        for (const rarity in probabilities) {
            cumulativeProb += probabilities[rarity];
            if (rand < cumulativeProb) { selectedRarity = rarity; break; }
        }
    }

    // 2. 결정된 등급에 맞는 캐릭터들 중 "현재 가챠 타입에 등장하는 애들"만 필터링
    let possibleCharacters = characters.filter(char => {
    // (1) 등급이 맞아야 함
    if (char.rarity !== selectedRarity) return false;

    // (2) 가챠 풀 데이터 확인
    const poolInfo = gachaPool[char.name];
    if (!poolInfo) return false; // 시트에 이름 없으면 절대 안 나옴

    // (3) 타입(일반/이벤트)에 따라 등장 여부 확인
    if (gachaType === 'normal') {
        return poolInfo.normal;
    }
    
    if (gachaType === 'event') {
        // ✨ [핵심 로직] 
        // 1. 현재 픽업 주인공인 경우 (yumecan_data.js 등에서 설정된 이름)
        if (char.name === EVENT_CHARACTER_NAME) return true;

        // 2. 이 캐릭터의 targetEventId가 '현재 진행중인 이벤트 ID'와 일치하는 경우
        if (poolInfo.targetEventId && poolInfo.targetEventId === CURRENT_EVENT_ID) return true;

        // 3. (옵션) targetEventId가 'ALL'이면 모든 이벤트 가챠에 등장
        if (poolInfo.targetEventId === 'ALL') return true;

        // 위 조건에 안 맞으면 등장 안 함
        return false;
    }
    
    return false;
});

    // 만약 설정 실수로 해당 등급에 뽑을 캐릭터가 하나도 없다면? (안전장치)
    if (possibleCharacters.length === 0) {
        console.warn(`경고: ${gachaType} 뽑기의 ${selectedRarity} 등급에 해당하는 캐릭터가 없습니다! N등급으로 대체합니다.`);
        
        // N등급 캐릭터들을 모두 찾아서 그 중 랜덤으로 하나를 줍니다
        const nRankChars = characters.filter(c => c.rarity === 'N');
        
        if (nRankChars.length > 0) {
            return nRankChars[Math.floor(Math.random() * nRankChars.length)];
        }
        
        // (만약 N등급조차 하나도 없다면 어쩔 수 없이 전체 목록의 첫 번째를 줍니다)
        return characters[0];
    }

    // 3. 픽업 캐릭터 확률 적용 (이벤트 뽑기인 경우)
    if (useEventRates && (selectedRarity === 'SSR' || selectedRarity === 'SR')) {
        // 픽업 대상 캐릭터가 현재 뽑기 가능 목록에 있는지 확인
        const pickupChar = possibleCharacters.find(c => c.name === EVENT_CHARACTER_NAME);
        
        if (pickupChar) {
            // 50% 확률로 픽업 캐릭터 등장
            if (Math.random() < 0.5) {
                return pickupChar;
            } else {
                // 나머지 50%는 픽업 캐릭터를 제외한 다른 애들 중에서 랜덤
                const otherChars = possibleCharacters.filter(c => c.name !== EVENT_CHARACTER_NAME);
                if (otherChars.length > 0) {
                    return otherChars[Math.floor(Math.random() * otherChars.length)];
                }
                return pickupChar; // 다른 애가 없으면 픽업캐 줌
            }
        }
    }

    // 4. 최종 랜덤 선택
    return possibleCharacters[Math.floor(Math.random() * possibleCharacters.length)];
}

            function displayResults(pulledCharacters) {
                resultsContainer.innerHTML = '';
                pulledCharacters.forEach((character, index) => {
                    resultsContainer.appendChild(createCard(character, { animationIndex: index, mode: 'gachaResult' }));
                });
            }
            
            function getUniqueInventory() {
                const cardCounts = playerInventory.reduce((acc, card) => {
                    if (card && card.name) {
                        if (!acc[card.name]) { acc[card.name] = { ...card, count: 0 }; }
                        acc[card.name].count++;
                    }
                    return acc;
                }, {});
                const rarityOrder = { 'SSR': 4, 'SR': 3, 'R': 2, 'N': 1 };
                return Object.values(cardCounts).sort((a, b) => (rarityOrder[b.rarity] - rarityOrder[a.rarity]) || a.name.localeCompare(b.name));
            }

            // ✅ 이 코드로 기존 displayInventory 함수를 통째로 교체해주세요.
            // ✅ 이 코드로 기존 displayInventory 함수를 통째로 교체해주세요.
            function displayInventory() {
    inventoryStatus.textContent = `${playerInventory.length} / ${inventoryCapacity}`;
    inventoryContainer.innerHTML = '';

    // ✨ [핵심 헬퍼] 카드의 '진짜 등급'을 판별하는 함수
    // 자식 카드라면 inherited.originalRarity를, 일반 카드라면 원본 데이터의 rarity를 반환
    const getRealRarity = (card) => {
        if (card.inherited && card.inherited.originalRarity) {
            return card.inherited.originalRarity;
        }
        const char = findCharacter(card.name);
        return char ? char.rarity : 'N'; // 데이터 없으면 N 처리
    };

    // --- 1. 필터링 로직 (수정됨) ---
    const filteredInventory = playerInventory.filter(cardInstance => {
        if (currentRarityFilter === 'All') return true;
        // 기존: findCharacter(cardInstance.name).rarity (X) -> 이름만 보고 판단함
        // 수정: getRealRarity(cardInstance) (O) -> 유전 정보까지 확인
        return getRealRarity(cardInstance) === currentRarityFilter;
    });

    if (filteredInventory.length === 0) {
        const emptyMessage = currentRarityFilter === 'All' 
            ? '아직 수집한 등장인물이 없습니다.' 
            : `해당 등급의 등장인물이 없습니다.`;
        inventoryContainer.innerHTML = `<p class="col-span-full text-center text-gray-400 mt-10">${emptyMessage}</p>`;
        if (isMultiSelectMode) {
            updateMultiSelectUI();
        }
        return;
    }

    // --- 2. 정렬 로직 (수정됨) ---
    const rarityOrder = { 'SSR': 4, 'SR': 3, 'R': 2, 'N': 1 };
    const sortedInventory = [...filteredInventory].sort((a, b) => {
        const charA = findCharacter(a.name);
        const charB = findCharacter(b.name);

        // 안전장치
        if (!charA && !charB) return 0;
        if (!charA) return 1;
        if (!charB) return -1;

        // ✨ [수정] 정렬 시에도 '진짜 등급'을 기준으로 점수 매기기
        const rA = rarityOrder[getRealRarity(a)] || 0;
        const rB = rarityOrder[getRealRarity(b)] || 0;

        let comparison = 0;
        switch (currentSortOrder) {
            case 'level':
                // 퇴고 순: 레벨 > 등급 > 이름
                comparison = (b.level - a.level) || (rB - rA) || charA.baseName.localeCompare(charB.baseName);
                break;
            case 'revision':
                // 개정 순: 개정 > 등급 > 이름
                comparison = (b.revision - a.revision) || (rB - rA) || charA.baseName.localeCompare(charB.baseName);
                break;
            case 'name':
                // 이름 순: 이름 > 등급 > 레벨
                comparison = charA.baseName.localeCompare(charB.baseName) || (rB - rA) || (b.level - a.level);
                break;
            case 'rarity':
            default:
                // 등급 순: 등급 > 이름 > 레벨
                comparison = (rB - rA) || charA.baseName.localeCompare(charB.baseName) || (b.level - a.level);
                break;
        }
        return isSortAscending ? comparison * -1 : comparison;
    });

    // --- 3. 화면 표시 (기존 유지) ---
    sortedInventory.forEach((cardInstance, index) => {
        const character = findCharacter(cardInstance.name);
        if (character) {
            const cardElement = createCard(character, { animationIndex: index, mode: 'inventory', instance: cardInstance });
            if (isMultiSelectMode) {
                cardElement.classList.add('multi-select-card');
                const isInDeck = playerDeck.some(deckCard => deckCard.id === cardInstance.id);
                if (isInDeck) {
                    cardElement.classList.add('opacity-40', 'cursor-not-allowed', 'bg-red-900/30');
                    cardElement.title = "덱에 포함되어 파쇄 불가";
                } else {
                    cardElement.classList.add('cursor-pointer');
                }
                if (selectedCardsToDismantle.has(cardInstance.id)) {
                    cardElement.classList.remove('bg-black/20');
                    cardElement.classList.add('border-4', 'border-yellow-400', 'bg-blue-900/50');
                } else if (!isInDeck) {
                    cardElement.classList.add('border', 'border-gray-500', 'bg-black/20');
                }
                cardElement.querySelector('[data-action="set-representative"]').classList.add('hidden');
            }
            inventoryContainer.appendChild(cardElement);
        }
    });

    // --- 4. 버튼 UI 업데이트 ---
    document.querySelectorAll('.sort-button').forEach(btn => {
        btn.classList.remove('active', 'bg-blue-500');
        btn.querySelector('.sort-indicator').textContent = '';
    });
    const activeSortButton = document.querySelector(`.sort-button[data-sort="${currentSortOrder}"]`);
    if (activeSortButton) {
        activeSortButton.classList.add('active', 'bg-blue-500');
        activeSortButton.querySelector('.sort-indicator').textContent = isSortAscending ? ' ▲' : ' ▼';
    }

    document.querySelectorAll('.filter-button').forEach(btn => {
        btn.classList.remove('active', 'bg-blue-500');
        if (btn.dataset.filter === currentRarityFilter) {
            btn.classList.add('active', 'bg-blue-500');
        }
    });
    
    if (isMultiSelectMode) {
        updateMultiSelectUI();
    }
}

		// ================== ✨ 마이룸 & 가구 상점 로직 시작 ✨ ==================

// 1. 마이룸 화면 표시 (캐릭터 & 가구 렌더링)
		// ================== ✨ 아이소메트릭(마름모) 변환 로직 ✨ ==================

// 1. 그리드 좌표 변환 함수 (벽 안쪽으로 범위 축소)
function getIsoPos(gridX, gridY) {
    const centerX = 50; 
    
    // ✨ [수정 1] 바닥 중심점 높이 (30 -> 35)
    // 전체적으로 살짝 내려서 위쪽 벽에 닿지 않게 합니다.
    const centerY = 45; 
    
    // ✨ [수정 2] 너비 계수 축소 (0.46 -> 0.38)
    // 좌우 벽 두께만큼 안쪽으로 들여옵니다.
    const widthFactor = 0.38;  
    
    // ✨ [수정 3] 높이 계수 축소 (0.30 -> 0.24)
    // 아래쪽 벽에 닿지 않게 상하 폭을 줄입니다.
    const heightFactor = 0.24; 
    
    const screenX = centerX + (gridX - gridY) * widthFactor;
    const screenY = centerY + (gridX + gridY) * heightFactor;
    
    const zIndex = Math.floor(gridX + gridY);
    
    return { left: screenX, top: screenY, zIndex: zIndex };
}

// 2. 역변환 함수 (위와 변수값 일치 필수)
function getGridPosFromScreen(screenX, screenY) {
    const centerX = 50;
    const centerY = 45; // ✨ 일치시킴
    
    const widthFactor = 0.38; // ✨ 일치시킴
    const heightFactor = 0.24; // ✨ 일치시킴
    
    const dx = (screenX - centerX) / widthFactor;
    const dy = (screenY - centerY) / heightFactor;
    
    let gridX = (dx + dy) / 2;
    let gridY = (dy - dx) / 2;
    
    gridX = Math.max(0, Math.min(100, gridX));
    gridY = Math.max(0, Math.min(100, gridY));
    
    return { x: gridX, y: gridY };
}

// ================== ✨ 수정된 displayMyRoom (전체 코드) ✨ ==================
function displayMyRoom() {
    const roomLayer = document.getElementById('room-layer');
    if (!roomLayer) return;
    roomLayer.innerHTML = '';

    if (!playerRoom.furniture) playerRoom.furniture = [];

    // (1) 가구 렌더링 (기존과 동일)
    playerRoom.furniture.forEach((item, index) => {
        const furnitureData = furnitureItems.find(f => f.id === item.id);
        if (furnitureData) {
            const el = document.createElement('img');
            el.src = furnitureData.imageUrl;
            el.className = 'placed-furniture absolute transition-transform duration-200 pointer-events-auto';
            el.dataset.id = item.id;
            el.dataset.key = index;

            const iso = getIsoPos(item.x, item.y);
            el.style.left = `${iso.left}%`;
            el.style.top = `${iso.top}%`;
            
            const flipTransform = item.isFlipped ? 'scaleX(-1)' : 'scaleX(1)';
            let zOffset = 0;

            if (furnitureData.type === 'rug') {
                el.style.transform = `translate(-50%, -50%) rotate(45deg) scaleY(0.58) ${flipTransform}`;
                el.style.width = `${furnitureData.size.w * 7}%`; 
                el.style.opacity = '0.95';
                zOffset = -100; 
            } else if (furnitureData.type === 'wall') {
                el.style.transform = `translate(-50%, -200%) ${flipTransform}`;
                el.style.width = `${furnitureData.size.w * 10}%`; 
                zOffset = -50; 
            } else {
                el.style.transform = `translate(-50%, -95%) ${flipTransform}`;
                let baseWidth = 12; 
                if (furnitureData.scale) baseWidth = baseWidth * furnitureData.scale;
                el.style.width = `${baseWidth}%`; 
                el.style.filter = 'drop-shadow(0px 5px 5px rgba(0,0,0,0.5))'; 
                zOffset = 0; 
            }
            el.style.zIndex = iso.zIndex + zOffset; 
            roomLayer.appendChild(el);
        }
    });

    // (2) 캐릭터 렌더링
    let activeCharacters = [];

    if (playerRoom.characters && playerRoom.characters.length > 0) {
        if (typeof playerRoom.characters[0] === 'string') {
            activeCharacters = playerRoom.characters
                .map(id => playerInventory.find(c => c.id === id))
                .filter(Boolean);
        } else {
            activeCharacters = playerRoom.characters;
        }
    }

    if (activeCharacters.length === 0) {
        activeCharacters = playerDeck.length > 0 ? playerDeck : playerInventory.slice(0, 5);
    }

    activeCharacters.forEach((card, index) => {
        const charData = findCharacter(card.name);
        if (!charData) return;

        const el = document.createElement('div');
        el.className = 'chibi-character absolute cursor-pointer transition-all duration-[2000ms] ease-linear pointer-events-auto';
        el.id = `chibi-${index}`;
        el.dataset.charName = charData.name;
        
        const gridX = Math.random() * 90;
        const gridY = Math.random() * 90;
        const iso = getIsoPos(gridX, gridY);

        el.style.left = `${iso.left}%`;
        el.style.top = `${iso.top}%`;
        el.style.transform = 'translate(-50%, -90%)'; 
        el.style.width = `${TILE_WIDTH_PERCENT * 1.3}%`; 
        el.style.height = 'auto'; 
        el.style.zIndex = iso.zIndex + 50;

        const img = document.createElement('img');
        img.src = (typeof chibiImages !== 'undefined' && chibiImages[charData.name]) ? chibiImages[charData.name] : charData.cardImageUrl;
        img.className = 'w-full h-full object-contain drop-shadow-lg';
        el.appendChild(img);

        const bubble = document.createElement('div');
        bubble.className = 'chibi-bubble absolute -top-10 left-1/2 -translate-x-1/2 bg-white text-black px-2 py-1 rounded-lg text-xs whitespace-nowrap opacity-0 transition-opacity duration-300 pointer-events-none z-20 border border-gray-300 shadow-sm';
        bubble.innerText = charData.dialogues[0];
        el.appendChild(bubble);

        // ✨✨ [수정됨] 하트 버튼 (텍스트 제거) ✨✨
        if (currentVisitTargetUid && !hasDoneFavorToday) {
            const heartBtn = document.createElement('div');
            
            // 위치 조정: 텍스트가 빠졌으니 약간 더 내려도 됩니다 (-top-16 -> -top-14 정도)
            heartBtn.className = 'absolute -top-14 left-1/2 -translate-x-1/2 cursor-pointer z-50';
            
            // ✨ 내부 HTML에서 'Favor' 텍스트 div를 삭제했습니다.
            heartBtn.innerHTML = `
                <div class="bg-white/90 border-2 border-pink-400 rounded-full p-2 shadow-lg hover:scale-110 transition-transform">
                    <span class="text-xl">💖</span>
                </div>
            `;
            
            heartBtn.onclick = (e) => {
                e.stopPropagation(); 
                sendFavorToFriend(currentVisitTargetUid, card.name, heartBtn);
            };
            
            el.appendChild(heartBtn);
        }

        el.addEventListener('click', (e) => {
            e.stopPropagation();
            const randomDialogue = charData.dialogues[Math.floor(Math.random() * charData.dialogues.length)];
            bubble.innerText = randomDialogue;
            bubble.style.opacity = 1;
            setTimeout(() => bubble.style.opacity = 0, 3000);
        });

        roomLayer.appendChild(el);
        
        if (!el.dataset.gridX) {
             el.dataset.gridX = gridX;
             el.dataset.gridY = gridY;
        }
        
        startChibiMovement(el);
    });
    
    initInteractionSystem();
}

		// ================== ✨ 캐릭터 상호작용 시스템 ✨ ==================

let interactionCheckInterval = null;

// 1. 상호작용 체크 시스템 (기존 함수)
function initInteractionSystem() {
    if (interactionCheckInterval) clearInterval(interactionCheckInterval);

    // 1초마다 캐릭터들의 거리를 확인
    interactionCheckInterval = setInterval(() => {
        const myRoomView = document.getElementById('myroom-view');
        if (!myRoomView || myRoomView.classList.contains('hidden')) return;

        const characters = document.querySelectorAll('.chibi-character');
        if (characters.length < 2) return;

        // 이중 루프로 두 캐릭터 간의 거리 비교
        for (let i = 0; i < characters.length; i++) {
            for (let j = i + 1; j < characters.length; j++) {
                const charA = characters[i];
                const charB = characters[j];

                // 이미 대화 중이면 패스
                if (charA.dataset.isInteracting === 'true' || charB.dataset.isInteracting === 'true') continue;

                // 쿨타임 체크
                const now = Date.now();
                if (charA.dataset.lastInteraction && now - charA.dataset.lastInteraction < 10000) continue;
                if (charB.dataset.lastInteraction && now - charB.dataset.lastInteraction < 10000) continue;

                // 거리 계산
                const x1 = parseFloat(charA.dataset.gridX);
                const y1 = parseFloat(charA.dataset.gridY);
                const x2 = parseFloat(charB.dataset.gridX);
                const y2 = parseFloat(charB.dataset.gridY);

                const dist = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));

                // 거리가 15 이내이면 상호작용 시작
                if (dist < 15) {
                    triggerInteraction(charA, charB);
                    return; 
                }
            }
        }
    }, 1000);
}

async function sendFavorToFriend(friendUid, charName, btnElement) {
    if (hasDoneFavorToday) return; // 중복 방지
    
    // UI 즉시 반응 (버튼 숨기기 & 클릭 방지)
    btnElement.style.display = 'none';
    hasDoneFavorToday = true; // 임시 락

    const batch = db.batch();
    const todayStr = new Date().toDateString();

    try {
        // 1. 내 기록 업데이트 (오늘 이 친구에게 했다고 기록)
        const myHistoryRef = db.collection('users').doc(currentUser.uid)
                               .collection('favorHistory').doc(friendUid);
        batch.set(myHistoryRef, { lastFavorDate: todayStr });

        // 2. 나에게 보상 우편 발송
        const myMailRef = db.collection('users').doc(currentUser.uid).collection('mailbox').doc();
        batch.set(myMailRef, {
            title: '💖 페이버 보상 (방문)',
            content: `친구의 객실을 방문하여 [${charName}]와(과) 교감했습니다.`,
            rewards: { currency: 10 }, // 보석 10개
            createdAt: firebase.firestore.FieldValue.serverTimestamp(),
            read: false
        });

        // 3. 친구에게 보상 우편 발송
        const friendMailRef = db.collection('users').doc(friendUid).collection('mailbox').doc();
        batch.set(friendMailRef, {
            title: `💖 페이버 도착 (${currentPlayerNickname})`,
            content: `${currentPlayerNickname}님이 방문하여 [${charName}]에게 인사를 건넸습니다!`,
            rewards: { currency: 10 }, // 보석 10개
            createdAt: firebase.firestore.FieldValue.serverTimestamp(),
            read: false
        });

        await batch.commit();

        // 성공 효과
        showMessage(`💖 교감 완료! 보상이 우편으로 지급되었습니다.`, 'text-pink-300', messageArea);
        
        // 화면 갱신 (하트 완전히 없애기 위해)
        displayMyRoom();

    } catch (error) {
        console.error("페이버 전송 실패:", error);
        alert("오류가 발생했습니다.");
        hasDoneFavorToday = false; // 실패 시 락 해제
        btnElement.style.display = 'block'; // 버튼 복구
    }
}

// 2. 대화 발생 및 안전장치 (수정된 함수)
// yumecan.html - triggerInteraction 함수 교체

// [수정됨] 상호작용 발생 함수 (안전장치 강화)
function triggerInteraction(charA, charB) {
    charA.dataset.isInteracting = 'true';
    charB.dataset.isInteracting = 'true';

    try {
        const ax = parseFloat(charA.style.left);
        const bx = parseFloat(charB.style.left);
        const imgA = charA.querySelector('img');
        const imgB = charB.querySelector('img');
        
        // 서로 마주보게 하기
        if (ax < bx) { imgA.style.transform = 'scaleX(-1)'; imgB.style.transform = 'scaleX(1)'; } 
        else { imgA.style.transform = 'scaleX(1)'; imgB.style.transform = 'scaleX(-1)'; }

        // ✨ [핵심 수정] 리스트 인덱스 대신, 1단계에서 붙여둔 이름표(dataset)를 직접 읽습니다.
        // 이러면 덱/인벤토리 순서가 바뀌어도 오류가 나지 않습니다.
        const charDataA = findCharacter(charA.dataset.charName);
        const charDataB = findCharacter(charB.dataset.charName);

        if (!charDataA || !charDataB) {
            // 데이터가 없으면 조용히 종료 (에러 방지)
            console.warn("상호작용 캐릭터 데이터를 찾을 수 없습니다.");
            return; 
        }

        const nameA = charDataA.baseName.trim();
        const nameB = charDataB.baseName.trim();
        const searchKey = [nameA, nameB].sort().join('_');

        console.log(`[상호작용] ${nameA} & ${nameB} (${searchKey})`);

        let speaker1, speaker2;
        let dialogue1, dialogue2;

        // 고유 대사 확인
        if (interactionDialogues && interactionDialogues[searchKey]) {
            const match = interactionDialogues[searchKey];
            const randomPick = match.dialogues[Math.floor(Math.random() * match.dialogues.length)];
            
            // 화자 순서 맞추기
            if (match.pair[0] === nameA) {
                speaker1 = charA; speaker2 = charB;
            } else {
                speaker1 = charB; speaker2 = charA;
            }
            dialogue1 = randomPick[0];
            dialogue2 = randomPick[1];

        } else {
            // 범용 대사
            const randomPick = genericInteractions[Math.floor(Math.random() * genericInteractions.length)];
            speaker1 = charA;
            speaker2 = charB;
            dialogue1 = randomPick[0];
            dialogue2 = randomPick[1];
        }

        // 대사 출력
        showBubble(speaker1, dialogue1);
        setTimeout(() => showBubble(speaker2, dialogue2), 1000);

    } catch (error) {
        console.warn("상호작용 에러 처리됨:", error);
    } finally {
        // 4초 후 대화 상태 해제
        setTimeout(() => {
            if(charA) {
                charA.dataset.isInteracting = 'false';
                charA.dataset.lastInteraction = Date.now();
            }
            if(charB) {
                charB.dataset.isInteracting = 'false';
                charB.dataset.lastInteraction = Date.now();
            }
        }, 4000);
    }
}

function showBubble(charEl, text) {
    const bubble = charEl.querySelector('.chibi-bubble');
    if (bubble) {
        bubble.innerText = text;
        bubble.style.opacity = 1;
        bubble.style.zIndex = 100; // 말풍선 맨 위로
        setTimeout(() => {
            bubble.style.opacity = 0;
            bubble.style.zIndex = 20;
        }, 3000);
    }
}


// 캐릭터 이동 함수 (한 칸씩 이동 + 안전장치 추가)
function startChibiMovement(element) {
    if (element.dataset.moveInterval) clearInterval(element.dataset.moveInterval);

    const move = () => {
        const myRoomView = document.getElementById('myroom-view');
        if (!myRoomView || myRoomView.classList.contains('hidden')) return;
        if (element.dataset.isInteracting === 'true') return;

        let targetGridX, targetGridY;
        let attempts = 0;
        let finalTarget = null; // 최종 목적지

        // ✨ [핵심 로직] 빈 자리를 찾기 위해 10번 시도합니다.
        while (attempts < 10) {
            // 0~9 사이 랜덤 좌표 생성
            // 1. 가장자리(0과 100 근처)에 너무 붙지 않도록 10 ~ 90 사이의 좌표를 생성합니다.
const margin = 10;
const effectiveSize = GRID_SIZE - (margin * 2); // 100 - 20 = 80
const testX = Math.floor(Math.random() * effectiveSize) + margin;
const testY = Math.floor(Math.random() * effectiveSize) + margin;

// 2. 가구 충돌 체크 범위 수정 (좌표가 0~100이 되었으므로 범위도 넓혀야 함)
const isBlocked = playerRoom.furniture.some(f => {
    const itemData = furnitureItems.find(i => i.id === f.id);
    if (!itemData || itemData.type === 'wall' || itemData.type === 'rug') return false;
    
    // 가구 중심점(f.x, f.y)과 목표 지점(testX, testY)의 거리를 계산
    // 거리가 6 이내면 부딪힌 것으로 간주 (가구 크기에 따라 조절 가능)
    const dist = Math.sqrt(Math.pow(f.x - testX, 2) + Math.pow(f.y - testY, 2));
    return dist < 6; 
});
           

            // 빈 자리라면? -> 여기로 결정하고 반복 종료!
            if (!isBlocked) {
                finalTarget = { x: testX, y: testY };
                break;
            }
            
            // 막힌 자리라면? -> 일단 후보지로 저장해두고 다시 시도 (정 갈 데 없으면 여기라도 가야 하니까)
            if (!finalTarget) {
                finalTarget = { x: testX, y: testY };
            }

            attempts++;
        }

        // (안전장치) 혹시라도 타겟이 없으면 현재 위치 유지
        if (!finalTarget) return;

        // --- 이동 실행 ---
        const iso = getIsoPos(finalTarget.x, finalTarget.y);
        
        const currentLeft = parseFloat(element.style.left) || iso.left;
        const img = element.querySelector('img');
        
        if (iso.left < currentLeft) {
            img.style.transform = 'scaleX(1)'; 
            element.dataset.facing = 'left';
        } else {
            img.style.transform = 'scaleX(-1)'; 
            element.dataset.facing = 'right';
        }

        element.style.left = `${iso.left}%`;
        element.style.top = `${iso.top}%`;
        
        // 가구보다 살짝 앞에 서기
        element.style.zIndex = iso.zIndex + 5;
        
        element.dataset.gridX = finalTarget.x;
        element.dataset.gridY = finalTarget.y;
    };

    // 2.5초 ~ 4.5초 간격으로 이동 (너무 정신없지 않게)
    const interval = setInterval(move, Math.random() * 2000 + 2500);
    element.dataset.moveInterval = interval;
}

// ✨ [신규] 교환소 인벤토리 클릭 이벤트 리스너 (여기에 추가하세요!)
// 4. 인벤토리 클릭 이벤트 (위임) - [변수명 중복 해결 버전]
        const tradeInvWrapper = document.getElementById('trade-inventory-container'); // 변수명 변경됨
        if (tradeInvWrapper) {
            tradeInvWrapper.addEventListener('click', (e) => {
                const cardEl = e.target.closest('[data-card-id]');
                if (cardEl) {
                    const clickedId = cardEl.dataset.cardId;
                    selectedTradeCardId = clickedId;
                    
                    const cardInstance = playerInventory.find(c => c.id === clickedId);
                    if (cardInstance) {
                        const charData = findCharacter(cardInstance.name);
                        document.getElementById('trade-selected-name').innerHTML = 
                            `<span class="text-yellow-300">${charData.name}</span> <span class="text-xs text-gray-400">(Lv.${cardInstance.level})</span>`;
                        document.getElementById('trade-selected-card-preview').classList.remove('hidden');
                        loadTradeInventory();
                    }
                }
            });
        }

// ================== ✨ 수정된 initDragEvents (배치 모드) ✨ ==================
function initDragEvents() {
    const container = document.getElementById('room-container');

    const handleStart = (e) => {
        if (!isEditMode) return;
        let target = e.target;
        
        if (e.type === 'touchstart') {
            const touch = e.touches[0];
            target = document.elementFromPoint(touch.clientX, touch.clientY);
            if (!target || !target.classList.contains('placed-furniture')) return;
        }

        if (target && target.classList.contains('placed-furniture')) {
            if (e.cancelable) e.preventDefault();
            draggedFurniture = target;
            draggedFurniture.style.cursor = 'grabbing';
            draggedFurniture.style.zIndex = 9999; // 드래그 중엔 맨 위로
            draggedFurniture.style.transition = 'none'; // 드래그 중엔 애니메이션 끔

            const clientX = e.type === 'touchstart' ? e.touches[0].clientX : e.clientX;
            const clientY = e.type === 'touchstart' ? e.touches[0].clientY : e.clientY;
            const rect = draggedFurniture.getBoundingClientRect();
            
            // 중심점 기준 드래그를 위해 오프셋 조정
            dragOffsetX = clientX - rect.left - (rect.width / 2);
            dragOffsetY = clientY - rect.top - (rect.height / 2);
        }
    };

    const handleMove = (e) => {
        if (!isEditMode || !draggedFurniture) return;
        if (e.cancelable) e.preventDefault();

        const containerRect = container.getBoundingClientRect();
        const clientX = e.type === 'touchmove' ? e.touches[0].clientX : e.clientX;
        const clientY = e.type === 'touchmove' ? e.touches[0].clientY : e.clientY;

        // 화면상 좌표 (%, 픽셀 -> 퍼센트 변환)
        let screenX = ((clientX - containerRect.left) / containerRect.width) * 100;
        let screenY = ((clientY - containerRect.top) / containerRect.height) * 100;

        // 시각적 업데이트
        draggedFurniture.style.left = `${screenX}%`;
        draggedFurniture.style.top = `${screenY}%`;
    };

    const handleEnd = (e) => {
        if (!isEditMode || !draggedFurniture) return;

        // 드래그가 끝난 시점의 화면 좌표(%)
        const currentLeft = parseFloat(draggedFurniture.style.left);
        const currentTop = parseFloat(draggedFurniture.style.top);
        
        // ✨ 화면 좌표를 다시 그리드 좌표(x, y)로 역변환하여 저장
        const gridPos = getGridPosFromScreen(currentLeft, currentTop);
        
        const uniqueKey = draggedFurniture.dataset.key;
        if (uniqueKey !== undefined && playerRoom.furniture[uniqueKey]) {
            playerRoom.furniture[uniqueKey].x = gridPos.x;
            playerRoom.furniture[uniqueKey].y = gridPos.y;
        }

        // z-index 재계산 및 스타일 복구
        const newIso = getIsoPos(gridPos.x, gridPos.y);
        draggedFurniture.style.zIndex = newIso.zIndex;
        draggedFurniture.style.cursor = 'grab';
        draggedFurniture.style.transition = ''; // 애니메이션 복구
        
        // 최종 위치 보정 (정확한 그리드 위치로 스냅)
        draggedFurniture.style.left = `${newIso.left}%`;
        draggedFurniture.style.top = `${newIso.top}%`;

        draggedFurniture = null;
    };

    container.addEventListener('mousedown', handleStart);
    window.addEventListener('mousemove', handleMove);
    window.addEventListener('mouseup', handleEnd);

    container.addEventListener('touchstart', handleStart, { passive: false });
    window.addEventListener('touchmove', handleMove, { passive: false });
    window.addEventListener('touchend', handleEnd);

    container.addEventListener('contextmenu', (e) => {
        if (!isEditMode) return;
        if (e.target.classList.contains('placed-furniture')) {
            e.preventDefault();
            if(confirm('이 가구를 회수하시겠습니까?')) {
                const uniqueKey = e.target.dataset.key;
                if (uniqueKey !== undefined) {
                    playerRoom.furniture.splice(uniqueKey, 1);
                    displayMyRoom();
                    saveGame();
                    toggleEditMode(); 
                    toggleEditMode(); 
                }
            }
        }
    });
	// 4. 더블 클릭 시 가구 좌우 반전 (최적화 버전)
    container.addEventListener('dblclick', (e) => {
        if (!isEditMode) return;
        
        let target = e.target;
        if (!target.classList.contains('placed-furniture')) return;

        e.preventDefault();
        e.stopPropagation(); // 이벤트 전파 중단 (중요)
        
        const uniqueKey = target.dataset.key;
        const item = playerRoom.furniture[uniqueKey]; // 데이터 원본 가져오기

        if (uniqueKey !== undefined && item) {
            // 1. 데이터 값 변경
            item.isFlipped = !item.isFlipped;
            
            // 2. 화면 갱신 (전체를 다시 그리지 않고, 해당 요소 스타일만 변경)
            const furnitureData = furnitureItems.find(f => f.id === item.id);
            const flipTransform = item.isFlipped ? 'scaleX(-1)' : 'scaleX(1)';

            // 가구 타입에 따른 transform 재계산
            if (furnitureData.type === 'rug') {
                target.style.transform = `translate(-50%, -50%) rotate(45deg) scaleY(0.58) ${flipTransform}`;
            } else if (furnitureData.type === 'wall') {
                target.style.transform = `translate(-50%, -200%) ${flipTransform}`;
            } else {
                target.style.transform = `translate(-50%, -95%) ${flipTransform}`;
            }
            
            // ❌ displayMyRoom(); <-- 이거 때문에 튕기는 거라 삭제했습니다.
            // ❌ saveGame();      <-- 저장도 나중에 한꺼번에 합니다.
        }
    });

} // initDragEvents 끝


// ================== ✨ [신규] 가구 보관함 기능 시작 ✨ ==================

// 1. 가구 보관함 열기 (보유 중이지만 방에 없는 가구만 표시)
// 1. 가구 보관함 열기 (수량 계산 로직 적용)
function openFurnitureStorage() {
    const list = document.getElementById('storage-list');
    const modal = document.getElementById('furniture-storage-modal');
    if (!list || !modal) return;

    list.innerHTML = '';

    // 1. 현재 방에 배치된 가구들의 ID별 개수를 셉니다.
    const placedCounts = {};
    playerRoom.furniture.forEach(f => {
        placedCounts[f.id] = (placedCounts[f.id] || 0) + 1;
    });

    // 2. 전체 보유 가구의 ID별 개수를 셉니다.
    const ownedCounts = {};
    ownedFurniture.forEach(id => {
        ownedCounts[id] = (ownedCounts[id] || 0) + 1;
    });

    // 3. (보유 개수 - 배치 개수)가 1개 이상인 가구만 추출합니다.
    const uniqueOwnedIds = [...new Set(ownedFurniture)]; // 중복 제거된 ID 목록
    
    let hasItem = false;

    uniqueOwnedIds.forEach(id => {
        const totalOwned = ownedCounts[id] || 0;
        const totalPlaced = placedCounts[id] || 0;
        const availableCount = totalOwned - totalPlaced; // 보관함에 남아있는 개수

        if (availableCount > 0) {
            hasItem = true;
            const item = furnitureItems.find(f => f.id === id);
            if (!item) return;

            const div = document.createElement('div');
            div.className = 'bg-black/40 p-3 rounded flex flex-col items-center text-center border border-purple-500/30 hover:bg-purple-900/20 transition-colors cursor-pointer';
            
            // 클릭 시 배치
            div.onclick = () => placeFurnitureFromStorage(id);

            div.innerHTML = `
                <div class="h-16 w-full flex items-center justify-center mb-2 bg-black/20 rounded pointer-events-none relative">
                    <img src="${item.imageUrl}" class="max-h-full max-w-full">
                    <span class="absolute top-0 right-0 bg-blue-600 text-white text-xs font-bold px-1.5 py-0.5 rounded-bl">x${availableCount}</span>
                </div>
                <p class="font-bold text-white text-sm mb-1 pointer-events-none">${item.name}</p>
                <p class="text-green-400 text-xs pointer-events-none">클릭하여 배치</p>
            `;
            list.appendChild(div);
        }
    });

    if (!hasItem) {
        list.innerHTML = `<p class="col-span-3 text-center text-gray-500 py-4">보관 중인 가구가 없습니다.<br>모든 가구를 배치했습니다.</p>`;
    }
    modal.classList.remove('hidden');
}

// (참고) placeFurnitureFromStorage 함수는 기존 유지하되, isFlipped 초기값만 추가해주세요.
// 기존: playerRoom.furniture.push({ id: item.id, x: 45, y: 45 });
// 수정: playerRoom.furniture.push({ id: item.id, x: 45, y: 45, isFlipped: false });

// 2. 보관함에서 가구 꺼내기 (배치)
function placeFurnitureFromStorage(furnitureId) {
    const item = furnitureItems.find(f => f.id === furnitureId);
    if (!item) return;

    // 방 중앙에 배치
    playerRoom.furniture.push({ id: item.id, x: 45, y: 45, isFlipped: false });
    
    showMessage(`${item.name} 배치 완료!`, 'text-green-300', messageArea);
    
    // 화면 갱신
    displayMyRoom();
    saveGame();
    
    // 보관함 목록 갱신 (방금 꺼낸 건 사라져야 함)
    openFurnitureStorage();
}

// ================== ✨ 가구 보관함 기능 끝 ✨ ==================
		
// 2. 가구 상점 열기
// 2. 가구 상점 열기 (수정됨)
function openFurnitureShop() {
    const list = document.getElementById('furniture-list');
    const modal = document.getElementById('furniture-shop-modal');
    if (!list || !modal) return;

    list.innerHTML = '';

    furnitureItems.forEach(item => {
        // 현재 보유 중인 개수 계산
        const ownedCount = ownedFurniture.filter(id => id === item.id).length;
        
        const div = document.createElement('div');
        div.className = 'bg-black/40 p-3 rounded flex flex-col items-center text-center border border-white/10';
        
        // 돈이 충분한지 확인
        const canAfford = playerCurrency >= item.cost;
        
        // 버튼 스타일 결정 (보유 여부 상관없이 돈만 있으면 활성화)
        const btnClass = canAfford 
            ? 'bg-green-500 hover:bg-green-600 cursor-pointer' 
            : 'bg-red-500 opacity-50 cursor-not-allowed';
            
        const btnDisabled = canAfford ? '' : 'disabled';

        div.innerHTML = `
            <div class="h-16 w-full flex items-center justify-center mb-2 bg-black/20 rounded relative">
                <img src="${item.imageUrl}" class="max-h-full max-w-full">
                ${ownedCount > 0 ? `<span class="absolute top-0 right-0 bg-blue-600 text-white text-xs font-bold px-1.5 py-0.5 rounded-bl">x${ownedCount}</span>` : ''}
            </div>
            <p class="font-bold text-white text-sm mb-1">${item.name}</p>
            <p class="text-yellow-300 text-xs mb-2">💎 ${item.cost}</p>
            <button class="gacha-button text-xs py-1 px-3 rounded-full text-white font-bold w-full transition-colors ${btnClass}" 
                ${btnDisabled} 
                onclick="buyFurniture('${item.id}')">
                구매
            </button>
        `;
        list.appendChild(div);
    });
    modal.classList.remove('hidden');
}

// 3. 가구 구매 (중복 구매 허용 버전)
window.buyFurniture = function(furnitureId) {
    const item = furnitureItems.find(f => f.id === furnitureId);
    if (!item) return;

    // ❌ 기존의 중복 체크 로직 삭제
    // if (ownedFurniture.includes(item.id)) { ... } 

    if (playerCurrency >= item.cost) {
        if (!confirm(`${item.name}을(를) 💎${item.cost}에 구매하시겠습니까?`)) return;

        playerCurrency -= item.cost;
        
        // 보유 목록에 추가 (같은 ID가 여러 번 들어감)
        ownedFurniture.push(item.id);
        
        // 구매 즉시 방 중앙에 자동 배치 (초기 상태: 반전 없음)
        playerRoom.furniture.push({ id: item.id, x: 45, y: 45, isFlipped: false });
        
        showMessage(`${item.name} 구매 완료!`, 'text-green-300', messageArea);
        
        updateUI();
        saveGame();
        openFurnitureShop(); 
        displayMyRoom(); 
    } else {
        alert('보석이 부족합니다.');
    }
};

let playerLastRaidSpawnId = 0;

		// ================== 🔨 배치 모드(Edit Mode) 로직 시작 ==================

let isEditMode = false; // 현재 배치 모드인지 여부
let draggedFurniture = null; // 드래그 중인 가구 요소
let dragOffsetX = 0;
let dragOffsetY = 0;

// 1. 배치 모드 토글 함수
function toggleEditMode() {
if (!document.getElementById('visit-mode-overlay').classList.contains('hidden')) {
        return;
    }
    isEditMode = !isEditMode;
    const btn = document.getElementById('myroom-edit-mode');
    const container = document.getElementById('room-container');
    
    // ✨ [추가] 보관함 버튼 요소 가져오기
    const storageBtn = document.getElementById('open-furniture-storage');

    if (isEditMode) {
        // [ON] 배치 모드 켜짐
        btn.textContent = '✅ 저장 완료';
        btn.classList.remove('bg-blue-500', 'hover:bg-blue-600');
        btn.classList.add('bg-green-600', 'hover:bg-green-700');
        
        container.classList.add('border-yellow-400'); 
        
        // ✨ [추가] 보관함 버튼 보이기
        if(storageBtn) storageBtn.classList.remove('hidden');

        // 캐릭터 숨기기
        document.querySelectorAll('.chibi-character').forEach(el => el.classList.add('hidden'));
        
        // 가구 드래그 활성화
        document.querySelectorAll('.placed-furniture').forEach(el => {
            el.style.cursor = 'grab';
            el.style.pointerEvents = 'auto';
        });
        
        // 안내 메시지 수정 (회수하면 보관함으로 간다는 내용 추가)
        showMessage('가구를 드래그하여 이동하거나, 우클릭하여 보관함에 넣으세요.', 'text-yellow-300', messageArea);

    } else {
        // [OFF] 배치 모드 꺼짐
        btn.textContent = '🔨 배치 모드';
        btn.classList.remove('bg-green-600', 'hover:bg-green-700');
        btn.classList.add('bg-blue-500', 'hover:bg-blue-600');
        
        container.classList.remove('border-yellow-400');
        
        // ✨ [추가] 보관함 버튼 숨기기
        if(storageBtn) storageBtn.classList.add('hidden');

        // 캐릭터 보이기
        document.querySelectorAll('.chibi-character').forEach(el => el.classList.remove('hidden'));
        
        document.querySelectorAll('.placed-furniture').forEach(el => {
            el.style.cursor = 'default';
        });

        saveGame();
        showMessage('배치가 저장되었습니다.', 'text-green-300', messageArea);
    }
}

		


    

// ================== 🔨 배치 모드 로직 끝 ==================
// ================== ✨ 마이룸 로직 끝 ✨ ==================

           // ✅ [최종 수정] 편찬(덱 관리) 화면 표시 함수 (안전장치 강화판)
            function displayDeckManagement() {
                // 1. 덱 상태 텍스트 업데이트
                deckStatus.textContent = `현재 편찬: ${playerDeck.length} / ${DECK_CAPACITY}`;
                if (playerDeck.length === DECK_CAPACITY) {
                    deckStatus.classList.remove('text-yellow-300');
                    deckStatus.classList.add('text-green-400');
                } else {
                    deckStatus.classList.add('text-yellow-300');
                    deckStatus.classList.remove('text-green-400');
                }
                
                // 2. [위쪽] 덱 슬롯 표시 (여기가 오류의 원인이었습니다)
                deckSlotsContainer.innerHTML = '';
                
                // 덱 데이터 청소 (데이터 없는 카드는 덱에서 자동 제외하기 위함)
                const validDeck = [];

                for (let i = 0; i < DECK_CAPACITY; i++) {
                    if (playerDeck[i]) {
                        const baseCharacter = findCharacter(playerDeck[i].name);
                        
                        // ✨ [안전장치 1] 데이터가 존재하는 카드만 그림
                        if (baseCharacter) {
                            deckSlotsContainer.appendChild(createCard(baseCharacter, { mode: 'deckSlot', instance: playerDeck[i] }));
                            validDeck.push(playerDeck[i]); // 유효한 카드만 임시 배열에 저장
                        } else {
                            // 데이터가 없으면 '오류 카드'로 표시하고 덱에서는 제외됨
                            console.warn(`덱에 유효하지 않은 카드가 있습니다: ${playerDeck[i].name}`);
                            const errorSlot = document.createElement('div');
                            errorSlot.className = 'deck-slot rounded-lg border-red-500 text-red-400 flex flex-col items-center justify-center text-xs'; 
                            errorSlot.innerHTML = `<p>데이터 없음</p><button onclick="location.reload()" class="mt-1 underline">새로고침</button>`;
                            deckSlotsContainer.appendChild(errorSlot);
                        }
                    } else {
                        // 빈 슬롯
                        const emptySlot = document.createElement('div');
                        emptySlot.className = 'deck-slot rounded-lg'; 
                        emptySlot.textContent = '비어있음';
                        deckSlotsContainer.appendChild(emptySlot);
                    }
                }

                // 덱 데이터 동기화 (오류 카드가 있었다면 제거된 상태로 저장)
                if (validDeck.length !== playerDeck.length) {
                    playerDeck = validDeck;
                    saveGame(); // 자동 수정된 덱 저장
                }

                // 3. [아래쪽] 인벤토리 리스트 표시
                deckInventoryContainer.innerHTML = '';
                if (playerInventory.length === 0) {
                    deckInventoryContainer.innerHTML = `<p class="col-span-full text-center text-gray-400 mt-10">편찬할 등장인물이 없습니다.</p>`;
                } else {
                    // 정렬: 덱 포함 > 등급 > 레벨 > 이름
                    const rarityOrder = { 'SSR': 4, 'SR': 3, 'R': 2, 'N': 1 };
                    const sortedInventory = [...playerInventory].sort((a, b) => {
                        const charA = findCharacter(a.name);
                        const charB = findCharacter(b.name);
                        
                        if (!charA) return 1; 
                        if (!charB) return -1;

                        const inDeckA = playerDeck.some(d => d.id === a.id) ? 1 : 0;
                        const inDeckB = playerDeck.some(d => d.id === b.id) ? 1 : 0;
                        
                        return (inDeckB - inDeckA) || 
                               (rarityOrder[charB.rarity] - rarityOrder[charA.rarity]) || 
                               (b.level - a.level) || 
                               charA.baseName.localeCompare(charB.baseName);
                    });

                    sortedInventory.forEach((cardInstance, index) => {
                        const baseCharacter = findCharacter(cardInstance.name);
                        
                        // ✨ [안전장치 2] 인벤토리에도 데이터 없는 카드는 건너뜀
                        if (!baseCharacter) return; 

                        const isCardInDeck = playerDeck.some(deckCard => deckCard.id === cardInstance.id);
                        const isDeckFull = playerDeck.length >= DECK_CAPACITY;
                        
                        deckInventoryContainer.appendChild(createCard(baseCharacter, {
                            animationIndex: index,
                            mode: 'deckBuilder',
                            instance: cardInstance,
                            isCardInDeck: isCardInDeck,
                            isDeckFull: isDeckFull
                        }));
                    });
                }
                displaySynergies();
            }

            
           // ✅ [수정됨] 자동 편성 함수 (안전장치 추가)
            function autoFillDeck() {
                // 1. 인벤토리의 모든 카드에 대해 전투력 계산
                const inventoryWithPower = playerInventory.map(cardInstance => {
                    // 카드의 현재 스탯(퇴고/개정 적용)을 가져옴
                    const enhancedStats = getEnhancedStats(cardInstance);

                    // ✨ [핵심 수정] 데이터가 유실된 카드는 stats가 null로 반환됨
                    // 이때 atk를 읽으려 하면 에러가 나므로, 안전하게 전투력을 0(또는 -1)으로 처리
                    if (!enhancedStats) {
                        return { instance: cardInstance, power: -1 }; 
                    }

                    // 정상적인 카드라면 전투력 계산 (공 + 방 + 체력/10)
                    const power = enhancedStats.atk + enhancedStats.def + Math.floor(enhancedStats.hp / 10);
                    return { instance: cardInstance, power: power };
                });

                // 2. 전투력 높은 순으로 정렬 (오류 카드는 power가 -1이므로 맨 뒤로 감)
                inventoryWithPower.sort((a, b) => b.power - a.power);
                
                // 3. 상위 5장 선택 (단, 전투력이 0보다 큰 '정상 카드'만 선택)
                const validCards = inventoryWithPower.filter(item => item.power > 0);
                
                playerDeck = validCards.slice(0, DECK_CAPACITY).map(item => item.instance);

                // 4. 화면 갱신 및 저장
                displayDeckManagement();
                showMessage('가장 강력한 등장인물로 덱을 자동 편성했습니다!', 'text-blue-300', messageArea);
                saveGame();
            }

            function addToDeck(cardId) {
                if (playerDeck.length >= DECK_CAPACITY) return;
                
                const cardInstanceToAdd = playerInventory.find(c => c.id === cardId);
                if (!cardInstanceToAdd) return;

                // 이제 동일 인물이 아닌, '이미 덱에 들어간 카드인지'만 확인합니다.
                if (playerDeck.some(deckCard => deckCard.id === cardInstanceToAdd.id)) {
                     showMessage('이미 편찬된 카드입니다.', 'text-yellow-400', messageArea);
                    return;
                }

                playerDeck.push(cardInstanceToAdd);
                displayDeckManagement();
                saveGame();
            }
            
            function removeFromDeck(cardId) {
                const indexToRemove = playerDeck.findIndex(card => card.id === cardId);
                if(indexToRemove > -1) {
                    playerDeck.splice(indexToRemove, 1);
                }
                displayDeckManagement();
                saveGame();
            }
            
				// 위치: gacha1.html, 약 1129번째 줄
			function calculateDeckPower() {
    if (playerDeck.length === 0) return 0;
    
    // 덱에 있는 각 카드의 퇴고된 스탯을 기준으로 전투력을 합산합니다.
    // (표시되는 전투력에는 인연 보너스가 포함되지 않지만, 실제 전투에서는 정상 적용됩니다.)
    return playerDeck.reduce((total, cardInstance) => {
        const enhancedStats = getEnhancedStats(cardInstance);
        if (enhancedStats) {
            return total + (enhancedStats.atk + enhancedStats.def + Math.floor(enhancedStats.hp / 10));
        }
        return total;
    }, 0);
}

            // ✅ 이 코드로 기존 displayCombatView 함수를 통째로 교체해주세요.
            function displayCombatView() {
                deckPowerDisplay.textContent = calculateDeckPower();
                const chapterContainer = document.getElementById('chapter-list-container');
                chapterContainer.innerHTML = '';

                mainChapters.forEach((chapter, index) => {
                    // ✨ 챕터 잠금 해제 조건 로직 시작 ✨
                    let isChapterUnlocked = false;
                    if (index === 0) {
                        isChapterUnlocked = true; // 1장은 항상 열려있음
                    } else {
                        // 이전 챕터의 마지막 스테이지 ID를 만듭니다. (예: 2장의 조건 -> 1-10)
                        const prevChapter = mainChapters[index - 1];
                        const lastStageIdOfPrevChapter = `${index}-${prevChapter.stages.length}`;
                        isChapterUnlocked = clearedStages.includes(lastStageIdOfPrevChapter);
                    }
                    // ✨ 챕터 잠금 해제 조건 로직 끝 ✨

                    const chapterEl = document.createElement('button');
                    chapterEl.className = `w-full gacha-button text-white font-bold py-3 px-4 rounded-lg text-left ${isChapterUnlocked ? 'bg-black/20 hover:bg-black/40' : 'bg-black/40 text-gray-500 cursor-not-allowed'}`;
                    chapterEl.disabled = !isChapterUnlocked;
                    
                    if (isChapterUnlocked) {
                        chapterEl.dataset.action = 'select-chapter';
                        chapterEl.dataset.chapterIndex = index;
                        chapterEl.textContent = chapter.chapterName;
                    } else {
                        chapterEl.textContent = `${chapter.chapterName} (제${index}장 클리어 시 해금)`;
                    }
                    
                    chapterContainer.appendChild(chapterEl);
                });

                // 기본적으로 첫 번째 챕터의 스테이지를 표시
                displayStages(0);
            }
            
			// ✅ displayCombatView 함수 바로 다음에 이 새로운 함수를 추가해주세요.
            function displayStages(chapterIndex) {
                const stageContainer = document.getElementById('stage-list-container');
                stageContainer.innerHTML = ''; // 초기화
                
                // 선택된 챕터 버튼 활성화 스타일 적용
                document.querySelectorAll('#chapter-list-container button').forEach((btn, idx) => {
                    btn.classList.toggle('bg-blue-500', idx === chapterIndex);
                });

                const chapter = mainChapters[chapterIndex];
                if (!chapter) return;

                chapter.stages.forEach((stage, stageIndex) => {
                    const stageId = `${chapterIndex + 1}-${stageIndex + 1}`;
                    const isCleared = clearedStages.includes(stageId);
                    
                    // 스테이지 잠금 해제 조건: 첫 스테이지이거나, 이전 스테이지를 클리어했거나
                    const isUnlocked = stageIndex === 0 || clearedStages.includes(`${chapterIndex + 1}-${stageIndex}`);

                    const stageEl = document.createElement('button');
                    stageEl.className = `p-3 rounded-lg text-center transition-transform duration-200 ${isUnlocked ? 'bg-white/20 hover:scale-105 cursor-pointer' : 'bg-black/30 text-gray-500 cursor-not-allowed'}`;
                    stageEl.disabled = !isUnlocked;
                    
                    stageEl.innerHTML = `
                        <p class="font-bold">${stage.stageName}</p>
                        <p class="text-xs">${isCleared ? '✔️' : '⚔️'}</p>
                    `;

                    if(isUnlocked) {
                        stageEl.dataset.action = 'challenge-stage';
                        stageEl.dataset.chapterIndex = chapterIndex;
                        stageEl.dataset.stageIndex = stageIndex;
                    }
                    stageContainer.appendChild(stageEl);
                });
            }
			
            // ✅ 기존 challengeDungeon 함수를 아래 코드로 교체해주세요. (이벤트 던전 로직은 유지됩니다)
            function challengeDungeon(dungeonIndex, type = 'main') {
                if (playerBookmarks < 1) {
                    const msgArea = type === 'event' ? messageArea : (document.getElementById('combat-message-area') || messageArea);
                    showMessage('책갈피가 부족합니다!', 'text-yellow-400', msgArea);
                    return;
                }
                if (playerDeck.length < DECK_CAPACITY) {
                    const msgArea = type === 'event' ? messageArea : (document.getElementById('combat-message-area') || messageArea);
                    showMessage('덱을 5장으로 모두 채워야 합니다!', 'text-yellow-400', msgArea);
                    return;
                }
                
                playerBookmarks--;
                if (playerBookmarks === MAX_BOOKMARKS - 1) {
                     lastBookmarkUpdateTime = Date.now();
                }
                updateUI();
                
                // 이벤트 던전은 기존 로직을 그대로 사용합니다.
                if (type === 'event') {
                    startCombat(dungeonIndex, type);
                }
                // 'main' 타입은 이제 사용되지 않습니다. challengeStage를 통해 호출됩니다.
            }
			
			// 방문 중인 친구의 UID를 저장 (내 방이면 null)
let currentVisitTargetUid = null;
// 오늘 해당 친구에게 페이버를 했는지 여부 (캐싱)
let hasDoneFavorToday = false;
            
            // gacha3.html - challengeStage 함수 (기존 함수 전체 교체)

function challengeStage(chapterIndex, stageIndex) {
    // **참고:** 책갈피 부족 체크는 startStageCombat에서 한 번 더 하지만, 
    // 여기서는 덱 용량 체크만 남깁니다.
    
    if (playerDeck.length < DECK_CAPACITY) {
        showMessage('덱을 5장으로 모두 채워야 합니다!', 'text-yellow-400', messageArea);
        return;
    }
    
    // 책갈피가 1개라도 없으면 여기서 리턴됩니다.
    if (playerBookmarks < 1) {
        showMessage('책갈피가 부족합니다!', 'text-yellow-400', messageArea);
        return;
    }

    const stage = mainChapters[chapterIndex].stages[stageIndex];
    const stageId = `${chapterIndex + 1}-${stageIndex + 1}`;

    // 1. 스테이지 스토리가 있고, 아직 열람하지 않은 경우
    if (stage.stageStory && !clearedStageStories.includes(stageId)) {
        const storyToStart = { content: stage.stageStory }; 
        
        // 스토리 완료 시 책갈피 소모 및 전투 시작을 위한 콜백 설정
        // startStageCombat 함수는 내부적으로 책갈피를 소모합니다.
        document.getElementById('interactive-story-modal').dataset.callback = `startStageCombat(${chapterIndex}, ${stageIndex})`;
        
        startInteractiveStory(storyToStart);
        
        // 스토리 열람 상태를 저장 (책갈피는 스토리 완료 후 소모)
        clearedStageStories.push(stageId);
        saveGame(); 
        
    } else {
        // 2. 스토리가 없거나 이미 열람한 경우, 바로 책갈피를 소모하고 전투 시작
        startStageCombat(chapterIndex, stageIndex);
    }
}

            function setCombatSpeed(speed) {
                combatSpeedMultiplier = speed;
                const allSpeedButtons = document.querySelectorAll('.speed-button');
                allSpeedButtons.forEach(btn => {
                    btn.classList.remove('active');
                    btn.classList.add('bg-gray-600');
                    btn.classList.remove('bg-blue-500');
                });
                document.getElementById(`speed-${speed}x`).classList.add('active', 'bg-blue-500');
                document.getElementById(`speed-${speed}x`).classList.remove('bg-gray-600');
            }

			// 책갈피를 소모하고 실제 전투를 시작하는 헬퍼 함수
function startStageCombat(chapterIndex, stageIndex) {
    // 1. 책갈피 소모 로직 (소모되지 않았을 경우에만 실행)
    if (playerBookmarks < 1) {
        showMessage('책갈피가 부족합니다!', 'text-yellow-400', messageArea);
        return;
    }
    
    playerBookmarks--;
    if (playerBookmarks === MAX_BOOKMARKS - 1) {
        lastBookmarkUpdateTime = Date.now();
    }
    updateUI();

    // 2. 전투 시작
    startCombat({ chapter: chapterIndex, stage: stageIndex }, 'main_stage');
}

				// ✅ [수정됨] startCombat 함수: 화면 레이아웃 변경 및 효과 시스템 초기화
async function startCombat(indices, type) {
    isCombatRunning = true;
    setCombatSpeed(1);

    let monsterData;

    // ▼▼▼ 몬스터 데이터 설정 (레이드 포함) ▼▼▼
    if (type === 'raid') {
        monsterData = JSON.parse(JSON.stringify({
            name: raidBossData.name,
            stats: { 
                hp: raidBossData.currentHp, 
                atk: raidBossData.atk, 
                def: raidBossData.def 
            },
            imageUrl: raidBossData.imageUrl,
            isAoE: true 
        }));
    } else if (type === 'main_stage') {
        const combatData = mainChapters[indices.chapter].stages[indices.stage];
        monsterData = JSON.parse(JSON.stringify(monsters[combatData.monsterName]));
    } else if (type === 'event') {
        const combatData = eventDungeons[indices];
        monsterData = JSON.parse(JSON.stringify(monsters[combatData.monsterName]));
    }
    // ▲▲▲ 몬스터 데이터 설정 끝 ▲▲▲
    
    window.currentCombatIndices = indices;
    window.currentCombatType = type;

    // 1. 퇴고/개정 레벨 적용
    let combatDeck = playerDeck.map(cardInstance => {
        const baseCard = findCharacter(cardInstance.name);
        const enhancedStats = getEnhancedStats(cardInstance);
        
        // ✨ [추가] 유전된 스킬이 있으면 그것을 사용
        let activeSkills = baseCard.skills;
        if (cardInstance.inherited && cardInstance.inherited.skills) {
            activeSkills = cardInstance.inherited.skills;
        }

        return {
            ...baseCard,
            skills: activeSkills, // 덮어쓰기
            stats: enhancedStats,
            activeEffects: [], 
            cardImageUrl: baseCard.cardImageUrl 
        };
    });

    // 2. 인연 보너스 적용
    combatDeck = applySynergyBonusesToDeck(combatDeck);

    // 3. 최대 HP 저장 (원본 보너스 덱 저장)
    const originalBonusDeck = JSON.parse(JSON.stringify(combatDeck));

    // --- UI 렌더링 (레이아웃 변경) ---
    const combatMonsterImage = document.getElementById('combat-monster-image');
    if (combatMonsterImage) combatMonsterImage.classList.remove('shake-animation');

    // 뷰 전환
    allViews.forEach(view => view.classList.add('hidden'));
    combatInProgressView.classList.remove('hidden');
    combatLog.innerHTML = '';
    
    // 1) 전체 컨테이너 설정
    const container = combatInProgressView.querySelector('.grid');
    if (container) {
        container.className = "flex flex-col md:flex-row gap-2 md:gap-4 items-center justify-center h-full max-h-[550px]"; 
    }

    // 2) 플레이어 덱 영역 (좌측)
    combatPlayerDeck.className = "w-full md:w-1/2 md:max-w-md flex flex-wrap justify-center content-center gap-1.5 md:gap-2 order-2 md:order-1 overflow-hidden p-2"; 
    combatPlayerDeck.innerHTML = '';

    // 3) 몬스터 영역 (우측)
    combatMonsterArea.className = "w-full md:w-1/2 flex flex-col items-center justify-center bg-black/40 rounded-xl p-4 order-1 md:order-2 border border-white/10 min-h-[180px]";
    
    // 플레이어 덱 UI 그리기
    combatDeck.forEach((card, index) => {
        const cardEl = document.createElement('div');
        
        // ✨ 등급별 글로우 클래스 이름 생성 (예: rarity-glow-SSR)
        const glowClass = `rarity-glow-${card.rarity}`;

        cardEl.className = 'relative w-[28%] bg-gray-800 p-0.5 rounded-lg border border-gray-600 shadow-md flex flex-col items-center transition-transform hover:scale-105 hover:z-10';
        cardEl.id = `combat-card-${index}`;

        const rarityColor = { 'N': 'text-gray-400', 'R': 'text-blue-400', 'SR': 'text-purple-400', 'SSR': 'text-yellow-400' }[card.rarity];

        cardEl.innerHTML = `
            <div class="relative w-full aspect-[2/3] overflow-hidden rounded mb-0.5">
                <img src="${card.cardImageUrl}" class="w-full h-full object-cover opacity-90 ${glowClass}">
                <div id="effect-icons-${index}" class="absolute top-0.5 right-0.5 flex flex-col gap-0.5 items-end transform scale-75 origin-top-right"></div> 
            </div>
            
            <p class="font-bold text-[8px] md:text-[10px] truncate w-full text-center ${rarityColor} mb-0.5">${card.name}</p>
            
            <div class="w-full hp-bar-background rounded-full h-1 md:h-1.5 bg-gray-600">
                <div id="player-hp-bar-${index}" class="hp-bar-foreground h-1 md:h-1.5 rounded-full transition-all duration-300" style="width: 100%"></div>
            </div>
            <p id="player-hp-text-${index}" class="text-[8px] text-center text-gray-400 mt-0.5 leading-none transform scale-90">${card.stats.hp}</p>
        `;
        combatPlayerDeck.appendChild(cardEl);
    });

    // 몬스터 UI 그리기
    combatMonsterArea.innerHTML = `
        <h3 class="text-lg md:text-3xl font-bold text-red-500 drop-shadow-md mb-2 md:mb-4 text-center truncate w-full px-2">${monsterData.name}</h3>
        
        <div class="relative w-full flex justify-center items-center flex-grow mb-2 md:mb-4">
             <img id="combat-monster-image" src="${monsterData.imageUrl}" alt="${monsterData.name}" class="h-24 md:h-56 object-contain drop-shadow-2xl transition-transform">
             <div id="monster-effect-icons" class="absolute top-0 right-2 md:right-4 flex flex-col gap-1"></div> 
        </div>
        
        <div class="w-full max-w-[180px] md:max-w-sm hp-bar-background rounded-full h-3 md:h-5 border border-gray-500 shadow-inner relative overflow-hidden">
            <div id="monster-hp-bar" class="hp-bar-foreground h-full bg-gradient-to-r from-red-600 to-red-400 transition-all duration-300" style="width: 100%"></div>
            <p id="monster-hp-text" class="absolute inset-0 flex items-center justify-center text-[9px] md:text-xs font-bold text-white drop-shadow-md">${monsterData.stats.hp} / ${monsterData.stats.hp}</p>
        </div>
    `;
    
    monsterData.activeEffects = [];

    // 4. 전투 루프 실행
    await runCombatLoop(combatDeck, originalBonusDeck, monsterData, indices, type); 
}

            
            

            const delay = ms => new Promise(res => setTimeout(res, ms / combatSpeedMultiplier));

            // ✅ [수정됨] runCombatLoop: 5턴 지속 효과 및 턴 관리 로직 적용
async function runCombatLoop(combatDeck, originalBonusDeck, monsterData, indices, type) { 
    const originalMonsterDef = monsterData.stats.def; // 몬스터 기본 방어력 백업
    const originalMonsterAtk = monsterData.stats.atk; // 몬스터 기본 공격력 백업
    let totalDamageDealt = 0; 

    while (monsterData.stats.hp > 0 && combatDeck.some(c => c.stats.hp > 0)) {
        if (!isCombatRunning) return;

        // ===============================================
        // 1. 플레이어 턴
        // ===============================================
        for (let i = 0; i < combatDeck.length; i++) {
            if (!isCombatRunning) return;

            const card = combatDeck[i];
            
            // ✨ [신규] 턴 시작 시 지속 효과 체크 (플레이어)
            if (card.stats.hp > 0 && card.activeEffects) {
                // 효과 지속시간 감소 및 만료 처리
                for (let j = card.activeEffects.length - 1; j >= 0; j--) {
                    card.activeEffects[j].turns--;
                    if (card.activeEffects[j].turns <= 0) {
                        // 효과 만료: 스탯 원복
                        const effect = card.activeEffects[j];
                        if (effect.type === 'buff_atk') {
                            // 단순 나눗셈으로 복구 (부동소수점 오차 있을 수 있으나 게임 규모상 허용)
                            card.stats.atk = Math.floor(card.stats.atk / effect.value);
                            logCombat(`<span class="text-gray-400">${card.name}의 공격력 증가 효과가 끝났습니다.</span>`);
                        }
                        // 배열에서 제거
                        card.activeEffects.splice(j, 1);
                    }
                }
                updateCombatUI(combatDeck, originalBonusDeck, monsterData); // 아이콘 갱신
            }

            if (card.stats.hp > 0) {
                // 턴 대기 (카드 활성화 시각효과)
                const cardEl = document.getElementById(`combat-card-${i}`);
                if (cardEl) {
                    cardEl.classList.add('ring-4', 'ring-yellow-400', 'scale-105', 'z-10');
                    await delay(600);
                    cardEl.classList.remove('ring-4', 'ring-yellow-400', 'scale-105', 'z-10');
                } else {
                    await delay(600);
                }
                
                if (!isCombatRunning) return;

                const monsterImage = document.getElementById('combat-monster-image');
                
                // 스킬 사용 여부 결정
                const useUltimate = card.rarity === 'SSR' && Math.random() < 0.25;
                const useSkill = Math.random() < 0.4;
                let skillToUse = null;

                if (useUltimate && card.skills.length > 1) skillToUse = card.skills[1];
                else if (useSkill) skillToUse = card.skills[0];

                let damage = 0;

                if (skillToUse) {
                    logCombat(`<strong>${card.name}</strong>의 스킬! <span class="text-yellow-300">"${skillToUse.name}"</span>`);
                    await delay(400);
                    if (!isCombatRunning) return; 

                    logCombat(`<em>"${skillToUse.dialogue}"</em>`);
                    
                    // --- 스킬 효과 계산 ---
                    if (skillToUse.type === 'true_damage') {
                        damage = Math.floor(card.stats.atk * skillToUse.power);
                        logCombat(`방어력을 무시한 강력한 일격!`);
                    } else if (skillToUse.type === 'heal') {
                        damage = 0;
                        const healAmount = Math.floor(card.stats.atk * skillToUse.power);
                        const maxHp = originalBonusDeck[i].stats.hp;
                        card.stats.hp = Math.min(maxHp, card.stats.hp + healAmount);
                        logCombat(`<strong>${card.name}</strong>이(가) 체력을 ${healAmount} 회복했습니다!`);
                        
                    } else if (skillToUse.type === 'vampire') {
                        damage = Math.max(1, Math.floor(card.stats.atk * skillToUse.power) - monsterData.stats.def);
                        const healedAmount = Math.floor(damage * 0.5);
                        const maxHp = originalBonusDeck[i].stats.hp;
                        card.stats.hp = Math.min(maxHp, card.stats.hp + healedAmount);
                        logCombat(`<strong>${card.name}</strong>이(가) ${healedAmount}의 체력을 흡수했습니다!`);
                        
                    } else if (skillToUse.type === 'debuff_def') {
                        // ✨ [수정] 방어력 감소 (5턴 지속)
                        // 몬스터에게 효과 적용
                        monsterData.stats.def = Math.max(0, Math.floor(monsterData.stats.def * 0.8));
                        monsterData.activeEffects.push({ type: 'debuff_def', turns: 5, value: 0.8, name: '방어력↓' });
                        logCombat(`<strong>${monsterData.name}</strong>의 방어력이 감소했습니다! (5턴)`);
                        
                    } else if (skillToUse.type === 'debuff_atk') {
                        // ✨ [수정] 공격력 감소 (5턴 지속)
                        monsterData.stats.atk = Math.max(0, Math.floor(monsterData.stats.atk * 0.9));
                        monsterData.activeEffects.push({ type: 'debuff_atk', turns: 5, value: 0.9, name: '공격력↓' });
                        logCombat(`<strong>${monsterData.name}</strong>의 공격력이 감소했습니다! (5턴)`);
                        
                    } else if (skillToUse.type === 'buff_atk') {
                        // ✨ [수정] 공격력 증가 (5턴 지속)
                        const multiplier = 1.1; // 10% 증가
                        card.stats.atk = Math.floor(card.stats.atk * multiplier);
                        card.activeEffects.push({ type: 'buff_atk', turns: 5, value: multiplier, name: '공격력↑' });
                        logCombat(`<strong>${card.name}</strong>의 공격력이 상승했습니다! (5턴)`);
                        
                    } else {
                        // 일반 데미지 스킬
                        damage = Math.max(1, Math.floor(card.stats.atk * skillToUse.power) - monsterData.stats.def);
                    }

                } else {
                    logCombat(`<strong>${card.name}</strong>의 일반 공격!`);
                    damage = Math.max(1, card.stats.atk - monsterData.stats.def);
                }
                
                if (damage > 0) {
                    monsterData.stats.hp = Math.max(0, monsterData.stats.hp - damage);
                    totalDamageDealt += damage;
                    logCombat(`<strong>${monsterData.name}</strong>에게 ${damage}의 데미지!`);
                    
                    if (monsterImage) {
                        monsterImage.classList.add('shake-animation');
                        setTimeout(() => monsterImage.classList.remove('shake-animation'), 300 / combatSpeedMultiplier);
                    }
                    updateCombatUI(combatDeck, originalBonusDeck, monsterData);
                }

                if (monsterData.stats.hp <= 0) break;
            }
        } 

        if (monsterData.stats.hp <= 0) break;

        // ===============================================
        // 2. 몬스터 턴
        // ===============================================
        await delay(1000);
        if (!isCombatRunning) return;

        // ✨ [신규] 몬스터 턴 시작 시 지속 효과 체크
        if (monsterData.activeEffects) {
             for (let j = monsterData.activeEffects.length - 1; j >= 0; j--) {
                monsterData.activeEffects[j].turns--;
                if (monsterData.activeEffects[j].turns <= 0) {
                    const effect = monsterData.activeEffects[j];
                    if (effect.type === 'debuff_def') {
                        monsterData.stats.def = originalMonsterDef; // 원상복구 (단순화: 기본값으로 리셋)
                        logCombat(`<span class="text-gray-400">${monsterData.name}의 방어력 감소 효과가 끝났습니다.</span>`);
                    } else if (effect.type === 'debuff_atk') {
                        monsterData.stats.atk = originalMonsterAtk;
                         logCombat(`<span class="text-gray-400">${monsterData.name}의 공격력 감소 효과가 끝났습니다.</span>`);
                    }
                    monsterData.activeEffects.splice(j, 1);
                }
            }
            updateCombatUI(combatDeck, originalBonusDeck, monsterData);
        }

        const alivePlayers = combatDeck.filter(c => c.stats.hp > 0);
        
        if (alivePlayers.length > 0) {
            if (monsterData.isAoE) {
                logCombat(`<strong>${monsterData.name}</strong>의 <span class="text-red-400 font-bold">광역 공격!</span>`);
                for (const targetCard of alivePlayers) {
                    const damage = Math.max(1, monsterData.stats.atk - targetCard.stats.def);
                    const hpBeforeAttack = targetCard.stats.hp;
                    targetCard.stats.hp = Math.max(0, targetCard.stats.hp - damage);
                    logCombat(`- <strong>${targetCard.name}</strong>에게 ${damage}의 데미지!`);
                    
                    if (targetCard.stats.hp <= 0 && hpBeforeAttack > 0) {
                        await delay(200);
                        if (!isCombatRunning) return;
                        if (targetCard.deathDialogue) logCombat(`<strong>${targetCard.name}</strong>: <em>"${targetCard.deathDialogue}"</em>`);
                        
                        // 카드 사망 처리 (흑백)
                        const deadCardEl = document.getElementById(`combat-card-${combatDeck.indexOf(targetCard)}`);
                        if(deadCardEl) deadCardEl.classList.add('grayscale', 'opacity-50');
                    }
                }
            } else {
                const targetCard = alivePlayers[Math.floor(Math.random() * alivePlayers.length)];
                logCombat(`<strong>${monsterData.name}</strong>의 공격!`);
                const damage = Math.max(1, monsterData.stats.atk - targetCard.stats.def);
                const hpBeforeAttack = targetCard.stats.hp;
                targetCard.stats.hp = Math.max(0, targetCard.stats.hp - damage);
                logCombat(`<strong>${targetCard.name}</strong>에게 ${damage}의 데미지!`);
                
                if (targetCard.stats.hp <= 0 && hpBeforeAttack > 0) {
                    await delay(400);
                    if (!isCombatRunning) return; 
                    if (targetCard.deathDialogue) logCombat(`<strong>${targetCard.name}</strong>: <em>"${targetCard.deathDialogue}"</em>`);
                    
                    const deadCardEl = document.getElementById(`combat-card-${combatDeck.indexOf(targetCard)}`);
                    if(deadCardEl) deadCardEl.classList.add('grayscale', 'opacity-50');
                }
            }
            updateCombatUI(combatDeck, originalBonusDeck, monsterData);
        }
    } // while 루프 종료
    
    await delay(1000);
    if (!isCombatRunning) return;

    // 전투 종료 시 임시 스탯 복구 (안전장치)
    monsterData.stats.def = originalMonsterDef; 
    
    if (isCombatRunning) {
        endCombat(monsterData.stats.hp <= 0, {indices: indices, type: type}, totalDamageDealt);
    }
}

            function logCombat(message) {
                combatLog.innerHTML += `<p>${message}</p>`;
                combatLogContainer.scrollTop = combatLogContainer.scrollHeight;
            }
			
			// ✨ [수정된 registerUser 함수]
        async function registerUser() {
            const email = document.getElementById('email-input').value;
            const password = document.getElementById('password-input').value;
            // ✨ 1. 닉네임 입력값 가져오기
            const nicknameInput = document.getElementById('nickname-input').value.trim();

            if (!nicknameInput) {
                return alert("닉네임을 입력해주세요!");
            }

            try {
                const userCredential = await auth.createUserWithEmailAndPassword(email, password);
                const newUser = userCredential.user;
                
                // ✨ 2. Firebase 프로필에 닉네임 설정
                await newUser.updateProfile({ displayName: nicknameInput });
                
                alert('회원가입 성공! 자동으로 로그인됩니다.');

                const localDataString = localStorage.getItem(SAVE_DATA_KEY);
                if (localDataString) {
                    // (기존 데이터 마이그레이션 로직 유지)
                    console.log('기존 로컬 데이터를 Firebase로 마이그레이션합니다.');
                    const localData = JSON.parse(localDataString);
                    // 마이그레이션 시에도 닉네임 저장
                    localData.nickname = nicknameInput; 
                    await db.collection('users').doc(newUser.uid).set(localData);
                    localStorage.removeItem(SAVE_DATA_KEY);
                } else {
                    // (신규 유저 로직)
                    initializeNewGameData();
                    
                    // ✨ 3. 전역 변수에 닉네임 저장 후 DB 저장
                    currentPlayerNickname = nicknameInput;
                    await saveGameToFirebase(); 
                }
            } catch (error) {
                alert(`회원가입 실패: ${error.message}`);
            }
        }

        // ✨ 로그인 함수 ✨
        async function loginUser() {
            const email = document.getElementById('email-input').value;
            const password = document.getElementById('password-input').value;
            try {
                await auth.signInWithEmailAndPassword(email, password);
            } catch (error) {
                alert(`로그인 실패: ${error.message}`);
            }
        }

        // ✨ 로그아웃 함수 ✨
        async function logoutUser() {
            try {
                await auth.signOut();
                alert('로그아웃 되었습니다.');
                location.reload();
            } catch (error) {
                alert(`로그아웃 실패: ${error.message}`);
            }
        }


			function renderEventStoryList() {
    const eventStoryContainer = document.getElementById('eventStoryContainer');
    eventStoryContainer.innerHTML = '';
    
    // 1번에서 정의한 eventStories 배열을 사용합니다.
    eventStories.forEach((story, index) => {
        const storyEl = document.createElement('div');
        storyEl.className = 'p-3 bg-white/10 rounded-lg shadow-md mb-2 cursor-pointer transition-transform hover:scale-[1.01]';
        
        // ⭐ 이 두 가지 data- 속성이 중요합니다!
        storyEl.dataset.storyIndex = index;
        storyEl.dataset.storyType = 'event'; // ✅ 이 속성이 'event'여야 합니다.
        
        storyEl.innerHTML = `
            <div class="text-lg font-bold text-white">${story.title}</div>
            <div class="text-sm text-gray-300">획득 보상: 북마크 10개</div>
        `;

        if (story.isLocked) {
             storyEl.classList.add('opacity-50', 'cursor-default');
             storyEl.innerHTML = `<div class="text-lg font-bold text-gray-500">스토리 잠금</div><div class="text-sm text-gray-500">이벤트 진행을 통해 해제 가능</div>`;
             storyEl.dataset.storyType = 'locked'; // 잠긴 스토리는 다른 타입으로 설정하여 클릭 방지
        }
        
        eventStoryContainer.appendChild(storyEl);
    });
}

             // ✅ [수정됨] updateCombatUI: HP바 및 상태 아이콘(버프/디버프) 표시
function updateCombatUI(deck, originalBonusDeck, monster) {
    // 1. 플레이어 덱 업데이트
    deck.forEach((card, index) => {
        const originalCardWithBonus = originalBonusDeck[index];
        if(!originalCardWithBonus || !originalCardWithBonus.stats) return; 

        const maxHp = originalCardWithBonus.stats.hp;
        const currentHp = card.stats.hp;
        const hpPercent = maxHp > 0 ? (currentHp / maxHp) * 100 : 0;
        
        // HP 바 업데이트
        const hpBarEl = document.getElementById(`player-hp-bar-${index}`);
        const hpTextEl = document.getElementById(`player-hp-text-${index}`);
        if (hpBarEl) hpBarEl.style.width = `${hpPercent}%`;
        if (hpTextEl) hpTextEl.textContent = `${currentHp} / ${maxHp}`;

        // ✨ [신규] 플레이어 상태 아이콘 렌더링
        const iconContainer = document.getElementById(`effect-icons-${index}`);
        if (iconContainer) {
            iconContainer.innerHTML = '';
            if (card.activeEffects) {
                card.activeEffects.forEach(effect => {
                    const icon = document.createElement('div');
                    // 효과별 아이콘 및 색상 설정
                    let iconChar = '⚡';
                    let bgClass = 'bg-gray-600';
                    
                    if (effect.type === 'buff_atk') { iconChar = '⚔️↑'; bgClass = 'bg-red-600'; }
                    else if (effect.type === 'buff_def') { iconChar = '🛡️↑'; bgClass = 'bg-blue-600'; }
                    
                    icon.className = `${bgClass} text-white text-[10px] px-1 rounded shadow animate-pulse font-bold`;
                    icon.innerHTML = `${iconChar} <span class="text-[9px]">${effect.turns}턴</span>`;
                    iconContainer.appendChild(icon);
                });
            }
        }
    });

    // 2. 몬스터 HP 업데이트
    let monsterMaxHp;
    if (typeof raidBossDataSheet !== 'undefined' && monster.name === raidBossDataSheet.name) {
        monsterMaxHp = raidBossDataSheet.maxHp;
    } else {
        monsterMaxHp = monsters[monster.name]?.stats.hp;
    }

    if (monsterMaxHp) {
        const monsterHpPercent = (monster.stats.hp / monsterMaxHp) * 100;
        const monsterHpBar = document.getElementById('monster-hp-bar');
        const monsterHpText = document.getElementById('monster-hp-text');

        if (monsterHpBar) monsterHpBar.style.width = `${monsterHpPercent}%`;
        if (monsterHpText) monsterHpText.textContent = `${monster.stats.hp} / ${monsterMaxHp}`;
    }

    // ✨ [신규] 몬스터 상태 아이콘 렌더링
    const monsterIconContainer = document.getElementById('monster-effect-icons');
    if (monsterIconContainer) {
        monsterIconContainer.innerHTML = '';
        if (monster.activeEffects) {
            monster.activeEffects.forEach(effect => {
                const icon = document.createElement('div');
                let iconChar = '💀';
                let bgClass = 'bg-gray-600';
                
                if (effect.type === 'debuff_atk') { iconChar = '⚔️↓'; bgClass = 'bg-blue-500'; }
                else if (effect.type === 'debuff_def') { iconChar = '🛡️↓'; bgClass = 'bg-purple-500'; }

                icon.className = `${bgClass} text-white text-xs px-2 py-1 rounded-full shadow border border-white font-bold`;
                icon.innerHTML = `${iconChar} ${effect.turns}턴`;
                monsterIconContainer.appendChild(icon);
            });
        }
    }
}


			// [수정] 현재 진행 중인 이벤트 스토리만 표시하도록 필터링 적용
function displayEventStories() {
    const eventStoryContainer = document.getElementById('event-story-part1-container');
    eventStoryContainer.innerHTML = '';
    
    // 데이터 없음 체크
    if (!eventStories || eventStories.length === 0) {
        eventStoryContainer.innerHTML = `<p class="text-center text-gray-400 mt-10">이벤트 스토리는 현재 준비 중입니다.</p>`;
        return;
    }

    // ✨ 진행 중인 이벤트가 없는 경우 예외 처리
    if (!CURRENT_EVENT_ID) {
        eventStoryContainer.innerHTML = `<p class="text-center text-gray-400 mt-10">현재 진행 중인 이벤트가 없습니다.</p>`;
        return;
    }

    let hasStoryToShow = false;

    // 전체 리스트를 순회하되, ID가 안 맞으면 건너뜀 (Index 유지를 위해 filter 대신 forEach 내부 체크 사용)
    eventStories.forEach((story, index) => {
        // ✨ [핵심] 현재 진행 중인 이벤트의 스토리인지 확인
        // (eventId가 없거나, 현재 이벤트 ID와 다르면 숨김)
        if (!story.eventId || story.eventId !== CURRENT_EVENT_ID) {
            return; 
        }

        hasStoryToShow = true;

        // 해금 조건 확인 (해당 순서의 던전 클리어 여부)
        const dungeonName = eventDungeons[index]?.name;
        const isUnlocked = dungeonName && clearedEventDungeons.includes(dungeonName);
        
        const storyEl = document.createElement('div');
        storyEl.className = `p-4 rounded-lg transition-colors duration-300 ${isUnlocked ? 'bg-white/20 hover:bg-white/30 cursor-pointer' : 'bg-black/30 text-gray-500'}`;
        
        if (isUnlocked) {
            storyEl.dataset.storyIndex = index; // 전체 배열 기준 인덱스 (재생 시 필요)
            storyEl.dataset.storyType = 'event';
        }

        let unlockText = '클릭하여 스토리 읽기';
        if (!isUnlocked) {
            unlockText = `${dungeonName ? dungeonName : (index + 1) + ' 스테이지'} 클리어 시 해금`;
        }

        storyEl.innerHTML = `
            <h3 class="text-xl font-bold ${isUnlocked ? 'text-pink-300' : ''}">[이벤트] ${story.title}</h3>
            <p class="text-sm">${unlockText}</p>
        `;
        eventStoryContainer.appendChild(storyEl);
    });

    // 현재 이벤트 ID에 맞는 스토리가 하나도 없을 때
    if (!hasStoryToShow) {
        eventStoryContainer.innerHTML = `<p class="text-center text-gray-400 mt-10">현재 공개된 스토리가 없습니다.</p>`;
    }
}
			
           // ✅ [최종 수정] endCombat (레이드 종료 시 모달 잔상 해결)
function endCombat(isVictory, combatInfo, totalDamageDealt = 0) { 
    console.log("1. 전투 종료 진입:", combatInfo);

    isCombatRunning = false; 

    // [1] 전투 화면 숨기기
    const combatView = document.getElementById('combat-in-progress-view');
    if (combatView) {
        combatView.classList.add('hidden');
    }

    // [2] 결과창 모달 준비
    const resultModal = document.getElementById('combat-result-modal');
    const resultTitle = document.getElementById('combat-result-title');
    const resultMessage = document.getElementById('combat-result-message');

    if (resultModal) {
        // 일단 모달을 띄움 (강제 표시)
        document.body.appendChild(resultModal); 
        resultModal.classList.remove('hidden');
        resultModal.style.zIndex = '99999'; 
        resultModal.style.display = 'flex'; 
        
        // ✨ [중요] 텍스트 초기화 (이전 전투 메시지가 남지 않게 함)
        if (resultTitle) resultTitle.textContent = "전투 종료 처리 중...";
        if (resultMessage) resultMessage.textContent = "";
    }

    // [3] 레이드 예외 처리 (여기가 문제였습니다)
    if (combatInfo && combatInfo.type === 'raid') {
        if (resultModal) {
            // ✨ [핵심 수정] flex로 강제된 스타일을 none으로 확실하게 덮어써서 끕니다.
            resultModal.style.display = 'none'; 
            resultModal.classList.add('hidden');
        }

        if (typeof submitRaidDamage === 'function') submitRaidDamage(totalDamageDealt);
        
        document.getElementById('event-view').classList.remove('hidden');
        document.getElementById('event-raid-view').classList.remove('hidden');
        
        const btnRaid = document.getElementById('event-sub-tab-raid');
        if (btnRaid) btnRaid.classList.add('active');
        return; 
    }

    // [4] 일반/이벤트 전투 보상 계산
    try {
        lastCombatType = combatInfo ? combatInfo.type : 'main'; 

        let rewardMsg = "";
        let titleText = isVictory ? "승리!" : "패배...";
        let titleColor = isVictory ? "text-green-400" : "text-red-400";

        if (isVictory) {
            if (combatInfo.type === 'event') {
                if (typeof eventDungeons !== 'undefined' && eventDungeons[combatInfo.indices]) {
                    const dungeon = eventDungeons[combatInfo.indices];
                    const reward = dungeon.eventPointReward || 0;
                    if (typeof playerEventPoints !== 'undefined') playerEventPoints += reward;
                    if (typeof playerCumulativeEventPoints !== 'undefined') playerCumulativeEventPoints += reward;
                    if (typeof clearedEventDungeons !== 'undefined' && !clearedEventDungeons.includes(dungeon.name)) {
                        clearedEventDungeons.push(dungeon.name);
                    }
                    rewardMsg = `이벤트 스테이지 클리어! ${reward} P를 획득했습니다.`;
                }
            } else if (combatInfo.type === 'main_stage') {
                if (typeof mainChapters !== 'undefined' && mainChapters[combatInfo.indices.chapter]) {
                    const stage = mainChapters[combatInfo.indices.chapter].stages[combatInfo.indices.stage];
                    const stageId = `${combatInfo.indices.chapter + 1}-${combatInfo.indices.stage + 1}`;
                    if (typeof clearedStages !== 'undefined' && !clearedStages.includes(stageId)) {
                        clearedStages.push(stageId);
                    }
                    let rewardsEarned = [];
                    if (stage.rewards) {
                        if (stage.rewards.fountainPens) {
                            if (typeof playerFountainPens !== 'undefined') playerFountainPens += stage.rewards.fountainPens;
                            rewardsEarned.push(`🖋️${stage.rewards.fountainPens}`);
                        }
                        if (stage.rewards.currency) {
                            if (typeof playerCurrency !== 'undefined') playerCurrency += stage.rewards.currency;
                            rewardsEarned.push(`💎${stage.rewards.currency}`);
                        }
                    }
                    rewardMsg = `스테이지 클리어! ${rewardsEarned.join(', ')} 획득!`;
                }
            }
        } else {
            rewardMsg = "전투에서 패배했습니다...";
        }

        // 결과 텍스트 적용
        if(resultTitle) {
            resultTitle.textContent = titleText;
            resultTitle.className = `text-4xl font-bold mb-4 ${titleColor}`;
        }
        if(resultMessage) resultMessage.textContent = rewardMsg;

        try { if(typeof updateUI === 'function') updateUI(); } catch(e) {}
        try { if(typeof checkAchievements === 'function') checkAchievements(); } catch(e) {}
saveGame();
    } catch (error) {
        console.error("보상 계산 에러:", error);
        if(resultMessage) resultMessage.textContent = `결과 처리 중 오류: ${error.message}`;
    }
}

            // ✅ [수정됨] createCard 함수 (등급별 글로우 적용)
function createCard(character, options = {}) {
    const { animationIndex, mode = 'default', isCardInDeck, isDeckFull, isCollected } = options;
    const cardInstance = options.instance; // 인스턴스 정보

    // ✨ 1. 표시할 등급 결정 (유전된 등급 우선)
    let displayRarity = character.rarity;
    if (cardInstance && cardInstance.inherited && cardInstance.inherited.originalRarity) {
        displayRarity = cardInstance.inherited.originalRarity;
    }

    // ✨ 2. 표시할 진영 결정 (유전된 진영 우선)
    let displayFaction = character.faction;
    if (cardInstance && cardInstance.inherited && cardInstance.inherited.faction) {
        displayFaction = cardInstance.inherited.faction;
    }

    const glowClass = `rarity-glow-${displayRarity}`;
    
    // 카드 생성
    const card = document.createElement('div');
    card.className = `rarity-${displayRarity} relative text-center rounded-lg shadow-md p-2 transform transition-transform duration-300 hover:scale-105 cursor-pointer`;
    card.title = character.name;
    
    const rarityColor = { 'N': 'text-gray-600', 'R': 'text-blue-800', 'SR': 'text-white', 'SSR': 'text-black' }[displayRarity];
    const factionColors = {
        '탐정': 'bg-blue-500 text-white',
        '조수': 'bg-green-500 text-white',
        '범인': 'bg-red-500 text-white',
        '히어로': 'bg-indigo-600 text-white',
        '빌런': 'bg-gray-800 text-white',
        '마법사': 'bg-purple-600 text-white',
        '초대객': 'bg-orange-400 text-white',
        '도박사': 'bg-yellow-600 text-white',
        '사제': 'bg-teal-500 text-white',
        '악마': 'bg-rose-900 text-white'
    };

    // 레벨 배지
    let levelBadgeHTML = '';
    if (cardInstance && cardInstance.level > 0) {
        levelBadgeHTML = `<div class="level-badge">+${cardInstance.level}</div>`;
    }
    
    // 개정 별
    let revisionStarsHTML = '';
    if (cardInstance && cardInstance.revision > 0) {
        revisionStarsHTML = `<div class="revision-stars">${'⭐'.repeat(cardInstance.revision)}</div>`;
    }
    
    // 버튼 생성 로직 (기존 유지)
    let actionButtonsHTML = '';
    if (mode === 'deckBuilder' && cardInstance) {
        const disabled = isDeckFull || isCardInDeck;
        const buttonText = isCardInDeck ? '편찬됨' : '추가';
        const buttonColor = isCardInDeck ? 'bg-gray-500' : 'bg-green-500 hover:bg-green-600';
        actionButtonsHTML = `<button data-action="add-to-deck" data-card-id="${cardInstance.id}" class="w-full mt-2 py-1 rounded-md text-white font-bold text-sm ${buttonColor}" ${disabled ? 'disabled' : ''}>${buttonText}</button>`;
    } else if (mode === 'inventory') {
        const isRepresentative = representativeCharacter && representativeCharacter.name === character.name;
        const repButtonText = isRepresentative ? '대표' : '대표 설정';
        const repButtonColor = isRepresentative ? 'bg-yellow-500' : 'bg-gray-600 hover:bg-gray-700';
        actionButtonsHTML = `<button data-action="set-representative" data-card-name="${character.name}" class="w-full mt-2 py-1 rounded-md text-white font-bold text-sm ${repButtonColor}" ${isRepresentative ? 'disabled' : ''}>${repButtonText}</button>`;
    } else if (mode === 'deckSlot' && cardInstance) {
        actionButtonsHTML = `<button data-action="remove-from-deck" data-card-id="${cardInstance.id}" class="w-full mt-2 py-1 rounded-md text-white font-bold text-sm bg-red-600 hover:bg-red-700 shadow-md">해제</button>`;
    }
    
    // ✨ 진영 배지 (displayFaction 사용)
    const factionBadge = `<span class="absolute top-2 right-2 text-xs font-bold px-2 py-1 rounded-full ${factionColors[displayFaction] || 'bg-gray-500'} z-10">${displayFaction}</span>`;

    card.innerHTML = `
        ${factionBadge} ${levelBadgeHTML} ${revisionStarsHTML} 
        <div class="relative pointer-events-none">
            <img src="${character.cardImageUrl}" alt="${character.name}" class="w-full h-full object-cover rounded-md mb-2 border-2 border-white/50 ${glowClass}"> 
            <p class="font-bold text-sm ${rarityColor} truncate">${character.name}</p>
            <p class="font-black text-lg ${rarityColor}" style="text-shadow: 1px 1px 2px rgba(255,255,255,0.5);">${displayRarity}</p>
        </div>
        ${actionButtonsHTML}
    `;

    if (cardInstance && mode !== 'collection') { 
        card.dataset.uniqueId = cardInstance.id;
    }

    if (typeof animationIndex === 'number') {
        card.style.opacity = '0';
        card.style.animationDelay = `${animationIndex * 0.05}s`;
        card.classList.add('card-animation');
    }
    
    if(mode === 'deckBuilder' && isCardInDeck) {
        card.classList.add('opacity-50');
    }

    if (mode === 'collection') {
        if (isCollected) {
            card.dataset.isCollected = "true";
        } else {
            card.dataset.isCollected = "false";
            card.classList.add('grayscale', 'opacity-75');
            card.classList.remove('hover:scale-105', 'cursor-pointer');
        }
    }
    return card;
}

            // ✅ [수정됨] getSkillDescription: 5턴 지속 문구 반영
function getSkillDescription(skill) {
    // 1. 구글 시트나 데이터 파일에 적어둔 '커스텀 설명'이 있다면 그걸 최우선으로 보여줌
    if (skill.desc && skill.desc !== "") {
        return skill.desc;
    }

    // 2. 커스텀 설명이 없으면, 스킬 타입에 따라 자동 생성
    const powerPercent = Math.round(skill.power * 100); // 예: 1.5 -> 150
    
    switch(skill.type) {
        case 'damage': 
            return `적에게 공격력의 ${powerPercent}% 만큼 피해를 줍니다.`;
        case 'heal': 
            return `자신의 체력을 공격력의 ${powerPercent}% 만큼 회복합니다.`;
        case 'vampire': 
            return `적을 공격하고 피해량의 50%를 체력으로 흡수합니다.`;
        case 'true_damage': 
            return `적의 방어력을 무시하고 공격력의 ${powerPercent}% 피해를 줍니다.`;
            
        // ▼▼▼ 여기 설명들이 변경되었습니다 (1턴 -> 5턴) ▼▼▼
        case 'buff_atk': 
            return `자신의 공격력이 5턴 동안 10% 증가합니다.`;
        case 'debuff_atk': 
            return `적의 공격력을 5턴 동안 10% 감소시킵니다.`;
        case 'debuff_def': 
            return `적의 방어력을 5턴 동안 20% 감소시킵니다.`;
        // ▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲
            
        default: 
            return '특별한 효과를 가진 스킬입니다.'; // 타입을 모를 때 나오는 기본 문구
    }
}

            let currentDetailCardId = null;

            // ✅ 이 코드로 기존 showCardDetails 함수를 통째로 교체해주세요.
            function showCardDetails(cardId) {
    const cardInstance = playerInventory.find(c => c.id === cardId);
    if (!cardInstance) {
        console.error("카드를 찾을 수 없습니다:", cardId);
        return;
    }

    currentDetailCardId = cardId;
    const character = findCharacter(cardInstance.name);
    const currentStats = getEnhancedStats(cardInstance);

    // --- 1. 기본 정보 표시 ---
    document.getElementById('detail-card-image').src = character.imageUrl;
    document.getElementById('detail-card-name').textContent = character.name;
    const rarityEl = document.getElementById('detail-card-rarity');
    
    // 유전된 등급이 있으면 그것을 표시
    let displayRarity = character.rarity;
    if (cardInstance.inherited && cardInstance.inherited.originalRarity) {
        displayRarity = cardInstance.inherited.originalRarity;
    }
    
    rarityEl.textContent = displayRarity;
    const rarityColor = { 'N': 'text-gray-400', 'R': 'text-blue-400', 'SR': 'text-purple-400', 'SSR': 'text-yellow-400' }[displayRarity];
    rarityEl.className = `font-bold text-2xl ${rarityColor}`;
    
    // 유전된 진영이 있으면 그것을 표시
    let displayFaction = character.faction;
    if (cardInstance.inherited && cardInstance.inherited.faction) {
        displayFaction = cardInstance.inherited.faction;
    }
    
    const factionEl = document.getElementById('detail-card-faction');
    factionEl.textContent = displayFaction;
    const factionColors = { 
        '탐정': 'bg-blue-500 text-white', '조수': 'bg-green-500 text-white', '범인': 'bg-red-500 text-white',
        '히어로': 'bg-indigo-600 text-white', '빌런': 'bg-gray-800 text-white', '마법사': 'bg-purple-600 text-white',
        '초대객': 'bg-orange-400 text-white', '도박사': 'bg-yellow-600 text-white', '사제': 'bg-teal-500 text-white', '악마': 'bg-rose-900 text-white'
    };
    
    // ✨ [수정됨] 끊겨있던 코드를 복구했습니다. (백틱과 변수가 정확히 닫혀야 합니다)
    factionEl.className = `font-bold text-lg px-3 py-1 rounded-full ${factionColors[displayFaction] || 'bg-gray-500'}`;

    // ▼▼▼ [부모 정보 표시 로직] ▼▼▼
    const parentsWrapper = document.getElementById('detail-parents-wrapper');
    const parentsContainer = document.getElementById('detail-parents-container');
    
    // 1. 자식 카드이고, 부모 정보(parents)가 있는지 확인
    if (cardInstance.inherited && cardInstance.inherited.parents && Array.isArray(cardInstance.inherited.parents)) {
        parentsContainer.innerHTML = '';
        
        // 2. 부모 정보 그리기
        cardInstance.inherited.parents.forEach((parentName, idx) => {
            const parentChar = findCharacter(parentName);
            const imgUrl = parentChar ? parentChar.imageUrl : 'https://placehold.co/50x50/333/fff?text=?';
            const rarityColor = parentChar ? ({ 'N':'border-gray-500', 'R':'border-blue-500', 'SR':'border-purple-500', 'SSR':'border-yellow-400' }[parentChar.rarity]) : 'border-gray-600';

            // HTML 문자열은 반드시 백틱(`)으로 감싸져 있어야 합니다.
            const parentHtml = `
                <div class="flex flex-col items-center group relative cursor-pointer" onclick="showCollectionCardDetails('${parentName}')" title="도감에서 보기">
                    <div class="relative w-12 h-12">
                        <img src="${imgUrl}" class="w-full h-full rounded-full border-2 ${rarityColor} object-cover shadow-md">
                        <div class="absolute -bottom-1 -right-1 bg-black text-white text-[10px] px-1 rounded-full border border-gray-500">
                            ${idx === 0 ? 'A' : 'B'}
                        </div>
                    </div>
                    <span class="text-[10px] text-gray-300 mt-1 font-bold">${parentName}</span>
                </div>
            `;
            
            if (idx > 0) {
                const plusSign = document.createElement('div');
                plusSign.className = "text-gray-500 text-xl font-bold";
                plusSign.innerText = "+";
                parentsContainer.appendChild(plusSign);
            }
            
            const wrapper = document.createElement('div');
            wrapper.innerHTML = parentHtml;
            parentsContainer.appendChild(wrapper.firstElementChild);
        });

        if (parentsWrapper) parentsWrapper.classList.remove('hidden'); 
    } else {
        if (parentsWrapper) parentsWrapper.classList.add('hidden'); 
    }

    // --- 2. 퇴고된 능력치 표시 ---
    document.getElementById('detail-stat-hp').textContent = currentStats.hp;
    document.getElementById('detail-stat-atk').textContent = currentStats.atk;
    document.getElementById('detail-stat-def').textContent = currentStats.def;

    // --- 3. 스킬 및 스토리 표시 ---
    const skillsContainer = document.getElementById('detail-skills-container');
    skillsContainer.innerHTML = '';
    
    // 유전된 스킬이 있으면 그것을 사용
    const displaySkills = (cardInstance.inherited && cardInstance.inherited.skills) ? cardInstance.inherited.skills : character.skills;

    displaySkills.forEach((skill, index) => {
        const isUltimate = displayRarity === 'SSR' && index === 1;
        const skillEl = document.createElement('div');
        skillEl.className = 'bg-black/20 p-3 rounded-lg';
        
        const description = skill.desc ? skill.desc : getSkillDescription(skill);

        skillEl.innerHTML = `
            <h4 class="font-bold ${isUltimate ? 'text-yellow-300' : 'text-white'}">
                ${isUltimate ? '궁극기' : '일반 스킬'}: ${skill.name}
            </h4>
            <p class="text-gray-300 italic">"${skill.dialogue || '...'}"</p>
            <p class="text-sm mt-1 text-green-300">${description}</p>
        `;
        skillsContainer.appendChild(skillEl);
    });
    
    currentStoryPages = character.story ? character.story.split('[PAGE_BREAK]') : ['스토리가 없습니다.'];
    currentStoryPageIndex = 0;
    displayCardStoryPage();

    // --- 4. 퇴고 UI 업데이트 ---
    const levelDisplay = document.getElementById('detail-card-level');
    const previewDisplay = document.getElementById('enhancement-preview');
    const costDisplay = document.getElementById('enhancement-cost');
    const enhanceButton = document.getElementById('enhance-card-button');
    
    levelDisplay.textContent = `+${cardInstance.level}`;
    
    if (cardInstance.level >= MAX_ENHANCEMENT_LEVEL) {
        previewDisplay.textContent = '최대 레벨에 도달했습니다.';
        enhanceButton.disabled = true;
        costDisplay.textContent = '퇴고 불가';
    } else {
        const nextLevelStats = getEnhancedStats({ ...cardInstance, level: cardInstance.level + 1 });
        const prob = ENHANCEMENT_PROBABILITIES[cardInstance.level];
        const probPercent = Math.floor(prob * 100);
        const probColor = prob >= 0.8 ? 'text-green-400' : (prob >= 0.5 ? 'text-yellow-400' : 'text-red-400');

        previewDisplay.innerHTML = `
            HP ${currentStats.hp} <span class="text-gray-400">&rarr;</span> ${nextLevelStats.hp}<br>
            ATK ${currentStats.atk} <span class="text-gray-400">&rarr;</span> ${nextLevelStats.atk}<br>
            DEF ${currentStats.def} <span class="text-gray-400">&rarr;</span> ${nextLevelStats.def}<br>
            <span class="${probColor} font-bold mt-1 block">성공 확률: ${probPercent}%</span>
        `;
        
        const cost = getEnhancementCost(cardInstance);
        costDisplay.textContent = `🖋️ ${cost}`;
        enhanceButton.disabled = playerFountainPens < cost;
    }

    // --- 5. 개정 UI 업데이트 (수정됨: 등급 일치 여부 확인) ---
    const revisionLevelDisplay = document.getElementById('detail-card-revision');
    const revisionPreviewDisplay = document.getElementById('revision-preview');
    const revisionMaterialSelect = document.getElementById('revision-material-select');
    const reviseButton = document.getElementById('revise-card-button');
    const inkwellCostDisplay = document.getElementById('inkwell-cost-display');
    const reviseInkButton = document.getElementById('revise-with-inkwell-button');

    revisionLevelDisplay.innerHTML = '⭐'.repeat(cardInstance.revision) + ` ${cardInstance.revision}차 개정`;
    revisionMaterialSelect.innerHTML = '<option value="">개정에 사용할 원본을 선택하세요</option>';

    if (cardInstance.revision >= MAX_REVISION_LEVEL) {
        revisionPreviewDisplay.textContent = '최종 개정판입니다.';
        reviseButton.disabled = true;
        revisionMaterialSelect.disabled = true;
        reviseInkButton.disabled = true;
        reviseInkButton.textContent = "최대 레벨";
        inkwellCostDisplay.textContent = "-";
    } else {
        const nextRevisionBonus = Math.round((cardInstance.revision + 1) * STAT_INCREASE_PER_REVISION * 100);
        revisionPreviewDisplay.textContent = `다음 개정 시 기본 능력치 +${nextRevisionBonus}%`;

        // ✨ [핵심 수정] 재료 카드 필터링 로직 강화
        const materialCards = playerInventory.filter(c => {
            // 1. 이름이 같아야 함
            if (c.name !== cardInstance.name) return false;
            // 2. 자기 자신은 제외
            if (c.id === cardInstance.id) return false;
            
            // 3. ✨ [신규] '실제 등급'이 일치해야 함
            // 타겟 카드의 등급
            const myRarity = (cardInstance.inherited && cardInstance.inherited.originalRarity) 
                             ? cardInstance.inherited.originalRarity 
                             : character.rarity;
            
            // 재료 카드의 등급
            const matChar = findCharacter(c.name);
            const matRarity = (c.inherited && c.inherited.originalRarity) 
                              ? c.inherited.originalRarity 
                              : (matChar ? matChar.rarity : 'N');

            return myRarity === matRarity;
        });

        if (materialCards.length > 0) {
            materialCards.forEach(mat => {
                // 옵션 텍스트에도 등급 표시 (확인용)
                const matRarity = (mat.inherited && mat.inherited.originalRarity) 
                                  ? mat.inherited.originalRarity 
                                  : findCharacter(mat.name).rarity;
                                  
                const option = document.createElement('option');
                option.value = mat.id;
                option.textContent = `[${matRarity}] ${mat.name} (Lv.${mat.level})`;
                revisionMaterialSelect.appendChild(option);
            });
            reviseButton.disabled = false;
            revisionMaterialSelect.disabled = false;
        } else {
            const option = document.createElement('option');
            option.textContent = '조건(등급/이름)이 맞는 원본이 없습니다.';
            option.disabled = true;
            revisionMaterialSelect.appendChild(option);
            reviseButton.disabled = true;
            revisionMaterialSelect.disabled = true;
        }

        // 잉크병 사용 (기존 로직 유지)
        const inkCost = INKWELL_REVISION_COSTS[displayRarity] || 999;
        const canAffordInk = playerInkwells >= inkCost;
        
        inkwellCostDisplay.innerHTML = `<span class="${canAffordInk ? 'text-green-400' : 'text-red-400'} font-bold">${playerInkwells}</span> / ${inkCost}`;
        reviseInkButton.disabled = !canAffordInk;
        reviseInkButton.textContent = canAffordInk ? "사용하기" : "부족함";
        reviseInkButton.onclick = reviseCardWithInkwell;
    }

    // --- 6. 출판(승급) UI 업데이트 ---
    const pubContainer = document.getElementById('publication-container');
    const pubButton = document.getElementById('publish-card-button');
    const pubTargetText = document.getElementById('publication-target-name');
    
    // 조건 확인
    const rarityOrder = ['N', 'R', 'SR', 'SSR'];
    const currentRarityIndex = rarityOrder.indexOf(displayRarity);
    
    const isMaxLevel = cardInstance.level >= (typeof MAX_ENHANCEMENT_LEVEL !== 'undefined' ? MAX_ENHANCEMENT_LEVEL : 9);
    const isMaxRevision = cardInstance.revision >= (typeof MAX_REVISION_LEVEL !== 'undefined' ? MAX_REVISION_LEVEL : 5);
    const hasNextRarity = currentRarityIndex !== -1 && currentRarityIndex < rarityOrder.length - 1;

    let showPublishBtn = false;
    let targetNameDisplay = "";

    if (isMaxLevel && isMaxRevision && hasNextRarity) {
        if (cardInstance.inherited) {
            // [자식 카드] 독립 출판 가능
            showPublishBtn = true;
            const nextRarity = rarityOrder[currentRarityIndex + 1];
            targetNameDisplay = `대상: [${nextRarity}] 독립 개정판 (특성 유지)`;
            pubButton.onclick = () => publishCard(currentDetailCardId, null);

        } else {
            // [일반 카드] 정식 출판 대상 찾기
            let nextRarityChar = null;
            const nextRarity = rarityOrder[currentRarityIndex + 1];

            if (character.publishTarget) {
                nextRarityChar = characters.find(c => c.name === character.publishTarget);
            }
            if (!nextRarityChar) {
                nextRarityChar = characters.find(c => c.baseName === character.baseName && c.rarity === nextRarity);
            }

            if (nextRarityChar) {
                showPublishBtn = true;
                targetNameDisplay = `대상: [${nextRarityChar.rarity}] ${nextRarityChar.name}`;
                pubButton.onclick = () => publishCard(currentDetailCardId, nextRarityChar);
            }
        }
    }

    if (showPublishBtn) {
        pubContainer.classList.remove('hidden');
        document.getElementById('enhancement-container').classList.add('hidden');
        document.getElementById('revision-container').classList.add('hidden');
        if (pubTargetText) pubTargetText.textContent = targetNameDisplay;
    } else {
        pubContainer.classList.add('hidden');
        document.getElementById('enhancement-container').classList.remove('hidden');
        document.getElementById('revision-container').classList.remove('hidden');
    }

    cardDetailModal.classList.remove('hidden');
}

                

			// ✅ showCardDetails 함수 바로 다음에 이 새로운 함수를 추가하세요.

function publishCard(cardId, targetCharacterData) {
    const myCard = playerInventory.find(c => c.id === cardId);
    if (!myCard) return;

    // 1. 자식 카드(영감)인지 확인
    const isChild = !!myCard.inherited;
    
    // 메시지 분기
    let confirmMsg = "";
    if (isChild) {
        confirmMsg = `[독립 출판]\n이 원고의 고유한 특성을 유지하며 상위 등급으로 출판하시겠습니까?\n\n(등급 상승, 기본 능력치 대폭 상승, 레벨/개정 초기화)`;
    } else {
        confirmMsg = `[정식 출판]\n이 원고를 [${targetCharacterData.name}]으로 정식 출판하시겠습니까?\n\n(주의: 레벨/개정 초기화)`;
    }

    if (!confirm(confirmMsg)) return;

    // 2. 공통: 레벨 및 개정 초기화
    const oldRarity = myCard.inherited ? myCard.inherited.originalRarity : findCharacter(myCard.name).rarity;
    myCard.level = 0;
    myCard.revision = 0;

    if (isChild) {
        // ================== 🌟 자식 카드: 독립 출판 로직 ==================
        
        // (1) 등급 상승 처리
        const rarityOrder = ['N', 'R', 'SR', 'SSR'];
        const currentIdx = rarityOrder.indexOf(myCard.inherited.originalRarity);
        
        if (currentIdx >= 3) return alert("이미 최고 등급입니다."); 
        
        const nextRarity = rarityOrder[currentIdx + 1];
        myCard.inherited.originalRarity = nextRarity; // 등급 변경

        // (2) 스탯 재계산 (비율 유지하며 뻥튀기)
        const currentMult = RARITY_STATS_WEIGHT[oldRarity] || 25;
        const nextMult = RARITY_STATS_WEIGHT[nextRarity] || 100;
        const growFactor = nextMult / currentMult; 

        myCard.inherited.stats.hp = Math.floor(myCard.inherited.stats.hp * growFactor);
        myCard.inherited.stats.atk = Math.floor(myCard.inherited.stats.atk * growFactor);
        myCard.inherited.stats.def = Math.floor(myCard.inherited.stats.def * growFactor);

        alert(`💡 독립 출판 성공!\n[${nextRarity}] 등급으로 승격되었습니다!\n능력치가 대폭 상승했습니다.`);

    } else {
        // ================== 📘 일반 카드: 정식 출판 로직 ==================
        
        const oldName = myCard.name;
        myCard.name = targetCharacterData.name; // 다른 캐릭터로 변신
        
        // 도감 등록
        if (typeof collectedCardNames !== 'undefined') {
            collectedCardNames.add(targetCharacterData.name);
        }
        
        alert(`[${oldName}] 원고가 [${targetCharacterData.name}]으로 훌륭하게 출판되었습니다!`);
    }

    // 3. 저장 및 갱신
    saveGame();
    updateUI();
    showCardDetails(cardId); 
    
    if (!document.getElementById('inventory-view').classList.contains('hidden')) {
        displayInventory();
    }
}
		
// [수정됨] 도감 카드 상세 보기 함수 (안전장치 및 UI 정리 강화)
function openCollectionCardModal(cardBaseName) {
    // 1. 기존 상세창 닫기 (겹침 방지)
    if (typeof hideCardDetails === 'function') {
        hideCardDetails(); 
    }

    // 2. 캐릭터 데이터 찾기
    const character = findCharacter(cardBaseName);
    if (!character) {
        console.error("도감 카드를 찾을 수 없습니다:", cardBaseName);
        return;
    }

    currentDetailCardId = null; // 도감은 인스턴스 ID가 없음

    // 3. 기본 정보 표시
    const imgEl = document.getElementById('detail-card-image');
    if(imgEl) imgEl.src = character.imageUrl;
    
    document.getElementById('detail-card-name').textContent = character.name;
    
    const rarityEl = document.getElementById('detail-card-rarity');
    rarityEl.textContent = character.rarity;
    const rarityColor = { 'N': 'text-gray-400', 'R': 'text-blue-400', 'SR': 'text-purple-400', 'SSR': 'text-yellow-400' }[character.rarity];
    rarityEl.className = `font-bold text-2xl ${rarityColor}`;
    
    const factionEl = document.getElementById('detail-card-faction');
    factionEl.textContent = character.faction;
    const factionColors = { 
        '탐정': 'bg-blue-500 text-white', '조수': 'bg-green-500 text-white', '범인': 'bg-red-500 text-white',
        '히어로': 'bg-indigo-600 text-white', '빌런': 'bg-gray-800 text-white', '마법사': 'bg-purple-600 text-white',
        '초대객': 'bg-orange-400 text-white', '도박사': 'bg-yellow-600 text-white', '사제': 'bg-teal-500 text-white', '악마': 'bg-rose-900 text-white'
    };
    factionEl.className = `font-bold text-lg px-3 py-1 rounded-full ${factionColors[character.faction] || 'bg-gray-500'}`;

    // 4. 기본 스탯 표시
    document.getElementById('detail-stat-hp').textContent = character.stats.hp;
    document.getElementById('detail-stat-atk').textContent = character.stats.atk;
    document.getElementById('detail-stat-def').textContent = character.stats.def;

    // 5. 스킬 표시
    const skillsContainer = document.getElementById('detail-skills-container');
    skillsContainer.innerHTML = '';
    character.skills.forEach((skill, index) => {
        const isUltimate = character.rarity === 'SSR' && index === 1;
        const skillEl = document.createElement('div');
        skillEl.className = 'bg-black/20 p-3 rounded-lg';
        
        const description = skill.desc ? skill.desc : getSkillDescription(skill);

        skillEl.innerHTML = `
            <h4 class="font-bold ${isUltimate ? 'text-yellow-300' : 'text-white'}">
                ${isUltimate ? '궁극기' : '일반 스킬'}: ${skill.name}
            </h4>
            <p class="text-gray-300 italic">"${skill.dialogue || '...'}"</p>
            <p class="text-sm mt-1 text-green-300">${description}</p>
        `;
        skillsContainer.appendChild(skillEl);
    });

    // 6. 스토리 표시 (✨안전장치 추가✨)
    // story 데이터가 없거나 비어있을 경우 에러가 나지 않도록 처리
    const storyText = character.story || "스토리가 없습니다.";
    currentStoryPages = storyText.split('[PAGE_BREAK]');
    currentStoryPageIndex = 0;
    displayCardStoryPage();
    
    const storyContainer = document.getElementById('detail-card-story-container');
    if(storyContainer) storyContainer.classList.remove('hidden');

    // 7. 불필요한 UI 숨기기 (도감 모드에서는 안 보여야 할 것들)
    const idsToHide = [
        'enhancement-container',  // 퇴고
        'revision-container',     // 개정
        'dismantle-container',    // 파쇄
        'publication-container',  // 출판
        'detail-parents-wrapper'  // 영감의 원천 (도감 카드는 부모가 없음)
    ];
    
    idsToHide.forEach(id => {
        const el = document.getElementById(id);
        if (el) el.classList.add('hidden');
    });

    // 8. 모달 열기
    document.getElementById('card-detail-modal').classList.remove('hidden');
}

// 전역 등록 (필수)
window.showCollectionCardDetails = showCollectionCardDetails;
			

			function enterMultiSelectMode() {
    isMultiSelectMode = true;
    selectedCardsToDismantle.clear();
    dismantleMultiUI.classList.remove('hidden');
    enterMultiModeButton.classList.add('hidden');
    displayInventory();
}

function exitMultiSelectMode() {
    isMultiSelectMode = false;
    selectedCardsToDismantle.clear();
    dismantleMultiUI.classList.add('hidden');
    enterMultiModeButton.classList.remove('hidden');
    displayInventory();
    // 모드 종료 시 인벤토리 뷰가 열려있다면 새로고침하여 카드 상세 모달이 뜨도록 합니다.
    if (!document.getElementById('inventory-view').classList.contains('hidden')) {
        switchTab('inventory');
    }
}

function updateMultiSelectUI() {
    const count = selectedCardsToDismantle.size;
    selectedCardCountSpan.textContent = `${count}장`;
    dismantleSelectedButton.disabled = count === 0;
    dismantleSelectedButton.classList.toggle('bg-red-700', count > 0);
}
			
			function dismantleCard(cardId) {
    if (!confirm('이 카드를 파쇄하고 재료를 회수하시겠습니까? 카드는 영구히 사라집니다.')) {
        return;
    }

    const indexToRemove = playerInventory.findIndex(c => c.id === cardId);
    if (indexToRemove === -1) {
        alert('카드를 찾을 수 없습니다.');
        return;
    }

    const cardInstance = playerInventory[indexToRemove];
    const character = findCharacter(cardInstance.name);
    const rarity = character.rarity;
    const rewards = DISMANTLE_REWARDS[rarity];

    // 덱에 포함된 카드는 삭제 불가능
    if (playerDeck.some(deckCard => deckCard.id === cardId)) {
        alert('편찬에 포함된 카드는 파쇄할 수 없습니다. 덱에서 먼저 제거해주세요.');
        return;
    }
    
    // 인벤토리에서 카드 제거
    playerInventory.splice(indexToRemove, 1);

    // 보상 지급
    let message = `[${cardInstance.name}] 파쇄 완료.`;
    if (rewards.fountainPens > 0) {
        playerFountainPens += rewards.fountainPens;
        message += ` 🖋️${rewards.fountainPens} 획득.`;
    }
    if (rewards.inkwells > 0) {
        playerInkwells += rewards.inkwells;
        message += ` 💧잉크병 ${rewards.inkwells} 획득.`;
    }

    hideCardDetails();
    updateUI();
    displayInventory();
    saveGame();
    showMessage(message, 'text-yellow-300', messageArea);
}
            
            function displayCardStoryPage() {
    const storyContent = document.getElementById('detail-card-story');
    const pageIndicator = document.getElementById('detail-story-page-indicator');
    
    // [수정된 부분] -------------------------------------------------
    let rawText = currentStoryPages[currentStoryPageIndex];
    
    // {nickname}을 실제 닉네임으로 변경
    let processedText = rawText.replace(/{nickname}/g, currentPlayerNickname);
    
    storyContent.textContent = processedText;
    // --------------------------------------------------------------

    pageIndicator.textContent = `${currentStoryPageIndex + 1} / ${currentStoryPages.length}`;
    
    detailStoryPrevButton.disabled = currentStoryPageIndex === 0;
    detailStoryNextButton.disabled = currentStoryPageIndex === currentStoryPages.length - 1;
}

            function hideCardDetails() {
                cardDetailModal.classList.add('hidden');
                // 👇 숨겨졌던 UI 요소들을 다시 보이도록 복원
                document.getElementById('enhancement-container').classList.remove('hidden');
                document.getElementById('revision-container').classList.remove('hidden');
                document.getElementById('dismantle-container').classList.remove('hidden');
            }
            
            // [수정] 캐릭터 검색 함수 (이름으로 못 찾으면 baseName으로 재검색)
function findCharacter(name) {
    if (!name) return undefined;
    
    const targetName = name.trim(); // 앞뒤 공백 제거 안전장치

    // 1. 전체 이름(name)으로 먼저 찾기 
    // 예: "[히어로] 아카이 츠키토" vs "[히어로] 아카이 츠키토" (일치)
    let found = characters.find(c => c.name === targetName);

    // 2. 없으면 기본 이름(baseName)으로 찾기 
    // 예: "아카이 츠키토" vs "[히어로] 아카이 츠키토" (불일치) -> baseName 확인 -> (일치!)
    if (!found) {
        found = characters.find(c => c.baseName === targetName);
    }

    return found;
}

            function displayStoryView() {
    const activeTab = document.querySelector('#story-view .sub-tab-button.active');
    
    // 현재 활성화된 탭이 '지난 이벤트(archive)'라면 해당 함수 호출
    if (activeTab && activeTab.id === 'story-sub-tab-archive') {
        displayEventArchive();
    } else {
        displayMainStories();
    }
}

// 2. 메인 스토리 목록 표시 함수
function displayMainStories() {
    // 컨테이너 표시/숨김 관리
    if (mainStoryContainer) mainStoryContainer.classList.remove('hidden');
    if (eventArchiveContainer) eventArchiveContainer.classList.add('hidden'); 
    
    mainStoryContainer.innerHTML = '';
    
    // 메인 스토리 데이터가 없으면 중단
    if (!mainStories) return;

    mainStories.forEach((story, index) => {
        // 해금 조건 확인 (던전 클리어 여부)
        const isUnlocked = story.dungeonToUnlock === null || clearedStages.includes(story.dungeonToUnlock);
        
        const storyEl = document.createElement('div');
        storyEl.className = `p-4 rounded-lg transition-colors duration-300 ${isUnlocked ? 'bg-white/20 hover:bg-white/30 cursor-pointer' : 'bg-black/30 text-gray-500'}`;
        
        if (isUnlocked) {
            storyEl.dataset.storyIndex = index;
            storyEl.dataset.storyType = 'main';
        }

        let unlockText = '클릭하여 스토리 읽기';
        if (!isUnlocked) {
            unlockText = `${story.dungeonToUnlock} 클리어 시 해금`;
        }

        storyEl.innerHTML = `
            <h3 class="text-xl font-bold ${isUnlocked ? 'text-yellow-300' : ''}">[메인] ${story.title}</h3>
            <p class="text-sm">${unlockText}</p>
        `;
        mainStoryContainer.appendChild(storyEl);
    });
}

// [수정] 지난 이벤트 스토리 보기 (미래 이벤트 숨김 처리 추가)
function displayEventArchive(selectedEventId = null) {
    // 컨테이너 표시/숨김 관리
    if (mainStoryContainer) mainStoryContainer.classList.add('hidden');
    if (eventArchiveContainer) eventArchiveContainer.classList.remove('hidden');
    
    eventArchiveContainer.innerHTML = '';

    if (!eventStories || eventStories.length === 0) {
        eventArchiveContainer.innerHTML = `<p class="text-center text-gray-400 mt-10">지난 이벤트 스토리가 없습니다.</p>`;
        return;
    }

    // [화면 1] 이벤트 목록 보기 (초기 화면)
    if (!selectedEventId) {
        const uniqueEventIds = new Set();
        eventStories.forEach(s => uniqueEventIds.add(s.eventId));

        eventArchiveContainer.innerHTML = `<h3 class="text-yellow-300 font-bold mb-4 px-2">📂 다시 볼 이벤트를 선택하세요</h3>`;
        
        // ✨ [핵심 수정] 현재 시간 가져오기
        const now = new Date();

        // ID들을 배열로 바꾼 뒤 '필터링(미래 이벤트 숨김)' 하고 '정렬'
        const sortedIds = Array.from(uniqueEventIds)
            .filter(id => {
                const info = allEventInfos.find(info => info.id === id);
                
                // 정보가 없거나, 시작 날짜가 현재보다 미래라면 목록에서 제외(false)
                if (!info || !info.startDate) return false;
                
                // 시작 날짜가 지났거나 오늘인 경우만 표시(true)
                return info.startDate <= now;
            })
            .sort((a, b) => {
                const infoA = allEventInfos.find(info => info.id === a);
                const infoB = allEventInfos.find(info => info.id === b);

                if (!infoA) return 1;
                if (!infoB) return -1;

                // 최신순 정렬 (내림차순)
                return new Date(infoB.startDate) - new Date(infoA.startDate);
            });

        if (sortedIds.length === 0) {
            eventArchiveContainer.innerHTML += `<p class="text-center text-gray-500 mt-4">공개된 이벤트 스토리가 없습니다.</p>`;
            return;
        }

        // 필터링된 목록으로 버튼 생성
        sortedIds.forEach(id => {
            const eventInfo = allEventInfos.find(info => info.id === id);
            const title = eventInfo ? eventInfo.title : `알 수 없는 이벤트 (${id})`;

            const btn = document.createElement('div');
            btn.className = 'p-4 bg-indigo-900/60 hover:bg-indigo-800 border border-indigo-500 rounded-lg mb-3 cursor-pointer flex justify-between items-center transition-all';
            
            btn.innerHTML = `
                <span class="font-bold text-lg text-white">${title}</span>
                <span class="text-sm text-gray-400">▶</span>
            `;
            
            btn.onclick = () => displayEventArchive(id);
            eventArchiveContainer.appendChild(btn);
        });
    } 
    // [화면 2] 스토리 목록 보기 (특정 이벤트 선택 시)
    else {
        // ... (이 아래 코드는 기존과 동일합니다) ...
        const eventInfo = allEventInfos.find(info => info.id === selectedEventId);
        const eventTitle = eventInfo ? eventInfo.title : selectedEventId;

        eventArchiveContainer.innerHTML = `
            <div class="flex items-center justify-between mb-4">
                <button id="archive-back-btn" class="text-sm bg-gray-600 hover:bg-gray-500 text-white px-3 py-1 rounded">⬅ 목록으로</button>
                <span class="text-yellow-300 font-bold text-sm border border-yellow-500 px-2 py-0.5 rounded">${eventTitle}</span>
            </div>
        `;
        
        document.getElementById('archive-back-btn').onclick = () => displayEventArchive(null);

        const targetStories = eventStories.filter(s => s.eventId === selectedEventId);

        targetStories.forEach((story) => {
            const realIndex = eventStories.indexOf(story);
            
            const storyEl = document.createElement('div');
            storyEl.className = `p-4 rounded-lg bg-white/10 hover:bg-white/20 cursor-pointer mb-2 transition-colors border-l-4 border-pink-500`;
            
            storyEl.onclick = () => {
                startInteractiveStory(realIndex, 'event');
            };

            storyEl.innerHTML = `
                <h3 class="text-lg font-bold text-pink-300">${story.title}</h3>
                <p class="text-xs text-gray-400">Click to Play</p>
            `;
            eventArchiveContainer.appendChild(storyEl);
        });
    }
}

			function getEnhancementCost(cardInstance) {
    const character = findCharacter(cardInstance.name);
    if (!character || cardInstance.level >= MAX_ENHANCEMENT_LEVEL) return null;

    const baseCost = ENHANCEMENT_BASE_COSTS[cardInstance.level];
    
    // ✨ [핵심 수정] 자식 카드라면 유전된 등급을 사용
    let rarity = character.rarity;
    if (cardInstance.inherited && cardInstance.inherited.originalRarity) {
        rarity = cardInstance.inherited.originalRarity;
    }

    const multiplier = RARITY_COST_MULTIPLIER[rarity] || 1.0;
    
    // 최종 비용 반올림
    return Math.ceil(baseCost * multiplier);
}
			
			// --- 대화형 스토리 관련 함수 (새 버전) ---
            // gacha3.html - startInteractiveStory 함수 (기존 함수 전체 교체)

function startInteractiveStory(storyOrIndex, type) {
    let storyData;

    if (typeof storyOrIndex === 'number' && type === 'main') {
        storyData = mainStories[storyOrIndex];
    } else if (typeof storyOrIndex === 'number' && type === 'event') {
        storyData = eventStories[storyOrIndex];
    } else if (typeof storyOrIndex === 'number' && type === 'event_part2') { // 👈 이 블록을 추가
        storyData = eventStoryPart2.secondHalf[storyOrIndex];
    } else if (typeof storyOrIndex === 'object') {
        // 스테이지 스토리 객체를 직접 받습니다.
        storyData = storyOrIndex;
    } else {
        return;
    }

    currentInteractiveStory = storyData;
    // 스토리 데이터가 없거나, 내용(content)이 배열이 아니면 중단합니다.
    if (!currentInteractiveStory || !Array.isArray(currentInteractiveStory.content)) {
        alert("스토리 내용을 찾을 수 없습니다!"); // 데이터 문제 발생 시 알림 추가
        return;
    }

    currentSceneIndex = 0;
    interactiveStoryModal.classList.remove('hidden');
    renderCurrentScene();
}
            // [수정] 스토리 장면 렌더링 (구글 시트 이미지 연동 추가)
// [수정] 스토리 장면 렌더링 (이름 깔끔하게 출력 + 이미지 자동 매칭)
function renderCurrentScene() {
    const scene = currentInteractiveStory.content[currentSceneIndex];
    if (!scene) {
        closeInteractiveStory();
        return;
    }

    const choiceContainer = document.getElementById('choice-buttons-container');
    choiceContainer.innerHTML = ''; 

    // [수정] 대화 화자 이름 표시 로직 (강력한 괄호 제거 적용)
    let displaySpeaker = scene.character;

    if (scene.character) {
        const charData = findCharacter(scene.character);
        // 1. 데이터가 있으면 baseName 사용, 없으면 원래 이름 사용
        if (charData && charData.baseName) {
            displaySpeaker = charData.baseName;
        }
        
        // 2. [핵심] baseName이든 원래 이름이든, 괄호가 있다면 무조건 삭제
        // 일반 괄호()와 전각 괄호（）를 모두 감지하여 제거합니다.
        displaySpeaker = displaySpeaker.replace(/\s*[\(\（].*?[\)\）]/g, '').trim();
    }

    speakerName.textContent = displaySpeaker || ' ';
    
    // {nickname} 치환 기능
    let textToShow = scene.dialogue ? scene.dialogue.replace(/{nickname}/g, currentPlayerNickname) : "...";
    dialogueText.textContent = textToShow;

    // 선택지 처리 로직
    if (scene.choices && scene.choices.length > 0) {
        storyNextButton.classList.add('hidden'); 
        scene.choices.forEach(choice => {
            const button = document.createElement('button');
            button.className = 'gacha-button bg-white/10 hover:bg-white/20 text-white font-bold py-3 px-5 rounded-lg w-full max-w-xs';
            button.textContent = choice.text;
            if (choice.nextScene !== undefined) button.dataset.nextScene = choice.nextScene;
            if (choice.isFinalChoice) {
                button.dataset.isFinalChoice = 'true';
                button.dataset.statId = choice.statId;
            }
            choiceContainer.appendChild(button);
        });
    } else {
        storyNextButton.classList.remove('hidden'); 
    }

    // 캐릭터 이미지 처리 (기존 로직 유지)
    if (scene.character) {
        let portraitUrl = '';
        if (characterPortraits[scene.character] && characterPortraits[scene.character][scene.expression]) {
            portraitUrl = characterPortraits[scene.character][scene.expression];
        } else {
            const charData = findCharacter(scene.character);
            if (charData) portraitUrl = charData.imageUrl || charData.cardImageUrl || '';
        }

        if (scene.position === 'left') {
            storyCharLeft.src = portraitUrl;
            storyCharLeft.classList.remove('opacity-0');
            storyCharLeft.classList.add('opacity-100');
            storyCharRight.classList.remove('opacity-100');
            storyCharRight.classList.add('opacity-0'); 
        } else if (scene.position === 'right') {
            storyCharRight.src = portraitUrl;
            storyCharRight.classList.remove('opacity-0');
            storyCharRight.classList.add('opacity-100');
            storyCharLeft.classList.remove('opacity-100');
            storyCharLeft.classList.add('opacity-0');
        }
    } else {
        storyCharLeft.classList.add('opacity-0');
        storyCharRight.classList.add('opacity-0');
    }
}

function advanceStory() {
    // 1. 현재 장면 데이터를 먼저 가져옵니다.
    const currentScene = currentInteractiveStory.content[currentSceneIndex]; 

    // 2. 'jumpTo' 속성이 있는지 확인합니다.
    if (currentScene && currentScene.jumpTo !== undefined) {
        // 'jumpTo'가 있으면: 인덱스를 지정된 번호로 점프
        currentSceneIndex = currentScene.jumpTo;
    } else {
        // 'jumpTo'가 없으면: 평소처럼 인덱스를 1 증가
        currentSceneIndex++;
    }

    // 3. 증가/점프된 인덱스가 스토리의 끝을 넘었는지 확인합니다.
    if (currentSceneIndex < currentInteractiveStory.content.length) {
        // 4. 스토리가 끝나지 않았으면: 다음 장면을 렌더링
        renderCurrentScene();
    } else {
        // 5. 스토리가 끝났으면:
        // (가장 중요!) 스토리를 닫기 *전에* 콜백(전투 시작 명령)을 읽어옵니다.
        const callback = interactiveStoryModal.dataset.callback; 
        
        closeInteractiveStory(); // 스토리를 닫습니다. (이때 currentInteractiveStory가 null이 됩니다)
        
        // 읽어둔 콜백이 있으면 실행합니다.
        if (callback) {
            eval(callback);
            interactiveStoryModal.dataset.callback = ''; // 콜백 비우기
        }
    }
}

// gacha3.html - dismantleMultipleCards 함수 (기존 함수 전체 교체)

function dismantleMultipleCards() {
    if (selectedCardsToDismantle.size === 0) {
        showMessage('파쇄할 카드를 선택해주세요.', 'text-yellow-400', messageArea);
        return;
    }

    if (!confirm(`선택된 ${selectedCardsToDismantle.size}장의 카드를 파쇄하고 재료를 회수하시겠습니까? (복구 불가)`)) {
        return;
    }

    let totalFountainPens = 0;
    let totalInkwells = 0;
    let cardsToRemove = []; 
    let cardsInDeck = []; 
    
    // 1. 파쇄할 카드와 보상 계산 (로직 유지)
    selectedCardsToDismantle.forEach(cardId => {
        const cardInstance = playerInventory.find(c => c.id === cardId);
        if (!cardInstance) return;

        if (playerDeck.some(deckCard => deckCard.id === cardId)) {
            cardsInDeck.push(cardInstance.name);
        } else {
            const character = findCharacter(cardInstance.name);
            const rewards = DISMANTLE_REWARDS[character.rarity];
            totalFountainPens += rewards.fountainPens;
            totalInkwells += rewards.inkwells;
            cardsToRemove.push(cardId);
        }
    });

    if (cardsToRemove.length === 0 && cardsInDeck.length > 0) {
        showMessage('선택된 카드가 모두 덱에 포함되어 파쇄할 수 없습니다.', 'text-red-400', messageArea);
        return;
    }

    // 2. 파쇄 실행 및 보상 지급
    playerInventory = playerInventory.filter(card => !cardsToRemove.includes(card.id));
    playerFountainPens += totalFountainPens;
    playerInkwells += totalInkwells;

    // 3. ✨핵심 수정✨: 파쇄 성공 시 선택 목록을 즉시 초기화
    selectedCardsToDismantle.clear(); // ✅ 선택된 카드 목록을 비웁니다.
    
    hideCardDetails();
    updateUI();
    saveGame();
    
    // 4. 결과 모달에 보상 표시 (데이터 채우기)
    dismantleRewardsList.innerHTML = '';
    
    if (totalFountainPens > 0) {
        dismantleRewardsList.innerHTML += `<div class="text-xl text-gray-300 font-bold">🖋️ 만년필: +${totalFountainPens}</div>`;
    }
    if (totalInkwells > 0) {
        dismantleRewardsList.innerHTML += `<div class="text-xl text-fuchsia-400 font-bold">💧 잉크병: +${totalInkwells}</div>`;
    }
    
    if (cardsInDeck.length > 0) {
         dismantleRewardsList.innerHTML += `<div class="text-xs text-red-400 mt-2">(${cardsInDeck.length}장은 덱에 포함되어 파쇄되지 않았습니다.)</div>`;
    }

    // 5. 모달에 최종 메시지 상태 저장
    if (cardsToRemove.length > 0) {
        dismantleResultModal.dataset.finalMessage = `총 ${cardsToRemove.length}장의 원고를 파쇄했습니다.`;
        dismantleResultModal.dataset.messageColor = 'text-yellow-300';
    } else {
        dismantleResultModal.dataset.finalMessage = '';
    }
    
    // 모달 표시 (즉시 띄웁니다.)
    dismantleResultModal.classList.remove('hidden');
}
			

			
			// [수정된 enhanceCard 함수]
function enhanceCard() {
    if (!currentDetailCardId) return;
    const cardInstance = playerInventory.find(c => c.id === currentDetailCardId);
    if (!cardInstance || cardInstance.level >= MAX_ENHANCEMENT_LEVEL) return;

    const cost = getEnhancementCost(cardInstance);
    if (cost === null) return;

    if (playerFountainPens >= cost) {
        // 1. 비용 소모 (성공하든 실패하든 소모됨)
        playerFountainPens -= cost;

        // 2. 성공 확률 가져오기
        const successRate = ENHANCEMENT_PROBABILITIES[cardInstance.level];
        
        // 3. 주사위 굴리기 (0.0 ~ 1.0 사이 랜덤값)
        const isSuccess = Math.random() < successRate;

        if (isSuccess) {
            // ✨ 성공!
            cardInstance.level++;
            alert(`퇴고 성공! (+${cardInstance.level}) 원고가 더 완벽해졌습니다.`);
            checkAchievements(); // 업적 체크
        } else {
            // 💥 실패... (레벨 유지, 비용만 소모)
            alert("퇴고 실패... 잉크만 낭비했습니다. 문장이 마음에 들지 않습니다.");
        }

        // 4. 저장 및 UI 갱신
        updateUI();
        saveGame();
        showCardDetails(currentDetailCardId); // 바뀐 정보(또는 그대로인 정보) 다시 표시
        
        // 인벤토리창이 열려있다면 갱신
        if (!document.getElementById('inventory-view').classList.contains('hidden')) {
            displayInventory();
        }

    } else {
        alert('만년필이 부족합니다!');
    }
}
			
            function closeInteractiveStory() {
    interactiveStoryModal.classList.add('hidden');
    storyCharLeft.src = ''; // 이미지 리소스 정리
    storyCharRight.src = '';
    currentInteractiveStory = null;
    // 일반적인 스토리 뷰에서 닫는 경우 콜백은 실행하지 않습니다.
   
}

// ✨ [신규] 잉크병을 사용하여 개정하는 함수
function reviseCardWithInkwell() {
    if (!currentDetailCardId) return;

    const cardInstance = playerInventory.find(c => c.id === currentDetailCardId);
    if (!cardInstance) return;

    const character = findCharacter(cardInstance.name);

    // ✨ [핵심 수정] 자식 카드라면 유전된 등급을 사용
    let rarity = character.rarity;
    if (cardInstance.inherited && cardInstance.inherited.originalRarity) {
        rarity = cardInstance.inherited.originalRarity;
    }

    // 1. 비용 계산 (수정된 rarity 기준)
    const cost = INKWELL_REVISION_COSTS[rarity] || 999;

    // 2. 유효성 검사
    if (cardInstance.revision >= MAX_REVISION_LEVEL) {
        alert("이미 최종 개정판입니다.");
        return;
    }
    if (playerInkwells < cost) {
        alert(`잉크병이 부족합니다. (필요: ${cost}, 보유: ${playerInkwells})`);
        return;
    }

    if (!confirm(`잉크병 ${cost}개를 사용하여 [${cardInstance.name}]의 개정판을 제작하시겠습니까?`)) {
        return;
    }

    // 3. 자원 소모 및 레벨업
    playerInkwells -= cost;
    cardInstance.revision++;

    // 4. 성공 메시지 및 저장
    const successDialogue = character.enhancementSuccessDialogue || "특수 잉크의 힘으로 새로운 가능성이 열렸습니다!";
    alert(`[잉크병 사용 성공]\n${successDialogue}`);

    updateUI();
    saveGame();
    showCardDetails(currentDetailCardId); // UI 갱신

    // 인벤토리창 갱신
    if (!document.getElementById('inventory-view').classList.contains('hidden')) {
        displayInventory();
    }
}
            function reviseCard() {
    if (!currentDetailCardId) return;

    if (!confirm('선택한 카드를 원본으로 사용해 개정판을 제작하시겠습니까? 원본 카드는 사라집니다.')) {
        return; 
    }

    const baseCard = playerInventory.find(c => c.id === currentDetailCardId);
    const materialSelect = document.getElementById('revision-material-select');
    const materialId = materialSelect.value;

    if (!baseCard || !materialId || materialId === "") { 
        alert('개정에 사용할 원본 카드를 선택해주세요.');
        return;
    }
    if (baseCard.revision >= MAX_REVISION_LEVEL) return;

    // 재료 카드를 인벤토리에서 찾음
    const materialIndex = playerInventory.findIndex(c => c.id === materialId);
    if (materialIndex > -1) {
        const materialCard = playerInventory[materialIndex];

        // 1. 덱 포함 여부 확인
        const isMaterialInDeck = playerDeck.some(deckCard => deckCard.id === materialId);
        if(isMaterialInDeck) {
            alert('편찬에 포함된 카드는 원본으로 사용할 수 없습니다.');
            return;
        }

        // ✨ 2. [신규] 등급 일치 여부 2차 검증 (보안)
        const getRealRarity = (c) => {
            if (c.inherited && c.inherited.originalRarity) return c.inherited.originalRarity;
            return findCharacter(c.name).rarity;
        };

        const baseRarity = getRealRarity(baseCard);
        const matRarity = getRealRarity(materialCard);

        if (baseRarity !== matRarity) {
            alert(`등급이 서로 다릅니다.\n(대상: ${baseRarity} / 재료: ${matRarity})\n같은 등급끼리만 개정이 가능합니다.`);
            return;
        }

        // 검증 통과 -> 재료 삭제
        playerInventory.splice(materialIndex, 1);
    } else {
        alert('오류: 재료 카드를 찾을 수 없습니다.');
        return;
    }

    // 기본 카드의 개정 레벨을 올립니다.
    baseCard.revision++;

    // 성공 메시지 및 UI 갱신
    const successDialogue = findCharacter(baseCard.name).enhancementSuccessDialogue || `${baseCard.name}의 새로운 가능성이 발견되었다!`;
    alert(successDialogue);

    updateUI();
    saveGame();
    showCardDetails(currentDetailCardId); 
    
    if (!document.getElementById('inventory-view').classList.contains('hidden')) {
        displayInventory();
    }
}
			
			async function recordAndShowStats(statId, userChoiceText) {
    const choiceRef = db.collection('choices').doc(statId);

    await choiceRef.set({
        [userChoiceText]: firebase.firestore.FieldValue.increment(1)
    }, { merge: true });

    const doc = await choiceRef.get();
    const data = doc.exists ? doc.data() : {};

    let totalVotes = 0;
    const stats = [];
    Object.values(data).forEach(votes => {
        totalVotes += votes;
    });

    // 통계에 표시할 선택지 목록을 실제 선택지가 있었던 씬에서 직접 가져오도록 수정
    const allChoices = eventStoryPart2.firstHalf[3].choices.map(c => c.text);

    allChoices.forEach(choiceText => {
        const votes = data[choiceText] || 0;
        const percent = totalVotes > 0 ? ((votes / totalVotes) * 100).toFixed(1) : "0.0";
        stats.push({ text: choiceText, percent: percent });
    });

    const statsContainer = document.getElementById('stats-container');
    statsContainer.innerHTML = stats.map(stat => `
        <div class="text-left">
            <div class="flex justify-between items-center mb-1">
                <span class="font-bold">${stat.text}</span>
                <span class="text-yellow-300">${stat.percent}%</span>
            </div>
            <div class="w-full bg-gray-600 rounded-full h-4">
                <div class="bg-blue-500 h-4 rounded-full" style="width: ${stat.percent}%"></div>
            </div>
        </div>
    `).join('');

    document.getElementById('choice-stats-modal').classList.remove('hidden');
}

// 1. 프로필 화면 표시
function displayProfileView() {
    // 닉네임 & 메시지 세팅
    document.getElementById('profile-nickname-edit').value = currentPlayerNickname;
    document.getElementById('profile-message-edit').value = playerProfile.statusMessage || "";
    document.getElementById('profile-msg-count').textContent = (playerProfile.statusMessage || "").length;

    // 대표 카드 이미지 세팅
    const repImg = document.getElementById('profile-rep-image');
    const repName = document.getElementById('profile-rep-name');

    let cardData = null;
    let charData = null;

    // 저장된 대표 카드 ID가 있고, 인벤토리에 그 카드가 실제로 존재하는지 확인
    if (playerProfile.repCardId) {
        cardData = playerInventory.find(c => c.id === playerProfile.repCardId);
    }

    // 만약 저장된 카드가 없다면(파쇄됨 등), 인벤토리의 첫 번째 카드를 보여줌 (또는 빈 상태)
    if (!cardData && playerInventory.length > 0) {
        // 기본값 없음 상태 유지
    }

    if (cardData) {
        charData = findCharacter(cardData.name);
        repImg.src = charData.imageUrl;
        repName.textContent = `[${charData.rarity}] ${charData.name} (Lv.${cardData.level})`;
        repName.className = "text-yellow-300 font-bold text-lg mt-2";
    } else {
        repImg.src = "https://placehold.co/400x600/000000/ffffff?text=Select+Card";
        repName.textContent = "대표 카드를 선택해주세요";
        repName.className = "text-gray-500 font-bold text-lg mt-2";
    }
}

// 2. 프로필 저장 버튼 클릭 시
function saveProfileData() {
    const newNickname = document.getElementById('profile-nickname-edit').value.trim();
    const newMessage = document.getElementById('profile-message-edit').value.trim();

    if (!newNickname) return alert("닉네임을 입력해주세요.");

    // 데이터 갱신
    currentPlayerNickname = newNickname;
    playerProfile.statusMessage = newMessage;

    // UI 갱신 (상단 닉네임 표시 등)
    document.getElementById('nickname-display').textContent = currentPlayerNickname;

    // Firebase 저장
    saveGame();
    alert("프로필이 저장되었습니다.");
}

// 3. 카드 선택 모달 열기
function openProfileCardSelector() {
    const modal = document.getElementById('profile-card-selector-modal');
    const list = document.getElementById('profile-card-list');
    list.innerHTML = '';

    // 인벤토리 정렬 (등급 높은 순 -> 레벨 높은 순)
    const sortedInv = [...playerInventory].sort((a, b) => {
        const charA = findCharacter(a.name);
        const charB = findCharacter(b.name);
        
        if (!charA) return 1;
        if (!charB) return -1;

        const rarityOrder = { 'SSR': 4, 'SR': 3, 'R': 2, 'N': 1 };
        const rA = rarityOrder[charA.rarity] || 0;
        const rB = rarityOrder[charB.rarity] || 0;

        return (rB - rA) || (b.level - a.level);
    });

    sortedInv.forEach(cardInstance => {
        const charData = findCharacter(cardInstance.name);
        if (!charData) return; 

        // ✨ 핵심 변경: 직접 HTML을 짜지 않고 'createCard' 함수를 사용합니다.
        // mode: 'default'로 설정하면 버튼 없이 카드 모양만 예쁘게 나옵니다.
        const cardEl = createCard(charData, { 
            instance: cardInstance, 
            mode: 'default' 
        });

        // 클릭 이벤트 연결 (클릭 시 해당 카드로 선택)
        cardEl.onclick = () => {
            selectProfileCard(cardInstance.id);
        };

        // ✨ 현재 선택된 카드라면 노란색 테두리와 뱃지로 표시
        if (playerProfile.repCardId === cardInstance.id) {
            cardEl.classList.add('ring-4', 'ring-yellow-400', 'z-10'); // 강조 테두리
            
            // '선택됨' 뱃지 추가
            const badge = document.createElement('div');
            badge.className = 'absolute top-0 right-0 bg-yellow-400 text-black font-bold px-2 py-1 rounded-bl-lg shadow-md z-20 text-xs';
            badge.innerText = 'V';
            cardEl.appendChild(badge);
        }

        list.appendChild(cardEl);
    });

    modal.classList.remove('hidden');
}

// 4. 카드 선택 처리
function selectProfileCard(cardId) {
    playerProfile.repCardId = cardId;
    document.getElementById('profile-card-selector-modal').classList.add('hidden');
    displayProfileView(); // 화면 갱신 (저장은 아직 안 함, 유저가 저장 버튼 눌러야 함)
}
window.displayProfileView = displayProfileView;
window.saveProfileData = saveProfileData;
window.openProfileCardSelector = openProfileCardSelector;
window.selectProfileCard = selectProfileCard;
// ... openRankingModal 함수 정의가 끝나는 곳 바로 아래에 추가 ...

window.openRankingModal = openRankingModal;

// 5. 한마디 글자수 카운팅 (이벤트 리스너 연결 필요)
document.getElementById('profile-message-edit').addEventListener('input', function() {
    document.getElementById('profile-msg-count').textContent = this.value.length;
});


		function handleStoryInteraction(e) {
    const choiceButton = e.target.closest('button');

    // --- 1. 선택지 버튼을 클릭한 경우 (기존 로직) ---
    if (choiceButton && choiceButton.dataset.nextScene) {
        currentEventChoice = choiceButton.textContent;
        currentSceneIndex = parseInt(choiceButton.dataset.nextScene);
        renderCurrentScene();
    } 
    // --- 2. '전반부 완료' 같은 최종 버튼을 클릭한 경우 (기존 로직) ---
    else if (choiceButton && choiceButton.dataset.isFinalChoice === 'true') {
        closeInteractiveStory();
        if (currentEventChoice) {
            // ✅ 1. 유저의 선택을 playerChoices 객체에 기록합니다.
            playerChoices[choiceButton.dataset.statId] = currentEventChoice;
            
            // ✅ 2. 변경된 playerChoices를 저장합니다.
            saveGame();

            recordAndShowStats(choiceButton.dataset.statId, currentEventChoice);
        } else {
            console.error("오류: 유저의 선택이 기록되지 않았습니다.");
        }
    }
    // --- 3. "스킵" 버튼을 누른 경우 (무시) ---
    else if (choiceButton && choiceButton.id === 'story-skip-button') {
        // 스킵 버튼은 자체 리스너(closeInteractiveStory)가 있으므로,
        // 여기서 advanceStory가 호출되는 것을 막습니다.
        return;
    }
    // --- 4. ✨ 그 외의 영역 (대화창, "다음" 버튼 등)을 클릭한 경우 ---
    else {
        // 현재 선택지가 화면에 떠 있는지 확인
        const choiceContainer = document.getElementById('choice-buttons-container');
        
        // 선택지가 없을 때만 (즉, '다음' 버튼이 보일 때만) advanceStory를 호출
        if (choiceContainer.children.length === 0) {
            advanceStory();
        }
        // (선택지가 1개 이상 떠있다면, 유저가 선택지를 누르길 기다리며 아무것도 하지 않음)
    }
}
			
            // --- 이벤트 리스너 ---

// ✨ [신규] 마이룸 입주민 필터 버튼 클릭 이벤트
document.getElementById('myroom-filter-container').addEventListener('click', (e) => {
    const btn = e.target.closest('.myroom-filter-btn');
    if (!btn) return;

    // 1. 필터 상태 변경
    currentMyRoomFilter = btn.dataset.filter;

    // 2. 버튼 스타일 업데이트 (선택된 건 파란색, 나머진 회색)
    document.querySelectorAll('.myroom-filter-btn').forEach(b => {
        if (b.dataset.filter === currentMyRoomFilter) {
            b.classList.remove('bg-gray-600', 'hover:bg-gray-700');
            b.classList.add('bg-blue-500', 'hover:bg-blue-600');
        } else {
            b.classList.remove('bg-blue-500', 'hover:bg-blue-600');
            b.classList.add('bg-gray-600', 'hover:bg-gray-700');
        }
    });

    // 3. 목록 다시 그리기
    updateMyRoomSelectorUI();
});

// ✨ 계정 관련 버튼
document.getElementById('register-button').addEventListener('click', registerUser);
document.getElementById('login-button').addEventListener('click', loginUser);
document.getElementById('logout-button').addEventListener('click', logoutUser);



// ✨ 이벤트 스토리 뷰의 새 서브 탭 리스너
document.getElementById('event-story-sub-tab-part1').addEventListener('click', () => {
    document.getElementById('event-story-part1-container').classList.remove('hidden');
    document.getElementById('event-story-part2-container').classList.add('hidden');
    document.getElementById('event-story-sub-tab-part1').classList.add('active');
    document.getElementById('event-story-sub-tab-part2').classList.remove('active');
	
});
document.getElementById('event-story-sub-tab-part2').addEventListener('click', () => {
    document.getElementById('event-story-part1-container').classList.add('hidden');
    document.getElementById('event-story-part2-container').classList.remove('hidden');
    document.getElementById('event-story-sub-tab-part1').classList.remove('active');
    document.getElementById('event-story-sub-tab-part2').classList.add('active');
	displayEventStoryPart2(); // 👈 이 줄을 추가하세요.
});

document.getElementById('event-view').addEventListener('click', (e) => {
    const storyEl = e.target.closest('[data-story-type]');
    if (!storyEl || !storyEl.dataset.storyIndex) return; // 유효한 스토리 버튼이 아니면 종료

    const storyType = storyEl.dataset.storyType;
    const storyIndex = parseInt(storyEl.dataset.storyIndex, 10);

    if (storyType === 'event') {
        // --- 전반부 스토리 클릭 ---
        startInteractiveStory(storyIndex, 'event');

    } else if (storyType === 'event_part2') {
        // --- 후반부 스토리 클릭 ---
        const storyData = eventStoryPart2.secondHalf[storyIndex];

        // 분기 스토리 처리
        if (storyData.isBranching) {
            const userChoice = playerChoices['event_part2_final_choice'];
            if (userChoice && storyData.branches[userChoice]) {
                startInteractiveStory({ content: storyData.branches[userChoice] });
            } else {
                // 혹시 모를 오류 방지용 기본값
                startInteractiveStory({ content: storyData.branches['결정적인 지문을 믿는다.'] });
            }
        } else {
            // 일반 후반부 스토리
            startInteractiveStory(storyIndex, 'event_part2');
        }

        // 후반부 스토리를 "클릭"했다는 사실을 기록 (이것이 다음 스토리의 해금 조건)
        playerChoices[`event_part2_story_${storyIndex}`] = true;
        saveGame();
        
        // 스토리가 끝난 후 UI를 새로고침하여 다음 스토리가 해금된 것을 바로 보여주기 위한 설정
        document.getElementById('interactive-story-modal').dataset.callback = 'displayEventStoryPart2()';
    }
});

// ✨ 인벤토리 다중 파쇄 모드 관련
enterMultiModeButton.addEventListener('click', enterMultiSelectMode);
exitMultiModeButton.addEventListener('click', exitMultiSelectMode);
dismantleSelectedButton.addEventListener('click', dismantleMultipleCards);

// ✨ 파쇄 결과 모달 닫기
closeDismantleResultButton.addEventListener('click', () => {
    const finalMessage = dismantleResultModal.dataset.finalMessage;
    const messageColor = dismantleResultModal.dataset.messageColor;
    dismantleResultModal.classList.add('hidden');
    if (finalMessage) {
        showMessage(finalMessage, messageColor, messageArea);
        dismantleResultModal.dataset.finalMessage = '';
    }
    exitMultiSelectMode();
});

// 필터 버튼 클릭
document.getElementById('inventory-filter-buttons').addEventListener('click', (e) => {
    const button = e.target.closest('.filter-button');
    if (button && button.dataset.filter) {
        currentRarityFilter = button.dataset.filter;
        displayInventory();
    }
});

// 필터된 원고 전체 선택 버튼 클릭
document.getElementById('select-all-filtered-button').addEventListener('click', () => {
    // 현재 화면에 보이는 카드들만 선택 대상으로 합니다.
    const currentlyVisibleCards = playerInventory.filter(cardInstance => {
        if (currentRarityFilter === 'All') return true;
        const character = findCharacter(cardInstance.name);
        return character && character.rarity === currentRarityFilter;
    });

    // 덱에 포함되지 않은 카드만 선택 목록에 추가합니다.
    currentlyVisibleCards.forEach(cardInstance => {
        const isInDeck = playerDeck.some(deckCard => deckCard.id === cardInstance.id);
        if (!isInDeck) {
            selectedCardsToDismantle.add(cardInstance.id);
        }
    });

    // 선택 상태를 화면에 즉시 반영합니다.
    displayInventory();
});

// ✨ 카드 상세 모달에서 단일 파쇄
dismantleCardButton.addEventListener('click', () => {
    dismantleCard(currentDetailCardId);
});

// ================ 👇 이벤트 홈 관련 리스너 (신규) 👇 ================

// 1. '홈' 화면의 이벤트 배너 클릭 시 -> 이벤트 홈(안내 창)으로 이동
const bannerElement = document.getElementById('event-banner'); 

if (bannerElement) { 
    // 기존 리스너 덮어쓰기
    bannerElement.onclick = function() {
        switchTab('event-home'); // ✨ 여기가 'event'에서 'event-home'으로 바뀝니다!
    };
}

// 2. '이벤트 홈'의 '이벤트 전투' 버튼 클릭 시
document.getElementById('goto-event-battle').addEventListener('click', () => {
    // 기존 event-view를 보여주고, '전투' 서브 탭을 활성화
    document.getElementById('event-home-view').classList.add('hidden');
    document.getElementById('event-view').classList.remove('hidden');
    displayEventView(); // 전투/스토리/상점 목록을 그림
    switchSubTab(document.getElementById('event-view'), eventSubTabBattle); // 전투 탭 활성화
});

// 3. '이벤트 홈'의 '이벤트 스토리' 버튼 클릭 시
document.getElementById('goto-event-story').addEventListener('click', () => {
    document.getElementById('event-home-view').classList.add('hidden');
    document.getElementById('event-view').classList.remove('hidden');
    displayEventView(); 
    switchSubTab(document.getElementById('event-view'), eventSubTabStory); // 스토리 탭 활성화
});

// 4. '이벤트 홈'의 '이벤트 서가' 버튼 클릭 시
document.getElementById('goto-event-gacha').addEventListener('click', () => {
    switchTab('gacha'); // 뽑기 탭으로 이동
    switchGachaTab('event'); // 이벤트 뽑기 서브 탭 활성화
});

// 5. '이벤트 홈'의 '이벤트 상점' 버튼 클릭 시 (신규 추가)
            document.getElementById('goto-event-shop').addEventListener('click', () => {
                // 기존 event-view를 보여주고, '상점' 서브 탭을 활성화
                document.getElementById('event-home-view').classList.add('hidden');
                document.getElementById('event-view').classList.remove('hidden');
                displayEventView(); // 전투/스토리/상점 목록을 그림
                
                // '상점' 탭을 활성화하기 위해 eventSubTabShop 변수(DOM 요소)를 전달
                switchSubTab(document.getElementById('event-view'), eventSubTabShop); 
            });

// ======================================================================


// =================== 👇 '도감' 탭 전용 리스너 👇 ===================

// '도감' 탭의 캐릭터 목록(사이드바) 클릭 이벤트
document.getElementById('collection-character-list').addEventListener('click', (e) => {
    const button = e.target.closest('button');
    if (button && button.dataset.baseName) {
        displayCharacterDetail(button.dataset.baseName);
    }
});

// '도감' 탭의 서브 탭 (카드 모음) 클릭
document.getElementById('collection-sub-tab-cards').addEventListener('click', (e) => {
    e.target.classList.add('active');
    document.getElementById('collection-sub-tab-dialogues').classList.remove('active');
    document.getElementById('collection-cards-view').classList.remove('hidden');
    document.getElementById('collection-dialogues-view').classList.add('hidden');
    
    // 현재 선택된 캐릭터의 baseName을 찾아서 카드 뷰를 다시 그림
    const activeCharButton = document.querySelector('#collection-character-list button.active');
    if (activeCharButton) {
        const baseName = activeCharButton.dataset.baseName;
        // const isCollected = new Set(playerInventory.map(card => findCharacter(card.name)?.baseName)).has(baseName); // 👈 이 줄 삭제
        displayCharacterCards(baseName); // 👈 두 번째 인자 없이 호출하도록 수정
    }
});

// '도감' 탭의 서브 탭 (대사 모음) 클릭
document.getElementById('collection-sub-tab-dialogues').addEventListener('click', (e) => {
    e.target.classList.add('active');
    document.getElementById('collection-sub-tab-cards').classList.remove('active');
    document.getElementById('collection-cards-view').classList.add('hidden');
    document.getElementById('collection-dialogues-view').classList.remove('hidden');
    
    // 현재 선택된 캐릭터의 baseName을 찾아서 대사 뷰를 그림
    const activeCharButton = document.querySelector('#collection-character-list button.active');
    if (activeCharButton) {
        displayCharacterDialogues(activeCharButton.dataset.baseName);
    }
});
// =================================================================

// ✨ 데이터 업로드 (이제 사용되지 않지만, 만약을 위해 남겨둠)
if (uploadFile) {
    uploadFile.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (file) {
            uploadSaveData(file); 
        }
        e.target.value = null; 
    });
}

// 1. 메인 스토리 탭 클릭
storySubTabMain.addEventListener('click', () => {
    storySubTabMain.classList.add('active');
    storySubTabArchive.classList.remove('active'); // archive 탭 비활성화
    displayStoryView();
});

// 2. 지난 이벤트(Archive) 탭 클릭 (기존 Stage 탭 리스너 대체)
storySubTabArchive.addEventListener('click', () => {
    storySubTabArchive.classList.add('active');
    storySubTabMain.classList.remove('active');
    displayStoryView();
});

// ✨ 인벤토리 정렬 버튼
document.getElementById('inventory-sort-buttons').addEventListener('click', (e) => {
    const button = e.target.closest('.sort-button');
    if (button && button.dataset.sort) {
        const newSortOrder = button.dataset.sort;
        if (newSortOrder === currentSortOrder) {
            isSortAscending = !isSortAscending;
        } else {
            currentSortOrder = newSortOrder;
            isSortAscending = false; 
        }
        displayInventory();
    }
});

// ✨ 카드 강화 및 개정 버튼
document.getElementById('enhance-card-button').addEventListener('click', enhanceCard);
document.getElementById('revise-card-button').addEventListener('click', reviseCard);

// ✨ 메인 탭 버튼
allTabs.forEach(tab => tab.addEventListener('click', () => switchTab(tab.id.split('-')[1])));

// ✨ 업적 보상 받기
achievementsContainer.addEventListener('click', (e) => {
    const button = e.target.closest('[data-ach-id]');
    if (button) {
        claimAchievement(button.dataset.achId);
    }
});

// ✨ 뽑기 버튼
pullOneButton.addEventListener('click', () => handlePull(1, PULL_ONE_COST, 'normal'));
pullTenButton.addEventListener('click', () => handlePull(10, PULL_TEN_COST, 'normal'));
pullOneEventButton.addEventListener('click', () => handlePull(1, PULL_ONE_COST, 'event'));
pullTenEventButton.addEventListener('click', () => handlePull(10, PULL_TEN_COST, 'event'));

// ✨ 기타 기능 버튼
expandInventoryButton.addEventListener('click', expandInventory);
autoFillDeckButton.addEventListener('click', autoFillDeck);
resetButton.addEventListener('click', resetGame);


		

// 2. 마이룸 내부 버튼들
const openShopBtn = document.getElementById('open-furniture-shop');
if (openShopBtn) openShopBtn.addEventListener('click', openFurnitureShop);

const closeShopBtn = document.getElementById('close-furniture-shop');
const shopModal = document.getElementById('furniture-shop-modal');
if (closeShopBtn) {
    closeShopBtn.addEventListener('click', () => {
        shopModal.classList.add('hidden');
    });
}

// 상점 모달 배경 클릭 시 닫기
if (shopModal) {
    shopModal.addEventListener('click', (e) => {
        if (e.target === shopModal) shopModal.classList.add('hidden');
    });
}

		

// ✨ 뽑기 뷰의 서브 탭
gachaTabNormal.addEventListener('click', () => switchGachaTab('normal'));
gachaTabEvent.addEventListener('click', () => switchGachaTab('event'));

// ✨ 카드 클릭 이벤트 (인벤토리, 덱 편성, 도감 등) - 수정된 버전
const cardClickableContainers = [inventoryContainer, deckInventoryContainer, deckSlotsContainer, collectionContainer];
cardClickableContainers.forEach(container => {
    container.addEventListener('click', (e) => {
        // 파쇄 중이거나, 클릭된 요소가 카드 자체가 아니면 무시
        if (isDismantling) return;
        
        // 1. 액션 버튼(`data-action`) 클릭 처리
        const actionButton = e.target.closest('[data-action]');
        if (actionButton) {
            e.stopPropagation(); // 카드 클릭 이벤트 중복 방지
            const action = actionButton.dataset.action;
            const cardId = actionButton.dataset.cardId;
            const cardName = actionButton.dataset.cardName;

            if (action === 'set-representative') setRepresentative(cardName);
            else if (action === 'add-to-deck') addToDeck(cardId);
            else if (action === 'remove-from-deck') removeFromDeck(cardId);
            
            return; // 액션 버튼 처리 후 종료
        }
        
        // 2. 카드 자체 클릭 처리 (상세 정보 보기 또는 다중 선택)
        const cardElement = e.target.closest('.relative.text-center'); // 카드 요소 찾기
        // data-unique-id는 인벤토리/덱 카드에만 있으므로 이걸로 구분
        const cardUniqueId = cardElement?.dataset.uniqueId; 

        // 인벤토리에서 다중 선택 모드일 때
        if (container === inventoryContainer && isMultiSelectMode && cardUniqueId) {
             const isInDeck = playerDeck.some(deckCard => deckCard.id === cardUniqueId);
             if (isInDeck) {
                 showMessage('덱에 포함된 카드는 파쇄할 수 없습니다.', 'text-red-400', messageArea);
                 return;
             }
             if (selectedCardsToDismantle.has(cardUniqueId)) {
                 selectedCardsToDismantle.delete(cardUniqueId);
             } else {
                 selectedCardsToDismantle.add(cardUniqueId);
             }
             displayInventory(); // 선택 상태 UI 업데이트
             return; // 다중 선택 후 종료
        }
        
        // 도감이 아닌 곳에서 유효한 카드 ID가 있을 때만 상세 정보 표시
        if (container !== collectionContainer && cardUniqueId) {
             showCardDetails(cardUniqueId);
        } 
        // 👇 도감에서 클릭 시: 기본 카드 정보 표시 (새 함수 호출)
        else if (container === collectionContainer && cardElement) {
            // 카드 요소에서 기본 이름(name)을 가져옵니다. (title 속성 활용)
            const cardBaseName = cardElement.title; 
            // 수집된 카드인지 다시 한번 확인 (회색 카드 클릭 방지)
            const isCollected = cardElement.dataset.isCollected === "true";
            if (cardBaseName && isCollected) {
                openCollectionCardModal(cardBaseName); // ✨ 변경된 함수 이름으로 호출
            }
        }

    }); // addEventListener 콜백 끝
}); // forEach 콜백 끝

// ✨ 전투 뷰 (챕터 및 스테이지 선택)
document.getElementById('combat-view').addEventListener('click', (e) => {
    const button = e.target.closest('button[data-action]');
    if (!button) return;
    const action = button.dataset.action;
    if (action === 'select-chapter') displayStages(parseInt(button.dataset.chapterIndex));
    else if (action === 'challenge-stage') challengeStage(parseInt(button.dataset.chapterIndex), parseInt(button.dataset.stageIndex));
});

// ✨ 홈 화면 및 이벤트 배너
homeCharacterContainer.addEventListener('click', () => { if (representativeCharacter) displayHomeView(true); });

eventBanner.addEventListener('click', () => {
    // 메시지는 띄우지 않고 바로 이벤트 탭으로 이동
    switchTab('event'); 
});
// ✨ 모달 닫기 버튼들 (결과 확인 후 화면 이동 처리)
closeCombatResultButton.addEventListener('click', () => {
    const resultModal = document.getElementById('combat-result-modal');
    
    if (resultModal) {
        // [핵심 해결] 아까 강제로 준 display: flex를 display: none으로 덮어씁니다.
        resultModal.style.display = 'none'; 
        resultModal.classList.add('hidden');
        
        // Z-index도 초기화 (혹시 모를 간섭 방지)
        resultModal.style.zIndex = '';
    }

    // 전투 화면 숨기기
    const combatView = document.getElementById('combat-in-progress-view');
    if (combatView) {
        combatView.classList.add('hidden');
    }

    // 화면 이동 로직 (원래대로)
    if (lastCombatType === 'event') {
        switchTab('event');
        displayEventView();
        
        const eventView = document.getElementById('event-view');
        const btnBattle = document.getElementById('event-sub-tab-battle');
        if (eventView && btnBattle) {
            switchSubTab(eventView, btnBattle);
        }
    } else {
        switchTab('combat');
    }
});
closeCardDetailButton.addEventListener('click', hideCardDetails);
cardDetailModal.addEventListener('click', (e) => { if (e.target === cardDetailModal) hideCardDetails(); });

// ✨ 스토리 뷰 (메인, 스테이지, 이벤트 스토리 목록)
storyView.addEventListener('click', (e) => {
    const storyEl = e.target.closest('[data-story-index], [data-stage-id]');
    if (!storyEl) return;
    if (storyEl.dataset.storyType === 'main') {
        startInteractiveStory(parseInt(storyEl.dataset.storyIndex), 'main');
    } else if (storyEl.dataset.storyType === 'stage') {
        const stageId = storyEl.dataset.stageId;
        const [chapIdx, stgIdx] = stageId.split('-').map(s => parseInt(s) - 1);
        const stage = mainChapters[chapIdx]?.stages[stgIdx];
        if (stage && stage.stageStory) startInteractiveStory({ content: stage.stageStory });
        else alert('스테이지 스토리 데이터를 찾을 수 없습니다.');
    } else if (storyEl.dataset.storyType === 'event') {
        startInteractiveStory(parseInt(storyEl.dataset.storyIndex), 'event');
    } 
});

// ✨ 이벤트 상점
eventShopContainer.addEventListener('click', (e) => {
    const button = e.target.closest('button');
    if (button && button.dataset.itemId) purchaseEventItem(button.dataset.itemId);
});

// ✨ 대화형 스토리 모달 상호작용
interactiveStoryModal.addEventListener('click', handleStoryInteraction);
document.getElementById('close-stats-modal').addEventListener('click', () => {
    document.getElementById('choice-stats-modal').classList.add('hidden');
});
storySkipButton.addEventListener('click', closeInteractiveStory);

// ✨ 카드 상세 스토리 페이지네이션
detailStoryPrevButton.addEventListener('click', () => {
    if (currentStoryPageIndex > 0) {
        currentStoryPageIndex--;
        displayCardStoryPage();
    }
});
detailStoryNextButton.addEventListener('click', () => {
    if (currentStoryPageIndex < currentStoryPages.length - 1) {
        currentStoryPageIndex++;
        displayCardStoryPage();
    }
});

// ✨ 전투 속도 조절
speed1xButton.addEventListener('click', () => setCombatSpeed(1));
speed2xButton.addEventListener('click', () => setCombatSpeed(2));
speed4xButton.addEventListener('click', () => setCombatSpeed(4));

		

// ✨ 이벤트 뷰의 서브 탭 (수정됨)
        eventSubTabBattle.addEventListener('click', () => {
            displayEventView(); 
            switchSubTab(document.getElementById('event-view'), eventSubTabBattle); 
        });
        eventSubTabStory.addEventListener('click', () => {
            displayEventView(); 
            switchSubTab(document.getElementById('event-view'), eventSubTabStory); 
        });
        eventSubTabShop.addEventListener('click', () => {
            displayEventView(); 
            switchSubTab(document.getElementById('event-view'), eventSubTabShop); 
        });

        // 👇👇👇 [여기]에 이 코드를 붙여넣으세요! 👇👇👇
        
        // --- [수정] 마이룸 배치 모드 활성화 코드 ---
        const myRoomEditBtn = document.getElementById('myroom-edit-mode');
        if (myRoomEditBtn) {
            myRoomEditBtn.addEventListener('click', toggleEditMode);
        }

		// ✨✨ [추가] 가구 보관함 버튼 연결 ✨✨
        const openStorageBtn = document.getElementById('open-furniture-storage');
        if (openStorageBtn) openStorageBtn.addEventListener('click', openFurnitureStorage);

        const closeStorageBtn = document.getElementById('close-furniture-storage');
        const storageModal = document.getElementById('furniture-storage-modal');
        
        if (closeStorageBtn) {
            closeStorageBtn.addEventListener('click', () => {
                storageModal.classList.add('hidden');
            });
        }
        
        if (storageModal) {
            storageModal.addEventListener('click', (e) => {
                if (e.target === storageModal) storageModal.classList.add('hidden');
            });
        }
        // 드래그 기능 초기화
        initDragEvents();
        // ==========================================
        // ▼▼▼ 교환소(Trade) 통합 코드 (여기서부터 붙여넣으세요) ▼▼▼
        // ==========================================

        // 1. 변수 및 기본 설정
        let selectedTradeCardId = null; 

        // 2. 탭 버튼 리스너
        const tradeTabBtn = document.getElementById('tab-trade');
        if (tradeTabBtn) {
            tradeTabBtn.addEventListener('click', () => {
                switchTab('trade');
                loadTradeList();
            });
        }

        const tradeSubTabMarket = document.getElementById('trade-sub-tab-market');
        if (tradeSubTabMarket) {
            tradeSubTabMarket.addEventListener('click', () => {
                document.getElementById('trade-market-view').classList.remove('hidden');
                document.getElementById('trade-register-view').classList.add('hidden');
                tradeSubTabMarket.classList.add('active');
                document.getElementById('trade-sub-tab-register').classList.remove('active');
                loadTradeList();
            });
        }

        const tradeSubTabRegister = document.getElementById('trade-sub-tab-register');
        if (tradeSubTabRegister) {
            tradeSubTabRegister.addEventListener('click', () => {
                document.getElementById('trade-market-view').classList.add('hidden');
                document.getElementById('trade-register-view').classList.remove('hidden');
                document.getElementById('trade-sub-tab-market').classList.remove('active');
                tradeSubTabRegister.classList.add('active');
                
                loadTradeInventory();
                loadMyTrades();
                
                // ✨ [추가] 탭을 열 때 선택 상자 초기화 함수 실행
                initTradeTargetSelectors(); 
            });
        }

		// ✨ [신규] 1. 베이스 이름 목록 채우기
function initTradeTargetSelectors() {
    const baseSelect = document.getElementById('trade-target-basename');
    if (!baseSelect) return;

    // 중복 제거된 베이스 이름 목록 만들기 (가나다순 정렬)
    // 'characters' 변수는 yumecan_data.js에 있는 전체 데이터입니다.
    const uniqueBaseNames = [...new Set(characters.map(c => c.baseName))].sort();

    baseSelect.innerHTML = '<option value="">등장인물을 선택하세요</option>';
    uniqueBaseNames.forEach(name => {
        const option = document.createElement('option');
        option.value = name;
        option.textContent = name;
        baseSelect.appendChild(option);
    });

    // 베이스 이름 변경 시 이벤트 연결
    baseSelect.onchange = updateTradeRarityOptions;
}

// ✨ [신규] 2. 선택된 캐릭터의 '등급' 목록 채우기
function updateTradeRarityOptions() {
    const baseName = document.getElementById('trade-target-basename').value;
    const raritySelect = document.getElementById('trade-target-rarity-select');
    const specificSelect = document.getElementById('trade-target-specific-card');
    
    // 초기화
    raritySelect.innerHTML = '<option value="">등급 선택</option>';
    specificSelect.innerHTML = '<option value="">-</option>';
    specificSelect.disabled = true;

    if (!baseName) {
        raritySelect.disabled = true;
        return;
    }

    // 해당 캐릭터가 가진 등급들만 추출
    const availableRarities = [...new Set(
        characters.filter(c => c.baseName === baseName).map(c => c.rarity)
    )];
    
    // 등급 순서 정렬 (N -> R -> SR -> SSR)
    const rarityOrder = { 'N': 1, 'R': 2, 'SR': 3, 'SSR': 4 };
    availableRarities.sort((a, b) => rarityOrder[a] - rarityOrder[b]);

    availableRarities.forEach(r => {
        const option = document.createElement('option');
        option.value = r;
        option.textContent = r;
        raritySelect.appendChild(option);
    });

    raritySelect.disabled = false;
    raritySelect.onchange = updateTradeSpecificCardOptions;
}

// ✨ [신규] 3. 캐릭터+등급에 맞는 '구체적인 카드' 목록 채우기
function updateTradeSpecificCardOptions() {
    const baseName = document.getElementById('trade-target-basename').value;
    const rarity = document.getElementById('trade-target-rarity-select').value;
    const specificSelect = document.getElementById('trade-target-specific-card');

    specificSelect.innerHTML = '<option value="">카드 선택</option>';

    if (!baseName || !rarity) {
        specificSelect.disabled = true;
        return;
    }

    // 조건에 맞는 카드 찾기
    const targetCards = characters.filter(c => c.baseName === baseName && c.rarity === rarity);

    targetCards.forEach(c => {
        const option = document.createElement('option');
        option.value = c.name; // 실제 값은 풀네임 (예: [빌런] 김기철)
        option.textContent = c.name;
        specificSelect.appendChild(option);
    });

    specificSelect.disabled = false;
}

        // [수정된 loadTradeInventory 함수]
function loadTradeInventory() {
    const container = document.getElementById('trade-inventory-container');
    if (!container) return;
    container.innerHTML = '';

    if (!playerInventory) {
        container.innerHTML = '<p class="col-span-full text-center text-gray-400">데이터 로딩 중...</p>';
        return;
    }

    // ✨ 헬퍼: 실제 등급 확인
    const getRealRarity = (card) => {
        if (card.inherited && card.inherited.originalRarity) {
            return card.inherited.originalRarity;
        }
        const char = findCharacter(card.name);
        return char ? char.rarity : 'N';
    };

    // 1. 필터링 (덱 제외 & 등급 필터 적용)
    let tradableCards = playerInventory.filter(card => {
        // 덱에 있는 카드는 제외
        if (playerDeck.some(d => d.id === card.id)) return false;
        
        // ✨ 등급 필터 적용 (실제 등급 기준)
        if (currentTradeRarityFilter !== 'All') {
            const realRarity = getRealRarity(card);
            if (realRarity !== currentTradeRarityFilter) return false;
        }
        return true;
    });

    // 2. 정렬
    const rarityOrder = { 'SSR': 4, 'SR': 3, 'R': 2, 'N': 1 };
    tradableCards.sort((a, b) => {
        const charA = findCharacter(a.name);
        const charB = findCharacter(b.name);
        
        // 실제 등급 기준으로 정렬
        const rA = rarityOrder[getRealRarity(a)] || 0;
        const rB = rarityOrder[getRealRarity(b)] || 0;

        return (rB - rA) || (b.level - a.level) || a.name.localeCompare(b.name);
    });

    if (tradableCards.length === 0) {
        const msg = currentTradeRarityFilter === 'All' 
            ? '거래 가능한 카드가 없습니다.<br>(덱에 있는 카드는 제외)' 
            : `[${currentTradeRarityFilter}] 등급의 카드가 없습니다.`;
        container.innerHTML = `<p class="col-span-full text-center text-gray-400 py-4 text-xs">${msg}</p>`;
        return;
    }

    // 3. 카드 생성
    tradableCards.forEach(cardInstance => {
        const charData = findCharacter(cardInstance.name);
        const isSelected = (selectedTradeCardId === cardInstance.id);
        
        const cardEl = document.createElement('div');
        cardEl.className = `relative cursor-pointer border-2 rounded-lg p-1 transition-all ${isSelected ? 'border-yellow-400 bg-white/20' : 'border-transparent bg-black/40 hover:bg-white/10'}`;
        cardEl.dataset.cardId = cardInstance.id;

        const imageUrl = charData ? charData.imageUrl : '';
        const displayName = charData ? charData.name : cardInstance.name;
        
        // ✨ 실제 등급 및 색상 결정
        const rarity = getRealRarity(cardInstance);
        const rarityColors = {
            'N': 'bg-gray-500 text-white',
            'R': 'bg-blue-600 text-white',
            'SR': 'bg-purple-600 text-white',
            'SSR': 'bg-yellow-400 text-black'
        };
        const badgeClass = rarityColors[rarity] || 'bg-gray-600 text-white';

        // ✨ 자식 카드 표시 (유전자 아이콘)
        let childBadge = '';
        if (cardInstance.inherited) {
            childBadge = `<span class="absolute top-0 left-0 bg-pink-600 text-white text-[10px] font-bold px-1 py-0.5 rounded-br shadow-md z-20">🧬</span>`;
        }

        cardEl.innerHTML = `
            <div class="pointer-events-none">
                <div class="aspect-[2/3] overflow-hidden rounded mb-1 relative">
                        <img src="${imageUrl}" class="w-full h-full object-cover">
                        ${childBadge}
                        <span class="absolute top-0 right-0 ${badgeClass} text-[10px] font-bold px-1.5 py-0.5 rounded-bl shadow-md z-10">
                        ${rarity}
                        </span>
                </div>
                <p class="text-xs text-center text-white truncate mt-1">${displayName}</p>
                <p class="text-[10px] text-center text-gray-400">Lv.${cardInstance.level}</p>
            </div>
        `;
        container.appendChild(cardEl);
    });
}

        // 4. 인벤토리 클릭 이벤트 (위임)
        const tradeInvContainer = document.getElementById('trade-inventory-container');
        if (tradeInvContainer) {
            tradeInvContainer.addEventListener('click', (e) => {
                const cardEl = e.target.closest('[data-card-id]');
                if (cardEl) {
                    const clickedId = cardEl.dataset.cardId;
                    selectedTradeCardId = clickedId;
                    
                    const cardInstance = playerInventory.find(c => c.id === clickedId);
                    if (cardInstance) {
                        const charData = findCharacter(cardInstance.name);
                        document.getElementById('trade-selected-name').innerHTML = 
                            `<span class="text-yellow-300">${charData.name}</span> <span class="text-xs text-gray-400">(Lv.${cardInstance.level})</span>`;
                        document.getElementById('trade-selected-card-preview').classList.remove('hidden');
                        loadTradeInventory();
                    }
                }
            });
        }
		
		const tradeFilterContainer = document.getElementById('trade-filter-buttons');
if (tradeFilterContainer) {
    tradeFilterContainer.addEventListener('click', (e) => {
        const btn = e.target.closest('.trade-filter-button');
        if (!btn) return;
        
        // 1. 필터 상태 업데이트
        currentTradeRarityFilter = btn.dataset.filter;
        
        // 2. 버튼 스타일 변경 (선택된 것만 파란색, 나머지는 회색)
        document.querySelectorAll('.trade-filter-button').forEach(b => {
            b.classList.remove('bg-blue-500', 'hover:bg-blue-600');
            b.classList.add('bg-gray-600', 'hover:bg-gray-700');
        });
        btn.classList.remove('bg-gray-600', 'hover:bg-gray-700');
        btn.classList.add('bg-blue-500', 'hover:bg-blue-600');
        
        // 3. 목록 새로고침
        loadTradeInventory();
    });
}

        // 5. 거래 등록 버튼 (새로고침 없이 이동 + 내 거래 표시)
        const btnRegister = document.getElementById('btn-register-trade');
        if (btnRegister) {
            btnRegister.addEventListener('click', async () => {
                if (!currentUser) return alert("로그인이 필요합니다.");
                if (!selectedTradeCardId) return alert("보낼 카드를 선택해주세요.");
                
                // ✨ [수정] 텍스트 입력값 대신 선택 상자에서 값 가져오기
                // const targetName = document.getElementById('trade-target-name').value.trim(); (삭제)
                const targetName = document.getElementById('trade-target-specific-card').value; // 구체적인 카드 이름
                const targetRarity = document.getElementById('trade-target-rarity-select').value; // 등급

                // 유효성 검사
                if (!targetName || !targetRarity) return alert("원하는 카드를 끝까지 선택해주세요.");
                
                if (playerCurrency < 10) return alert("보석이 부족합니다. (수수료 10)");

                if (!confirm(`[${targetName}] (${targetRarity}등급)을(를) 구하는 거래를 등록하시겠습니까?`)) return;

                const userRef = db.collection('users').doc(currentUser.uid);
                const tradesCollection = db.collection('trades');

                try {
                    await db.runTransaction(async (transaction) => {
                        const userDoc = await transaction.get(userRef);
                        if (!userDoc.exists) throw "User not found";

                        const userData = userDoc.data();
                        const currentInventory = userData.inventory || [];
                        
                        const cardIndex = currentInventory.findIndex(c => c.id === selectedTradeCardId);
                        if (cardIndex === -1) throw "카드를 찾을 수 없습니다.";

                        const cardToTrade = currentInventory[cardIndex];
                        
                        // DB 업데이트 준비
                        const newInventory = [...currentInventory];
                        newInventory.splice(cardIndex, 1); // 인벤토리에서 제거
                        
                        const newCurrency = (userData.currency || 0) - 10; // 수수료 차감
                        if (newCurrency < 0) throw "보석 부족";

                        transaction.update(userRef, { 
                            inventory: newInventory,
                            currency: newCurrency
                        });

                        const newTradeRef = tradesCollection.doc();
                        transaction.set(newTradeRef, {
        senderUid: currentUser.uid,
        senderName: currentPlayerNickname,
        offeredCard: cardToTrade,
        targetName: targetName,
        targetRarity: targetRarity, // ✨ [추가] DB에 희망 등급 저장
        createdAt: firebase.firestore.FieldValue.serverTimestamp(),
        status: 'active'
    });
                    });

                    // ✨ [핵심 변경] 새로고침 없이 즉시 반영 로직 ✨
                    
                    // 1. 로컬 데이터(내 인벤토리/돈) 수동 업데이트
                    const localCardIndex = playerInventory.findIndex(c => c.id === selectedTradeCardId);
                    if (localCardIndex > -1) playerInventory.splice(localCardIndex, 1);
                    playerCurrency -= 10;
                    
                    // 2. UI 갱신
                    updateUI(); 
selectedTradeCardId = null; 
document.getElementById('trade-selected-card-preview').classList.add('hidden'); 

// ✨ [수정] 옛날 입력창 초기화 코드를 지우고, 선택 상자들을 초기화합니다.
const baseSelect = document.getElementById('trade-target-basename');
if(baseSelect) baseSelect.value = ""; // 첫 번째 상자 초기화

const raritySelect = document.getElementById('trade-target-rarity-select');
if(raritySelect) {
    raritySelect.innerHTML = '<option value="">-</option>';
    raritySelect.disabled = true;
}

const specificSelect = document.getElementById('trade-target-specific-card');
if(specificSelect) {
    specificSelect.innerHTML = '<option value="">-</option>';
    specificSelect.disabled = true;
}

alert("거래가 등록되었습니다!");

// 3. '거래소 목록' 탭으로 화면 강제 전환
const marketTabBtn = document.getElementById('trade-sub-tab-market');
if(marketTabBtn) marketTabBtn.click();

                } catch (e) {
                    console.error(e);
                    alert("등록 실패: " + e);
                }
            });
        }

        // 6. 거래 목록 로드 함수 (내 거래도 표시됨)
        async function loadTradeList() {
    const container = document.getElementById('trade-list-container');
    if (!container) return;
    container.innerHTML = '<p class="text-white">로딩 중...</p>';

    // 상세 보기를 위해 현재 거래 데이터를 임시 저장
    window.currentMarketTrades = {}; 

    try {
        const snapshot = await db.collection('trades')
            .where('status', '==', 'active')
            .orderBy('createdAt', 'desc')
            .limit(20)
            .get();

        container.innerHTML = '';
        if (snapshot.empty) {
            container.innerHTML = '<p class="col-span-full text-center text-gray-500">등록된 거래가 없습니다.</p>';
            return;
        }

        snapshot.forEach(doc => {
            const trade = doc.data();
            const tradeId = doc.id;
            
            // 데이터 저장
            window.currentMarketTrades[tradeId] = trade.offeredCard;

            // ✨ [변수 정의] 여기서 'isMe'로 정의했습니다.
            const isMe = currentUser && trade.senderUid === currentUser.uid;
            
            const charData = findCharacter(trade.offeredCard.name);
            const imgUrl = charData ? charData.imageUrl : '';

            // 스타일 설정 (isMe 사용)
            const bgClass = isMe ? 'bg-blue-900/40 border-blue-500' : 'bg-gray-800 border-gray-600';

            // 희망 등급 뱃지
            let rarityBadge = '';
            if (trade.targetRarity && trade.targetRarity !== 'ALL') {
                const rColors = { 'N': 'bg-gray-500', 'R': 'bg-blue-600', 'SR': 'bg-purple-600', 'SSR': 'bg-yellow-500 text-black' };
                rarityBadge = `<span class="${rColors[trade.targetRarity]} text-white text-[10px] px-1.5 py-0.5 rounded ml-1 font-bold">${trade.targetRarity}</span>`;
            } else {
                rarityBadge = `<span class="bg-gray-600 text-white text-[10px] px-1.5 py-0.5 rounded ml-1">모든 등급</span>`;
            }

            // 자식 카드 유전자(🧬) 뱃지
            const isChild = trade.offeredCard.inherited ? true : false;
            const childBadge = isChild ? '<span class="absolute top-0 left-0 bg-pink-600 text-white text-[10px] font-bold px-1 py-0.5 rounded-br shadow-md z-20">🧬</span>' : '';

            const el = document.createElement('div');
            el.className = `${bgClass} p-3 rounded-lg border flex gap-3 items-center`;
            
            // ✨ [수정 완료] 아래쪽에서도 'isMyTrade' 대신 'isMe'를 사용하도록 고쳤습니다.
            el.innerHTML = `
                <div class="w-16 h-16 flex-shrink-0 relative cursor-pointer hover:scale-105 transition-transform" 
                     onclick="openTradeCardDetail('${tradeId}')" title="상세 정보 보기">
                    <img src="${imgUrl}" class="w-full h-full object-cover rounded border border-white/20">
                    ${isMe ? '<span class="absolute top-0 left-0 bg-blue-600 text-white text-[10px] px-1 font-bold z-10">ME</span>' : ''}
                    ${childBadge}
                </div>
                <div class="flex-grow">
                    <p class="text-yellow-300 font-bold text-sm">
                        ${trade.offeredCard.name} 
                        <span class="text-xs text-gray-400">(Lv.${trade.offeredCard.level})</span>
                    </p>
                    <p class="text-xs text-gray-400">From: ${trade.senderName}</p>
                    <div class="mt-1 text-white text-sm bg-black/30 p-1 rounded text-center">
                        구함: <span class="font-bold text-green-400">${trade.targetName}</span> ${rarityBadge}
                    </div>
                </div>
                <div class="flex flex-col gap-1">
                    ${isMe 
                        ? `<button onclick="cancelTrade('${tradeId}')" class="bg-red-500 hover:bg-red-600 text-white text-xs px-3 py-2 rounded">회수</button>`
                        : `<button onclick="executeTrade('${tradeId}', '${trade.targetName}', '${trade.targetRarity || 'ALL'}')" class="bg-blue-500 hover:bg-blue-600 text-white text-xs px-3 py-2 rounded font-bold">교환</button>`
                    }
                </div>
            `;
            container.appendChild(el);
        });
    } catch (e) {
        console.error(e);
        container.innerHTML = '<p class="text-red-400">목록 로드 실패</p>';
    }
}
        // 7. 내 거래 목록 (취소용)
        // [수정된 loadMyTrades 함수]
        async function loadMyTrades() {
            if (!currentUser) return;
            const list = document.getElementById('my-trade-list');
            if (!list) return;
            list.innerHTML = '<p class="text-gray-400 text-sm">로딩 중...</p>';
            
            try {
                // 'active' 상태와 'waiting_claim' 상태 모두 가져옴
                const snapshot = await db.collection('trades')
                    .where('senderUid', '==', currentUser.uid)
                    .orderBy('createdAt', 'desc') // 최신순
                    .get();

                list.innerHTML = '';
                
                // 아직 완료되지 않은(보상 미수령 포함) 거래만 필터링
                const activeTrades = snapshot.docs.filter(doc => {
                    const status = doc.data().status;
                    return status === 'active' || status === 'waiting_claim';
                });

                if(activeTrades.length === 0) {
                    list.innerHTML = '<p class="text-gray-500 text-sm">진행 중인 거래가 없습니다.</p>';
                    return;
                }

                activeTrades.forEach(doc => {
                    const trade = doc.data();
                    const div = document.createElement('div');
                    
                    // 상태에 따라 다른 디자인과 버튼 표시
                    if (trade.status === 'active') {
                        // 대기 중 -> 회수 버튼
                        div.className = 'flex justify-between items-center bg-gray-700 p-2 rounded mb-2 border border-gray-600';
                        div.innerHTML = `
                            <div>
                                <span class="text-white text-sm font-bold">등록 중</span>
                                <div class="text-xs text-gray-300">[${trade.offeredCard.name}] ↔ [${trade.targetName}]</div>
                            </div>
                            <button onclick="cancelTrade('${doc.id}')" class="bg-red-500 hover:bg-red-600 text-white text-xs px-2 py-1 rounded">회수</button>
                        `;
                    } else if (trade.status === 'waiting_claim') {
                        // 거래 성사됨 -> 수령 버튼 (✨중요)
                        div.className = 'flex justify-between items-center bg-green-900/50 p-2 rounded mb-2 border border-green-500';
                        div.innerHTML = `
                            <div>
                                <span class="text-green-400 text-sm font-bold">거래 성사!</span>
                                <div class="text-xs text-gray-200">${trade.buyerName || '누군가'}님과 교환됨</div>
                            </div>
                            <button onclick="receiveTradeItem('${doc.id}')" class="bg-blue-500 hover:bg-blue-600 text-white text-xs px-3 py-1 rounded animate-pulse font-bold">보상 수령</button>
                        `;
                    }
                    
                    list.appendChild(div);
                });
            } catch (e) {
                console.error(e);
                list.innerHTML = '<p class="text-red-400 text-sm">로드 실패 (콘솔 확인)</p>';
            }
        }

        // 1. 거래 버튼 클릭 시 실행 (카드 검색 및 분기 처리)
        window.executeTrade = function(tradeId, targetName, targetRarity) {
    // 헬퍼: 실제 등급 확인
    const getRealRarity = (card) => {
        if (card.inherited && card.inherited.originalRarity) {
            return card.inherited.originalRarity;
        }
        const char = findCharacter(card.name);
        return char ? char.rarity : 'N';
    };

    // 내가 가진 카드 중 조건에 맞는 것들을 모두 찾습니다.
    const candidates = playerInventory.filter(c => {
        const charData = findCharacter(c.name);
        if (!charData) return false;
        
        // 1. 이름 확인 (풀네임이 같거나, 베이스 이름이 같거나)
        const isNameMatch = (c.name === targetName) || (charData.baseName === targetName);
        if (!isNameMatch) return false;

        // 2. 덱에 있는 카드는 제외
        if (playerDeck.some(d => d.id === c.id)) return false;

        // 3. ✨ 등급 조건 확인 (실제 등급 사용)
        if (targetRarity && targetRarity !== 'ALL') {
            const myRarity = getRealRarity(c);
            if (myRarity !== targetRarity) return false;
        }
        
        return true;
    });

    // 경우의 수 처리
    if (candidates.length === 0) {
        return alert(`조건에 맞는 카드가 없습니다.\n(덱에 장착 중인 카드는 거래할 수 없습니다.)`);
    }
    
    if (candidates.length === 1) {
        // 1장뿐이면 바로 거래 진행
        confirmTradeTransaction(tradeId, candidates[0], targetName, targetRarity);
    } else {
        // 여러 장이면 선택 모달 띄우기
        openTradeSelectModal(tradeId, candidates, targetName, targetRarity);
    }
};

        // 2. 카드 선택 모달 열기 (개정 단계 표시 추가됨)
        function openTradeSelectModal(tradeId, candidates, targetName, targetRarity) {
    const modal = document.getElementById('trade-select-card-modal');
    const list = document.getElementById('trade-select-list');
    
    list.innerHTML = ''; 

    candidates.forEach(cardInstance => {
        const charData = findCharacter(cardInstance.name);
        const revision = cardInstance.revision || 0; 
        const stars = '⭐'.repeat(revision); 

        // ✨ 실제 등급 및 자식 여부 확인
        let displayRarity = charData.rarity;
        let isChild = false;
        if (cardInstance.inherited) {
            isChild = true;
            if (cardInstance.inherited.originalRarity) {
                displayRarity = cardInstance.inherited.originalRarity;
            }
        }

        const rarityColors = { 'N': 'bg-gray-500', 'R': 'bg-blue-600', 'SR': 'bg-purple-600', 'SSR': 'bg-yellow-500 text-black' };
        const badgeClass = rarityColors[displayRarity] || 'bg-gray-600';

        const cardEl = document.createElement('div');
        cardEl.className = 'relative bg-gray-700 p-2 rounded cursor-pointer hover:bg-gray-600 border border-gray-500 transition-transform hover:scale-105';
        
        cardEl.onclick = () => {
            document.getElementById('trade-select-card-modal').classList.add('hidden');
            confirmTradeTransaction(tradeId, cardInstance, targetName, targetRarity);
        };

        cardEl.innerHTML = `
            <div class="aspect-[2/3] overflow-hidden rounded mb-2 relative">
                <img src="${charData.imageUrl}" class="w-full h-full object-cover">
                
                ${isChild ? '<span class="absolute top-0 left-0 bg-pink-600 text-white text-[10px] font-bold px-1 py-0.5 rounded-br shadow-md z-10">🧬</span>' : ''}

                <span class="absolute bottom-0 right-0 bg-blue-600 text-white text-xs font-bold px-1.5 py-0.5 rounded-tl shadow-md z-10">
                    Lv.${cardInstance.level}
                </span>
                
                <span class="absolute top-0 right-0 ${badgeClass} text-white text-[10px] font-bold px-1.5 py-0.5 rounded-bl shadow-md z-10">
                    ${displayRarity}
                </span>

                <div class="absolute bottom-0 left-0 p-1 text-[10px] text-yellow-300 font-bold z-10" style="text-shadow: 1px 1px 2px black;">
                    ${stars}
                </div>
            </div>
            
            <p class="text-xs font-bold text-center text-white truncate">${cardInstance.name}</p>
        `;
        list.appendChild(cardEl);
    });

    modal.classList.remove('hidden');
}

        // 3. 실제 거래 트랜잭션 실행
        window.confirmTradeTransaction = async function(tradeId, myOfferCard, targetName, targetRarity) {
            const rarityMsg = (targetRarity && targetRarity !== 'ALL') ? `[${targetRarity}]` : '';
            
            // 어떤 카드를 보내는지 명확히 보여줌
            const msg = `나의 [${myOfferCard.name}] (Lv.${myOfferCard.level}) 카드를 보내시겠습니까?`;
            
            if (!confirm(msg)) return;

            const tradeRef = db.collection('trades').doc(tradeId);
            const buyerRef = db.collection('users').doc(currentUser.uid);
            let receivedCard = null;

            try {
                await db.runTransaction(async (transaction) => {
                    const tradeDoc = await transaction.get(tradeRef);
                    if (!tradeDoc.exists || tradeDoc.data().status !== 'active') throw "이미 완료되었거나 취소된 거래입니다.";
                    
                    receivedCard = tradeDoc.data().offeredCard;
                    const buyerDoc = await transaction.get(buyerRef);
                    const buyerInventory = buyerDoc.data().inventory || [];
                    
                    const cardIndex = buyerInventory.findIndex(c => c.id === myOfferCard.id);
                    if (cardIndex === -1) throw "카드를 찾을 수 없습니다.";

                    const newBuyerInventory = [...buyerInventory];
                    newBuyerInventory.splice(cardIndex, 1); 
                    newBuyerInventory.push(receivedCard);

                    transaction.update(buyerRef, { inventory: newBuyerInventory });
                    
                    transaction.update(tradeRef, { 
                        status: 'waiting_claim', 
                        receivedCard: myOfferCard, 
                        buyerUid: currentUser.uid,
                        buyerName: currentPlayerNickname,
                        completedAt: firebase.firestore.FieldValue.serverTimestamp()
                    });
                });

                // 로컬 데이터 갱신
                const localIndex = playerInventory.findIndex(c => c.id === myOfferCard.id);
                if(localIndex > -1) playerInventory.splice(localIndex, 1);
                if (receivedCard) playerInventory.push(receivedCard);

                alert(`거래 성공! [${receivedCard.name}] 획득!`);
                loadTradeList(); 

            } catch (e) {
                alert("거래 실패: " + e);
            }
        };

// ✨ [수정] 거래 취소 및 카드 회수 함수 (새로고침 없음)
        window.cancelTrade = async function(tradeId) {
            if(!confirm("거래를 취소하고 카드를 회수하시겠습니까?")) return;
            
            const tradeRef = db.collection('trades').doc(tradeId);
            const userRef = db.collection('users').doc(currentUser.uid);

            try {
                let returnedCard = null;

                await db.runTransaction(async (transaction) => {
                    const tradeDoc = await transaction.get(tradeRef);
                    if (!tradeDoc.exists) throw "거래가 존재하지 않습니다.";
                    
                    const data = tradeDoc.data();
                    if (data.status !== 'active') throw "이미 성사되었거나 취소된 거래입니다.";
                    if (data.senderUid !== currentUser.uid) throw "본인의 거래만 취소할 수 있습니다.";

                    returnedCard = data.offeredCard;

                    // 1. 내 DB 인벤토리에 카드 복구
                    const userDoc = await transaction.get(userRef);
                    const currentInventory = userDoc.data().inventory || [];
                    const newInventory = [...currentInventory, returnedCard];
                    
                    transaction.update(userRef, { inventory: newInventory });
                    
                    // 2. 거래 문서 삭제
                    transaction.delete(tradeRef);
                });

                // 3. 로컬 데이터(내 가방) 즉시 갱신
                if (returnedCard) {
                    playerInventory.push(returnedCard);
                }
                
                alert(`[${returnedCard.name}] 회수 완료!`);

                // 4. 화면 목록 갱신 (로딩 없이 즉시 반영)
                if (typeof loadTradeList === 'function') loadTradeList();       // 전체 목록 갱신
                if (typeof loadMyTrades === 'function') loadMyTrades();         // 내 거래 목록 갱신
                if (typeof loadTradeInventory === 'function') loadTradeInventory(); // 등록 화면 인벤토리 갱신

            } catch (e) {
                console.error(e);
                alert("회수 실패: " + e);
            }
        };
		
		
		// ================== 🤝 친구 시스템 (상호 수락 버전) ==================

// 1. 친구 요청 보내기 (중복 방지 안전장치 추가)
async function sendFriendRequest(targetUid, targetNickname) {
    if (!currentUser) return alert("로그인이 필요합니다.");
    
    try {
        // ✨ [핵심] 이미 친구인지 먼저 확인!
        const myCheck = await db.collection('users').doc(currentUser.uid).collection('friends').doc(targetUid).get();
        if (myCheck.exists) {
            const status = myCheck.data().status || 'accepted';
            if (status === 'accepted') return alert("이미 친구 사이입니다.");
            if (status === 'sent') return alert("이미 요청을 보낸 상태입니다.");
            if (status === 'received') return alert("상대방이 이미 요청을 보냈습니다. 받은 요청을 확인해주세요.");
        }

        const batch = db.batch();

        // 1. 내 친구 목록에 추가 (상태: sent)
        const myRef = db.collection('users').doc(currentUser.uid).collection('friends').doc(targetUid);
        batch.set(myRef, {
            nickname: targetNickname,
            status: 'sent',
            updatedAt: firebase.firestore.FieldValue.serverTimestamp()
        });

        // 2. 상대방 친구 목록에 추가 (상태: received)
        const theirRef = db.collection('users').doc(targetUid).collection('friends').doc(currentUser.uid);
        batch.set(theirRef, {
            nickname: currentPlayerNickname, 
            status: 'received',
			tutorialFinished: playerTutorialFinished, 
            updatedAt: firebase.firestore.FieldValue.serverTimestamp()
        });

        await batch.commit();
        
        alert(`[${targetNickname}]님에게 친구 요청을 보냈습니다!`);
        
        // UI 갱신 (프로필 창이 열려있다면 닫고, 친구 목록이 열려있다면 갱신)
        if (document.getElementById('other-user-profile-modal')) {
            document.getElementById('other-user-profile-modal').remove();
        }
        loadFriendList();

    } catch (error) {
        console.error("요청 실패:", error);
        alert("친구 요청 전송에 실패했습니다.");
    }
}

// 2. 친구 수락하기 (양쪽 모두 'accepted' 상태로 변경)
async function acceptFriendRequest(targetUid, targetNickname) {
    try {
        const batch = db.batch();

        // 내 상태 변경
        const myRef = db.collection('users').doc(currentUser.uid).collection('friends').doc(targetUid);
        batch.update(myRef, { status: 'accepted' });

        // 상대방 상태 변경
        const theirRef = db.collection('users').doc(targetUid).collection('friends').doc(currentUser.uid);
        batch.update(theirRef, { status: 'accepted' });

        await batch.commit();

        alert(`[${targetNickname}]님과 친구가 되었습니다!`);
        loadFriendList();

    } catch (error) {
        console.error("수락 실패:", error);
        alert("수락 중 오류가 발생했습니다.");
    }
}

// 3. 친구 삭제 / 요청 취소 / 거절 (양쪽 데이터 모두 삭제)
async function cancelFriendRequest(targetUid, targetNickname, isReject = false) {
    const msg = isReject ? '거절' : '삭제/취소';
    if (!confirm(`정말로 [${targetNickname}]님과의 관계를 ${msg}하시겠습니까?`)) return;

    try {
        const batch = db.batch();

        const myRef = db.collection('users').doc(currentUser.uid).collection('friends').doc(targetUid);
        batch.delete(myRef);

        const theirRef = db.collection('users').doc(targetUid).collection('friends').doc(currentUser.uid);
        batch.delete(theirRef);

        await batch.commit();

        alert("처리되었습니다.");
        loadFriendList();
        
        // 검색창이나 프로필이 열려있다면 갱신을 위해 닫기
        if (document.getElementById('other-user-profile-modal')) {
            document.getElementById('other-user-profile-modal').remove();
        }

    } catch (error) {
        console.error("삭제 실패:", error);
        alert("오류가 발생했습니다.");
    }
}

// [수정] 친구 목록 불러오기 (닉네임 클릭 시 프로필 연결 & UID 전달)
async function loadFriendList() {
    const friendContainer = document.getElementById('friend-list-container');
    const reqSection = document.getElementById('friend-request-section');
    const reqContainer = document.getElementById('friend-request-list');
    const reqCount = document.getElementById('request-count');

    if (!currentUser) return;
    
    friendContainer.innerHTML = '<p class="text-gray-500 text-center">로딩 중...</p>';

    try {
        const snapshot = await db.collection('users').doc(currentUser.uid).collection('friends').get();
        
        friendContainer.innerHTML = '';
        reqContainer.innerHTML = '';
        
        let friendCount = 0;
        let requestCount = 0;

        snapshot.forEach(doc => {
            const data = doc.data();
            const uid = doc.id; // ✨ 여기가 중요합니다! (문서 ID = 친구 UID)
            const status = data.status || 'accepted';

            // 1. 친구 요청 받은 경우
            if (status === 'received') {
                requestCount++;
                const div = document.createElement('div');
                div.className = 'flex justify-between items-center bg-pink-900/40 border border-pink-500/50 p-2 rounded-lg';
                div.innerHTML = `
                    <span class="font-bold text-white text-sm truncate w-24">${data.nickname}</span>
                    <div class="flex gap-1">
                        <button onclick="acceptFriendRequest('${uid}', '${data.nickname}')" class="bg-green-600 text-white text-xs px-2 py-1 rounded hover:bg-green-500">수락</button>
                        <button onclick="cancelFriendRequest('${uid}', '${data.nickname}', true)" class="bg-red-600 text-white text-xs px-2 py-1 rounded hover:bg-red-500">거절</button>
                    </div>
                `;
                reqContainer.appendChild(div);

            } 
            // 2. 이미 친구인 경우
            else if (status === 'accepted') {
                friendCount++;
                const div = document.createElement('div');
                div.className = 'flex justify-between items-center bg-gray-700 p-3 rounded-lg hover:bg-gray-600 transition-colors';
                
                // ✨ 닉네임 부분에 클릭 이벤트 추가 + UID 전달
                // onclick에서 openOtherUserProfile을 부를 때 uid: '${uid}'를 꼭 넣어야 합니다.
                div.innerHTML = `
                    <div class="flex items-center gap-3 cursor-pointer group" onclick="openOtherUserProfile({ nickname: '${data.nickname}', uid: '${uid}', representative: '${data.representative || ''}' })">
                        <div class="w-2 h-2 rounded-full bg-green-500 group-hover:bg-yellow-400 transition-colors"></div>
                        <span class="font-bold text-white group-hover:text-yellow-300 transition-colors">${data.nickname}</span>
                    </div>
                    <div class="flex gap-2">
                        <button onclick="visitFriendRoom('${uid}', '${data.nickname}')" class="bg-indigo-500 hover:bg-indigo-600 text-white text-xs px-3 py-2 rounded font-bold shadow">🏠</button>
                        <button onclick="deleteFriend('${uid}', '${data.nickname}')" class="bg-red-600 hover:bg-red-700 text-white text-xs px-3 py-2 rounded font-bold shadow">✂️</button>
                    </div>
                `;
                friendContainer.appendChild(div);
            }
        });

        if (requestCount > 0) {
            reqSection.classList.remove('hidden');
            reqCount.textContent = requestCount;
        } else {
            reqSection.classList.add('hidden');
        }

        if (friendCount === 0) {
            friendContainer.innerHTML = '<p class="text-gray-500 text-center mt-4 text-sm">등록된 친구가 없습니다.</p>';
        }

    } catch (e) {
        console.error(e);
        friendContainer.innerHTML = '<p class="text-red-400 text-center">목록 로드 실패</p>';
    }
}

// ✅ [디버깅 추가] 타 유저 프로필 모달
async function openOtherUserProfile(initialData) {
    const oldModal = document.getElementById('other-user-profile-modal');
    if (oldModal) oldModal.remove();

    let userData = initialData;
    
    try {
        document.body.style.cursor = 'wait';
        console.log(`🔍 [DEBUG] UID(${initialData.uid}) 데이터 불러오는 중...`);
        
        const doc = await db.collection('users').doc(initialData.uid).get();
        if (doc.exists) {
            const dbData = doc.data();
            
            // 🔥 [여기를 확인하세요] F12 콘솔에 이 로그가 뜰 겁니다.
            console.log("🔥 [DEBUG] 서버에서 받은 데이터:", dbData);
            console.log("📦 [DEBUG] 인벤토리 개수:", dbData.inventory ? dbData.inventory.length : "없음");
            console.log("👤 [DEBUG] 프로필 설정:", dbData.profile);

            userData = { ...initialData, ...dbData };
        } else {
            console.warn("⚠️ [DEBUG] 해당 유저의 데이터가 DB에 존재하지 않습니다.");
        }
    } catch (e) {
        console.error("프로필 정보 로드 실패:", e);
    } finally {
        document.body.style.cursor = 'default';
    }

    // -----------------------------------------------------------
    // ✨ [안전장치 추가] 헬퍼 함수 호출 전 데이터 정제
    // inventory가 null이거나 없으면 빈 배열로 만들어서 오류 방지
    if (!userData.inventory) userData.inventory = [];
    if (!userData.profile) userData.profile = { repCardId: null };
    // -----------------------------------------------------------

    const nickname = userData.nickname || "익명의 탐정";
    const statusMsg = (userData.profile && userData.profile.statusMessage) ? userData.profile.statusMessage : "등록된 한마디가 없습니다.";
    
    // 헬퍼 함수 호출
    const { imgUrl, cardName } = getUserRepInfo(userData);

    const isMe = (currentUser && userData.uid === currentUser.uid);
    
    const friendBtnHTML = isMe ? '' : `
        <button onclick="sendFriendRequest('${userData.uid}', '${nickname}')" class="flex-1 gacha-button bg-green-600 hover:bg-green-700 text-white py-3 rounded-lg font-bold text-lg shadow-lg transition-all border border-green-500">
            🤝 친구 추가
        </button>
    `;

    const modal = document.createElement('div');
    modal.id = 'other-user-profile-modal';
    modal.className = 'fixed inset-0 bg-black/80 flex items-center justify-center z-[100]';
    
    modal.innerHTML = `
        <div class="bg-gray-800 p-6 rounded-lg max-w-2xl w-full relative border border-gray-600 shadow-2xl mx-4 animate-fadeIn">
            <button onclick="document.getElementById('other-user-profile-modal').remove()" class="absolute top-3 right-4 text-gray-400 hover:text-white text-2xl">&times;</button>
            <h3 class="text-2xl font-bold text-yellow-300 mb-8 text-center">탐정 프로필</h3>
            
            <div class="flex flex-col md:flex-row gap-8 items-start">
                <div class="w-full md:w-1/2 flex flex-col items-center">
                    <div class="relative w-full max-w-[240px] aspect-[2/3] bg-black/30 rounded-lg overflow-hidden border-4 border-gray-700 shadow-xl mb-4 group">
                        <img src="${imgUrl}" class="w-full h-full object-cover">
                        <div class="absolute inset-0 bg-gradient-to-t from-black/60 via-transparent to-transparent pointer-events-none"></div>
                        <div class="absolute bottom-2 left-0 right-0 text-center">
                            <span class="inline-block bg-black/60 text-yellow-300 text-xs font-bold px-3 py-1 rounded-full border border-yellow-500/30">${cardName || '카드 정보 없음'}</span>
                        </div>
                    </div>
                </div>

                <div class="w-full md:w-1/2 flex flex-col justify-center space-y-6 py-2">
                    <div class="bg-black/20 p-4 rounded-lg border-l-4 border-indigo-500">
                        <p class="text-gray-400 text-xs font-bold mb-1 uppercase tracking-wider">Nickname</p>
                        <p class="text-white font-bold text-2xl tracking-tight">${nickname}</p>
                    </div>
                    <div>
                        <p class="text-gray-400 text-xs font-bold mb-2 uppercase tracking-wider ml-1">Status Message</p>
                        <div class="bg-black/30 p-6 rounded-xl text-gray-200 min-h-[120px] flex items-center justify-center relative border border-gray-700 shadow-inner">
                            <span class="text-6xl text-gray-700 absolute top-0 left-2 font-serif select-none leading-none">“</span>
                            <p class="italic px-4 break-words w-full text-center text-lg font-serif leading-relaxed z-10">${statusMsg}</p>
                            <span class="text-6xl text-gray-700 absolute bottom-[-10px] right-2 font-serif select-none leading-none">”</span>
                        </div>
                    </div>
                </div>
            </div>

            <div class="mt-8 flex gap-3">
                ${friendBtnHTML}
                <button onclick="document.getElementById('other-user-profile-modal').remove()" class="flex-1 gacha-button bg-gray-700 hover:bg-gray-600 text-white py-3 rounded-lg font-bold text-lg shadow-lg transition-all border border-gray-600">
                    닫기
                </button>
            </div>
        </div>
    `;
    document.body.appendChild(modal);
}
		

// [수정] 닉네임 검색 함수 (관계 상태에 따라 버튼 자동 변경)
async function searchUserByName() {
    const input = document.getElementById('friend-search-input');
    const resultBox = document.getElementById('friend-search-result');
    const resultAction = document.getElementById('search-result-action');
    const msg = document.getElementById('friend-search-msg');
    
    const nickname = input.value.trim();
    if (!nickname) return;

    msg.textContent = "검색 중...";
    resultBox.classList.add('hidden');

    try {
        const snapshot = await db.collection('users')
            .where('nickname', '==', nickname)
            .limit(1)
            .get();

        if (snapshot.empty) {
            msg.textContent = "해당 닉네임의 탐정을 찾을 수 없습니다.";
            return;
        }

        msg.textContent = "";
        const doc = snapshot.docs[0];
        const userData = doc.data();
        const uid = doc.id;
		const { imgUrl } = getUserRepInfo(userData);

        // --- ✨ [추가] 관계 상태 확인 로직 ---
        let relationStatus = 'none';
        if (currentUser && uid !== currentUser.uid) {
            const relDoc = await db.collection('users').doc(currentUser.uid).collection('friends').doc(uid).get();
            if (relDoc.exists) {
                relationStatus = relDoc.data().status || 'accepted';
            }
        }
        // -------------------------------------

    

        resultBox.classList.remove('hidden');
        
        // 박스 클릭 시 프로필 모달 열기
        resultBox.onclick = () => openOtherUserProfile({ ...userData, uid: uid });
        resultBox.classList.add('cursor-pointer', 'hover:bg-gray-700', 'transition-colors');

        document.getElementById('search-result-img').src = imgUrl;
        document.getElementById('search-result-name').textContent = userData.nickname;
        document.getElementById('search-result-msg').textContent = userData.profile?.statusMessage || "상태 메시지 없음";

        // 버튼 상태 분기 처리
        if (uid === currentUser.uid) {
            resultAction.innerHTML = `<span class="text-yellow-500 text-xs font-bold">나 (본인)</span>`;
            resultBox.onclick = null;
            resultBox.classList.remove('cursor-pointer', 'hover:bg-gray-700');
        } 
        else if (relationStatus === 'accepted') {
            // 이미 친구일 때 -> 방문 버튼 표시
            resultAction.innerHTML = `
                <button onclick="event.stopPropagation(); visitFriendRoom('${uid}', '${userData.nickname}')" class="gacha-button bg-indigo-500 hover:bg-indigo-600 text-white px-4 py-2 rounded-lg font-bold text-sm shadow-md">
                    🏠 방문
                </button>`;
        }
        else if (relationStatus === 'sent') {
            // 요청 보냄
            resultAction.innerHTML = `<span class="text-gray-400 text-xs font-bold">✉️ 요청함</span>`;
        }
        else if (relationStatus === 'received') {
            // 요청 받음 -> 수락 버튼
            resultAction.innerHTML = `
                <button onclick="event.stopPropagation(); acceptFriendRequest('${uid}', '${userData.nickname}')" class="gacha-button bg-green-500 hover:bg-green-600 text-white px-4 py-2 rounded-lg font-bold text-sm shadow-md animate-pulse">
                    ✅ 수락
                </button>`;
        }
        else {
            // 남남 -> 친구 추가 버튼
            resultAction.innerHTML = `
                <button onclick="event.stopPropagation(); sendFriendRequest('${uid}', '${userData.nickname}')" class="gacha-button bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-lg font-bold text-sm shadow-md">
                    친구 요청
                </button>`;
        }

    } catch (e) {
        console.error(e);
        msg.textContent = "검색 중 오류가 발생했습니다.";
    }
}


// ✅ [최종 수정] 친구 방 방문 함수 (내용물 직접 교체 방식)
let originalMyRoomData = null; // 내 방 데이터를 임시 저장할 변수

async function visitFriendRoom(targetUid, targetNickname) {
    if (typeof isEditMode !== 'undefined' && isEditMode) {
        toggleEditMode();
    }

    try {
        console.log(`[방문 시작] ${targetNickname} (${targetUid})`);

        // ✨ [추가 1] 방문 상태 설정
        currentVisitTargetUid = targetUid; 
        
        // ✨ [추가 2] 오늘 이 친구에게 이미 페이버를 했는지 DB에서 확인
        // (users/{내UID}/favorHistory/{친구UID} 문서를 확인)
        const todayStr = new Date().toDateString(); // 예: "Wed Dec 10 2025"
        const favorRef = db.collection('users').doc(currentUser.uid)
                           .collection('favorHistory').doc(targetUid);
        const favorDoc = await favorRef.get();
        
        if (favorDoc.exists && favorDoc.data().lastFavorDate === todayStr) {
            hasDoneFavorToday = true;
        } else {
            hasDoneFavorToday = false;
        }

        // --- (이 아래는 기존 로직과 동일) ---
        const doc = await db.collection('users').doc(targetUid).get();
        if (!doc.exists) {
            alert("존재하지 않는 유저입니다.");
            currentVisitTargetUid = null; // 실패 시 초기화
            return;
        }

        const friendData = doc.data();
        const friendInventory = friendData.inventory || []; 
        
        // 3. 친구 방 데이터 준비 (없으면 빈 방)
        let friendFurniture = [];
        let friendCharacters = [];

        if (friendData.myRoom) {
            // 가구 데이터 안전하게 가져오기
            if (Array.isArray(friendData.myRoom.furniture)) {
                friendFurniture = JSON.parse(JSON.stringify(friendData.myRoom.furniture));
            }

            // 캐릭터 데이터 안전하게 가져오기
            if (Array.isArray(friendData.myRoom.characters)) {
                // 저장된 ID 목록을 실제 캐릭터 객체로 변환
                friendCharacters = friendData.myRoom.characters
                    .map(id => friendInventory.find(c => c.id === id))
                    .filter(Boolean); // 유효하지 않은 카드 제거
            }
        }
        
        console.log(`[데이터 로드 완료] 가구: ${friendFurniture.length}개, 캐릭터: ${friendCharacters.length}명`);

        // 4. 내 방 데이터 백업 (아직 백업 안 했다면)
        if (!originalMyRoomData) {
            // 현재 playerRoom 상태를 깊은 복사로 백업
            originalMyRoomData = JSON.parse(JSON.stringify(playerRoom));
        }

        // ✨ [핵심 수정] 객체 자체를 바꾸지 않고, 속성만 친구 데이터로 덮어씁니다.
        // 이렇게 하면 참조 오류를 방지하고 확실하게 내용이 바뀝니다.
        playerRoom.furniture = friendFurniture;
        playerRoom.characters = friendCharacters;

        // 5. 화면 전환 및 렌더링
        switchTab('myroom');
        
        // 방문 모드 UI 표시
        const overlay = document.getElementById('visit-mode-overlay');
        if (overlay) overlay.classList.remove('hidden');
      
        // 수정/상점/보관함/입주관리 버튼 모두 숨기기
        const editBtn = document.getElementById('myroom-edit-mode');
        const shopBtn = document.getElementById('open-furniture-shop');
        const storageBtn = document.getElementById('open-furniture-storage');
        const charSelectorBtn = document.querySelector('button[onclick="openMyRoomCharacterSelector()"]');

        if (editBtn) editBtn.classList.add('hidden');
        if (shopBtn) shopBtn.classList.add('hidden');
        if (storageBtn) storageBtn.classList.add('hidden');
        if (charSelectorBtn) charSelectorBtn.classList.add('hidden');

        // 방 다시 그리기 (확실하게 비우고 다시 그림)
        const roomLayer = document.getElementById('room-layer');
        if (roomLayer) roomLayer.innerHTML = ''; 
        
        displayMyRoom(); // 여기서 UI가 갱신될 때 하트가 뜰지 말지 결정됨
        
        showMessage(`${targetNickname}님의 객실에 방문했습니다.`, 'text-indigo-300', messageArea);

    } catch (e) {
        console.error("방문 중 오류 발생:", e);
        alert(`방문에 실패했습니다. 오류: ${e.message}`);
        if (originalMyRoomData) exitVisitMode();
    }
}

// 5. 방문 종료 (내 방으로 돌아오기)
function exitVisitMode() {
    // ✨ [추가] 방문 변수 초기화
    currentVisitTargetUid = null;
    hasDoneFavorToday = false;

    if (originalMyRoomData) {
        playerRoom = originalMyRoomData; 
        originalMyRoomData = null;
    }
    
    // UI 복구
    document.getElementById('visit-mode-overlay').classList.add('hidden');
    document.getElementById('myroom-edit-mode').classList.remove('hidden');
    document.getElementById('open-furniture-shop').classList.remove('hidden');
    document.getElementById('open-furniture-storage').classList.add('hidden'); // 이건 원래 꺼져있음
	
	// ✨ [추가] 입주 관리 버튼 다시 보이기
    const charSelectorBtn = document.querySelector('button[onclick="openMyRoomCharacterSelector()"]');
    if(charSelectorBtn) charSelectorBtn.classList.remove('hidden');

    // 내 방 다시 그리기
    displayMyRoom();
    showMessage("나의 객실로 돌아왔습니다.", 'text-green-300', messageArea);
}

		
		// ================== 🏆 이벤트 랭킹 시스템 ==================
		
		

// 1. 랭킹 모달 열기 함수
// 1. 랭킹 모달 열기 (탭 기능 + 새로고침 버튼 추가)
async function openRankingModal() {
    let modal = document.getElementById('ranking-modal');
    
    // 모달이 없으면 HTML 새로 생성
    if (!modal) {
        modal = document.createElement('div');
        modal.id = 'ranking-modal';
        modal.className = 'fixed inset-0 bg-black/80 flex items-center justify-center z-50 hidden';
        modal.innerHTML = `
            <div class="bg-gray-800 p-6 rounded-lg max-w-md w-full relative border border-yellow-500">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-2xl font-bold text-yellow-300 ml-2">🏆 명예의 전당</h3>
                    <div class="flex gap-2">
                        <button onclick="refreshCurrentRanking()" class="text-sm bg-gray-600 hover:bg-gray-500 text-white px-3 py-1 rounded">🔄 갱신</button>
                        <button onclick="document.getElementById('ranking-modal').classList.add('hidden')" class="text-gray-400 hover:text-white text-2xl">&times;</button>
                    </div>
                </div>
                
                <div class="flex bg-black/40 rounded-lg p-1 mb-4">
                    <button id="rank-tab-event" onclick="switchRankingTab('event')" class="flex-1 py-2 rounded-md text-sm font-bold transition-all text-white bg-indigo-600">이벤트 P</button>
                    <button id="rank-tab-raid" onclick="switchRankingTab('raid')" class="flex-1 py-2 rounded-md text-sm font-bold transition-all text-gray-400 hover:text-white">레이드 Dmg</button>
                </div>

                <div class="flex justify-between items-center bg-gray-700/50 p-3 rounded-lg mb-4 border border-gray-600">
                    <span class="text-white font-bold text-sm" id="my-ranking-label">내 기록</span>
                    <span class="text-yellow-300 font-bold text-xl" id="my-ranking-score">-</span>
                </div>

                <div id="ranking-list" class="space-y-2 max-h-[50vh] overflow-y-auto bg-black/20 p-2 rounded-lg scrollbar-hide">
                    <p class="text-center text-gray-500 py-4">랭킹 데이터를 불러오는 중...</p>
                </div>
            </div>
        `;
        document.body.appendChild(modal);
    }
    
    modal.classList.remove('hidden');
    
    // 기본적으로 '이벤트' 탭을 엽니다.
    switchRankingTab('event');
}

// 2. 랭킹 탭 전환 함수 (신규 추가)
function switchRankingTab(type) {
    const eventBtn = document.getElementById('rank-tab-event');
    const raidBtn = document.getElementById('rank-tab-raid');
    const myLabel = document.getElementById('my-ranking-label');
    const myScore = document.getElementById('my-ranking-score');
    
    if (!eventBtn || !raidBtn) return;

    // 스타일 및 데이터 변경
    if (type === 'event') {
        eventBtn.className = "flex-1 py-2 rounded-md text-sm font-bold transition-all text-white bg-indigo-600 shadow-lg";
        raidBtn.className = "flex-1 py-2 rounded-md text-sm font-bold transition-all text-gray-400 hover:bg-white/10";
        
        if(myLabel) myLabel.textContent = "내 누적 포인트";
        if(myScore) myScore.textContent = `${(playerCumulativeEventPoints || 0).toLocaleString()} P`;
        
        loadEventRankingData();
        
    } else if (type === 'raid') {
        eventBtn.className = "flex-1 py-2 rounded-md text-sm font-bold transition-all text-gray-400 hover:bg-white/10";
        raidBtn.className = "flex-1 py-2 rounded-md text-sm font-bold transition-all text-white bg-red-600 shadow-lg";
        
        if(myLabel) myLabel.textContent = "내 누적 데미지";
        
        // ✨ [핵심 수정] 내 점수 표시 로직 (보스 시즌 체크)
        let displayDamage = playerRaidDamage || 0;
        if (raidBossData && playerLastRaidSpawnId !== raidBossData.spawnId) {
            displayDamage = 0;
        }

        if(myScore) myScore.textContent = `${displayDamage.toLocaleString()} Dmg`;
        
        loadRaidRankingData();
    }
}

// 3. 랭킹 새로고침 함수 (신규 추가)
function refreshCurrentRanking() {
    const eventBtn = document.getElementById('rank-tab-event');
    // 현재 활성화된 탭(파란색 버튼)이 무엇인지 확인하여 해당 랭킹을 다시 로드
    if (eventBtn && eventBtn.classList.contains('bg-indigo-600')) {
        loadEventRankingData(); 
    } else {
        loadRaidRankingData();
    }
}

// 전역 스코프에 함수 등록 (HTML에서 onclick으로 찾을 수 있게 함)
window.openRankingModal = openRankingModal;
window.switchRankingTab = switchRankingTab;
window.refreshCurrentRanking = refreshCurrentRanking;



// ✅ [수정됨] 이벤트 랭킹 로드 함수 (프로필 카드 적용 완료)
async function loadEventRankingData() {
    const listContainer = document.getElementById('ranking-list');
    
    try {
        // Firestore 쿼리 (변동 없음)
        const snapshot = await db.collection('users')
            .where('currentEventId', '==', CURRENT_EVENT_ID)
            .orderBy('cumulativeEventPoints', 'desc')
            .limit(20)
            .get();

        listContainer.innerHTML = '';
        
        if (snapshot.empty) {
            listContainer.innerHTML = '<p class="text-center text-gray-500">아직 랭킹 데이터가 없습니다.</p>';
            return;
        }

        let rank = 1;
        snapshot.forEach(doc => {
            const data = doc.data();
            const isMe = (currentUser && doc.id === currentUser.uid);
            
            // ---------------------------------------------------------
            // ✨ [핵심 수정] 기존의 복잡한 이미지 확인 로직을 
            // 헬퍼 함수 호출 한 줄로 대체합니다.
            // (이 함수가 '프로필 카드' -> '대표 캐릭터' 순으로 알아서 찾아줍니다)
            // ---------------------------------------------------------
            const { imgUrl } = getUserRepInfo(data); 

            const div = document.createElement('div');
            
            // 랭킹 스타일 설정 (변동 없음)
            let rankStyle = 'bg-gray-700 border-gray-600';
            let rankBadge = `<span class="font-bold w-6 text-center text-gray-400">${rank}</span>`;
            
            if (rank === 1) {
                rankStyle = 'bg-yellow-900/40 border-yellow-500';
                rankBadge = '🥇';
            } else if (rank === 2) {
                rankStyle = 'bg-gray-400/20 border-gray-400';
                rankBadge = '🥈';
            } else if (rank === 3) {
                rankStyle = 'bg-orange-900/40 border-orange-500';
                rankBadge = '🥉';
            }

            if (isMe) rankStyle += ' ring-2 ring-blue-500';

            // 클릭 이벤트 및 스타일
            div.className = `flex items-center gap-3 p-2 rounded border ${rankStyle} cursor-pointer hover:bg-white/10 transition-colors relative group`;
            div.onclick = () => openOtherUserProfile({ ...data, uid: doc.id });
            
            div.innerHTML = `
                <div class="text-xl">${rankBadge}</div>
                
                <img src="${imgUrl}" class="w-10 h-10 rounded object-cover bg-black border border-white/20">
                
                <div class="flex-grow">
                    <p class="text-sm font-bold text-white truncate max-w-[120px]">
                        ${data.nickname || '익명의 탐정'}
                    </p>
                    ${isMe ? '<span class="text-[10px] bg-blue-600 text-white px-1 rounded">ME</span>' : ''}
                </div>
                <div class="text-right">
                    <p class="text-yellow-300 font-bold text-sm">${(data.cumulativeEventPoints || 0).toLocaleString()} P</p>
                </div>
            `;
            listContainer.appendChild(div);
            rank++;
        });

    } catch (error) {
        console.error("랭킹 로드 실패:", error);
        
        if (error.message.includes('index')) {
             listContainer.innerHTML = `
                <div class="text-red-400 text-center text-sm p-2">
                    <p class="font-bold">⚠️ 시스템 설정 필요</p>
                    <p>개발자 콘솔(F12)을 열어 Firestore 인덱스 생성 링크를 클릭해주세요.</p>
                </div>
            `;
        } else {
             listContainer.innerHTML = '<p class="text-center text-red-500">랭킹을 불러오지 못했습니다.</p>';
        }
    }
}

// [추가] 이벤트 홈 화면에 TOP 3를 보여주는 함수
async function loadRankingPreview() {
    const container = document.getElementById('ranking-preview-container');
    if (!container) return;

    try {
        // Top 3 데이터 가져오기
        const snapshot = await db.collection('users')
            .where('currentEventId', '==', CURRENT_EVENT_ID)
            .orderBy('cumulativeEventPoints', 'desc')
            .limit(3)
            .get();

        container.innerHTML = '';

        if (snapshot.empty) {
            container.innerHTML = '<p class="text-center text-gray-500 text-sm py-2">아직 랭킹 데이터가 없습니다.</p>';
            return;
        }

        // 메달 및 스타일 설정 (금, 은, 동)
        const medals = ['🥇', '🥈', '🥉'];
        const borderColors = ['border-yellow-500', 'border-gray-400', 'border-orange-500'];
        const bgColors = ['bg-yellow-900/40', 'bg-gray-700/40', 'bg-orange-900/40'];
        const textColors = ['text-yellow-300', 'text-gray-300', 'text-orange-300'];

        let rank = 0;
        snapshot.forEach(doc => {
            const data = doc.data();
			const { imgUrl } = getUserRepInfo(data);
            const nickname = data.nickname || "익명의 탐정";
            const score = (data.cumulativeEventPoints || 0).toLocaleString();

            const el = document.createElement('div');
            el.className = `flex items-center justify-between p-2 rounded border ${borderColors[rank] || 'border-gray-700'} ${bgColors[rank] || 'bg-gray-800'}`;
            
            el.innerHTML = `
                <div class="flex items-center gap-2 overflow-hidden">
                    <span class="text-xl">${medals[rank]}</span>
                    <span class="font-bold text-white text-sm truncate max-w-[120px]">${nickname}</span>
                </div>
                <span class="font-bold ${textColors[rank] || 'text-white'} text-sm">${score} P</span>
            `;
            container.appendChild(el);
            rank++;
        });

        // 3명 미만일 경우 빈 칸 채우기 (선택사항)
        for (let i = rank; i < 3; i++) {
            const el = document.createElement('div');
            el.className = `flex items-center justify-between p-2 rounded border border-dashed border-gray-600 bg-white/5 opacity-50`;
            el.innerHTML = `
                <div class="flex items-center gap-2">
                    <span class="text-xl grayscale">${medals[i]}</span>
                    <span class="text-gray-400 text-sm">-</span>
                </div>
                <span class="text-gray-500 text-sm">0 P</span>
            `;
            container.appendChild(el);
        }

    } catch (e) {
        console.error("Top 3 로드 실패:", e);
        // 인덱스 에러 방지를 위해 조용히 실패 처리
        container.innerHTML = '<p class="text-center text-red-400 text-xs py-2">로딩 실패</p>';
    }
}
		
		// ✨ [신규] 판매자가 맡겨진 카드를 수령하는 함수
        window.receiveTradeItem = async function(tradeId) {
            const tradeRef = db.collection('trades').doc(tradeId);
            const userRef = db.collection('users').doc(currentUser.uid);

            try {
                let receivedCard = null;

                await db.runTransaction(async (transaction) => {
                    const tradeDoc = await transaction.get(tradeRef);
                    if (!tradeDoc.exists) throw "거래 정보가 없습니다.";
                    
                    const data = tradeDoc.data();
                    if (data.status !== 'waiting_claim') throw "수령할 수 없는 상태입니다.";
                    if (data.senderUid !== currentUser.uid) throw "본인의 거래가 아닙니다.";

                    receivedCard = data.receivedCard;

                    // 내 인벤토리에 카드 추가
                    const userDoc = await transaction.get(userRef);
                    const newInventory = [...(userDoc.data().inventory || []), receivedCard];

                    transaction.update(userRef, { inventory: newInventory });
                    
                    // 거래 완전 종료 처리 (삭제하거나 completed로 변경)
                    transaction.update(tradeRef, { status: 'completed' });
                });

                alert(`[${receivedCard.name}] 수령 완료!`);
                
                // 로컬 갱신
                playerInventory.push(receivedCard);
                loadMyTrades(); // 목록 갱신

            } catch (e) {
                console.error(e);
                alert("수령 실패: " + e);
            }
        };
		
		window.searchUserByName = searchUserByName;
    window.loadFriendList = loadFriendList;
    window.visitFriendRoom = visitFriendRoom;
    window.exitVisitMode = exitVisitMode;
    window.openOtherUserProfile = openOtherUserProfile;
    
    // 👇 새로 만든 상호 작용 함수들 등록
    window.sendFriendRequest = sendFriendRequest;
    window.acceptFriendRequest = acceptFriendRequest;
    window.cancelFriendRequest = cancelFriendRequest;
	window.deleteFriend = cancelFriendRequest;
	
	// ✨ [신규] 거래소 알림 리스너 (수령 대기 중인 거래가 있으면 배지 표시)
function startTradeListener(uid) {
    db.collection('trades')
      .where('senderUid', '==', uid)           // 내가 보낸 거래 중
      .where('status', '==', 'waiting_claim')  // '수령 대기' 상태인 것만 감시
      .onSnapshot(snapshot => {
          const badge = document.getElementById('trade-badge');
          const count = snapshot.size; // 대기 중인 거래 개수

          if (badge) {
              if (count > 0) {
                  badge.classList.remove('hidden'); // 배지 보이기
                  badge.textContent = count;        // 개수 표시 (1, 2...)
              } else {
                  badge.classList.add('hidden');    // 배지 숨기기
              }
          }
      });
}
	
	// ✨ 친구 요청 실시간 감시 함수
    function startFriendListener(uid) {
        db.collection('users').doc(uid).collection('friends')
          .where('status', '==', 'received') // '받음' 상태인 요청만 감시
          .onSnapshot(snapshot => {
              const count = snapshot.size; // 요청 개수
              const badge = document.getElementById('main-friend-badge');
              
              if (badge) {
                  if (count > 0) {
                      badge.classList.remove('hidden'); // 배지 보이기
                      badge.textContent = count;
                  } else {
                      badge.classList.add('hidden'); // 배지 숨기기
                  }
              }

              // 만약 현재 '친구 탭'을 보고 있다면 목록도 즉시 새로고침
              const friendsView = document.getElementById('friends-view');
              if (friendsView && !friendsView.classList.contains('hidden')) {
                  loadFriendList();
              }
          });
    }
	
	// ✨ 업적 배지 업데이트 함수
    function updateAchievementBadge() {
        // 'unlocked' 상태인(달성했지만 보상 안 받은) 업적 개수 세기
        let count = 0;
        
        // 전역 변수 achievements 배열을 순회
        achievements.forEach(ach => {
            // playerAchievements 객체에 해당 ID가 있고, 상태가 'unlocked'이면 카운트
            if (playerAchievements[ach.id] === 'unlocked') {
                count++;
            }
        });

        const badge = document.getElementById('achievement-badge');
        if (badge) {
            if (count > 0) {
                badge.textContent = count;
                badge.classList.remove('hidden'); // 배지 보이기
            } else {
                badge.classList.add('hidden');    // 배지 숨기기
            }
        }
    }
	
	// ================== ✨ 마이룸 입주 관리 시스템 ✨ ==================

let tempMyRoomChars = new Set(); // 선택 중인 캐릭터 ID 임시 저장

// 1. 입주 관리 모달 열기
function openMyRoomCharacterSelector() {
    const modal = document.getElementById('myroom-char-selector-modal');
    const list = document.getElementById('myroom-char-list');
    
    // 현재 설정된 입주민 목록을 임시 저장소에 복사
    tempMyRoomChars = new Set(playerRoom.characters || []);
    
    // 유효성 검사: 인벤토리에 없는 카드 ID(파쇄됨)는 제거
    tempMyRoomChars.forEach(id => {
        if (!playerInventory.some(c => c.id === id)) tempMyRoomChars.delete(id);
    });

    updateMyRoomSelectorUI(); // 화면 그리기
    modal.classList.remove('hidden');
}

let currentMyRoomFilter = 'All';

// [수정됨] 입주민 선택창 UI 그리기 (캐릭터별 정렬 적용)
function updateMyRoomSelectorUI() {
    const list = document.getElementById('myroom-char-selector-modal').querySelector('#myroom-char-list');
    const countSpan = document.getElementById('myroom-selected-count');
    
    list.innerHTML = '';
    countSpan.textContent = `${tempMyRoomChars.size} / 5`;

    // 1. 필터링 (선택된 등급만 남기기)
    const filteredInv = playerInventory.filter(cardInstance => {
        if (currentMyRoomFilter === 'All') return true;
        const charData = findCharacter(cardInstance.name);
        return charData && charData.rarity === currentMyRoomFilter;
    });

    if (filteredInv.length === 0) {
        list.innerHTML = `<p class="col-span-full text-center text-gray-500 py-10">해당 등급의 방문객이 없습니다.</p>`;
        return;
    }

    // 2. ✨ 정렬 로직 변경 (캐릭터 이름 -> 등급 -> 레벨)
    const sortedInv = [...filteredInv].sort((a, b) => {
        const charA = findCharacter(a.name);
        const charB = findCharacter(b.name);
        
        // 안전장치
        if (!charA) return 1;
        if (!charB) return -1;

        // [1순위] 캐릭터 기본 이름(BaseName)으로 묶기 (가나다순)
        const nameComparison = charA.baseName.localeCompare(charB.baseName);
        if (nameComparison !== 0) return nameComparison;

        // [2순위] 등급 높은 순 (SSR > SR > R > N)
        const rarityOrder = { 'SSR': 4, 'SR': 3, 'R': 2, 'N': 1 };
        const rA = rarityOrder[charA.rarity] || 0;
        const rB = rarityOrder[charB.rarity] || 0;
        if (rA !== rB) return rB - rA;

        // [3순위] 레벨 높은 순
        return b.level - a.level;
    });

    // 3. 카드 생성
    sortedInv.forEach(cardInstance => {
        const charData = findCharacter(cardInstance.name);
        if (!charData) return;

        const isSelected = tempMyRoomChars.has(cardInstance.id);
        
        const cardEl = document.createElement('div');
        cardEl.className = `relative cursor-pointer border-2 rounded-lg p-1 transition-all ${isSelected ? 'border-pink-500 bg-pink-900/40' : 'border-transparent bg-black/40 hover:bg-white/10'}`;
        
        // 클릭 시 토글
        cardEl.onclick = () => toggleMyRoomChar(cardInstance.id);

        cardEl.innerHTML = `
            <div class="aspect-[2/3] overflow-hidden rounded mb-1 relative pointer-events-none">
                <img src="${charData.imageUrl}" class="w-full h-full object-cover ${isSelected ? '' : 'opacity-70'}">
                ${isSelected ? '<div class="absolute inset-0 border-4 border-pink-500 rounded"></div><span class="absolute top-0 right-0 bg-pink-500 text-white text-xs font-bold px-1.5 py-0.5">V</span>' : ''}
                <span class="absolute bottom-0 right-0 bg-black/60 text-white text-[10px] px-1 rounded-tl">${charData.rarity}</span>
            </div>
            <p class="text-[10px] text-center text-white truncate">${cardInstance.name}</p>
        `;
        list.appendChild(cardEl);
    });
}

// 3. 캐릭터 선택/해제 토글
function toggleMyRoomChar(cardId) {
    if (tempMyRoomChars.has(cardId)) {
        tempMyRoomChars.delete(cardId);
    } else {
        if (tempMyRoomChars.size >= 5) {
            alert("최대 5명까지만 방문할 수 있습니다.");
            return;
        }
        tempMyRoomChars.add(cardId);
    }
    updateMyRoomSelectorUI(); // 화면 갱신
}

// 4. 저장하기
function saveMyRoomCharacters() {
    // 임시 선택 목록을 실제 데이터에 반영 (배열로 변환)
    playerRoom.characters = Array.from(tempMyRoomChars);
    
    saveGame();
    displayMyRoom(); // 마이룸 즉시 새로고침 (캐릭터 변경 반영)
    
    document.getElementById('myroom-char-selector-modal').classList.add('hidden');
    alert("방문객 명단이 갱신되었습니다!");
}

// ✨ HTML 버튼에서 함수를 찾을 수 있도록 window에 등록
window.openMyRoomCharacterSelector = openMyRoomCharacterSelector;
window.saveMyRoomCharacters = saveMyRoomCharacters;

// ================== 📩 우편함(Mailbox) 시스템 시작 ==================

// 1. 우편함 열기
function openMailbox() {
    if (!currentUser) return alert("로그인이 필요합니다.");
    
    const modal = document.getElementById('mailbox-modal');
    if (modal) {
        modal.classList.remove('hidden');
        loadMailboxList();
    } else {
        console.error("우편함 모달(mailbox-modal)을 찾을 수 없습니다. HTML을 확인해주세요.");
    }
}

// 2. 우편 목록 로드
async function loadMailboxList() {
    const listContainer = document.getElementById('mailbox-list');
    if (!listContainer) return;
    
    listContainer.innerHTML = '<p class="text-center text-gray-500 mt-10">우편을 불러오는 중...</p>';

    try {
        const snapshot = await db.collection('users').doc(currentUser.uid)
            .collection('mailbox')
            .orderBy('createdAt', 'desc')
            .get();

        listContainer.innerHTML = '';

        if (snapshot.empty) {
            listContainer.innerHTML = `
                <div class="flex flex-col items-center justify-center h-full text-gray-500 gap-2 py-10">
                    <span class="text-4xl">📭</span>
                    <p>우편함이 비어있습니다.</p>
                </div>`;
            return;
        }

        snapshot.forEach(doc => {
            const mail = doc.data();
            const mailId = doc.id;
            
            // 보상 텍스트 생성
            let rewardText = [];
            if (mail.rewards) {
                if (mail.rewards.currency) rewardText.push(`💎 ${mail.rewards.currency}`);
                if (mail.rewards.fountainPens) rewardText.push(`🖋️ ${mail.rewards.fountainPens}`);
                if (mail.rewards.inkwells) rewardText.push(`💧 ${mail.rewards.inkwells}`);
                if (mail.rewards.cardName) rewardText.push(`🃏 ${mail.rewards.cardName}`);
                if (mail.rewards.customItem) rewardText.push(`🎁 ${mail.rewards.customItem}`);
            }
            const rewardString = rewardText.length > 0 ? rewardText.join(' / ') : '안내 메시지';

            // 날짜 포맷
            const date = mail.createdAt ? new Date(mail.createdAt.toDate()).toLocaleDateString() : '';

            const div = document.createElement('div');
            div.className = 'bg-gray-700/80 p-4 rounded-lg border border-gray-600 flex flex-col sm:flex-row justify-between items-start sm:items-center gap-3 shadow-md hover:bg-gray-700 transition-colors mb-2';
            div.innerHTML = `
                <div class="flex-1">
                    <div class="flex items-center gap-2 mb-1">
                        <span class="bg-indigo-500 text-white text-[10px] px-1.5 py-0.5 rounded font-bold">SYSTEM</span>
                        <h4 class="font-bold text-white text-lg">${mail.title}</h4>
                    </div>
                    <p class="text-sm text-gray-300 mb-2 leading-relaxed whitespace-pre-wrap">${mail.content}</p>
                    <div class="bg-black/30 px-3 py-1.5 rounded inline-block">
                        <span class="text-yellow-300 font-bold text-sm">보상: ${rewardString}</span>
                    </div>
                    <p class="text-[10px] text-gray-500 mt-1">${date}</p>
                </div>
                <button onclick="claimMail('${mailId}')" class="gacha-button bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-6 rounded-full shadow-lg whitespace-nowrap self-end sm:self-center shrink-0">
                    받기
                </button>
            `;
            listContainer.appendChild(div);
        });

    } catch (e) {
        console.error(e);
        listContainer.innerHTML = '<p class="text-center text-red-400">목록 로드 실패</p>';
    }
}

// 3. 우편 받기 (단일)
async function claimMail(mailId) {
    if (!currentUser) return;

    const userRef = db.collection('users').doc(currentUser.uid);
    const mailRef = userRef.collection('mailbox').doc(mailId);

    try {
        await db.runTransaction(async (transaction) => {
            const mailDoc = await transaction.get(mailRef);
            if (!mailDoc.exists) throw "이미 받거나 삭제된 우편입니다.";
            
            const userData = (await transaction.get(userRef)).data();
            const mailData = mailDoc.data();
            const rewards = mailData.rewards || {};

            // 1. 재화 지급
            let newCurrency = (userData.currency || 0) + (rewards.currency || 0);
            let newPens = (userData.fountainPens || 0) + (rewards.fountainPens || 0);
            let newInk = (userData.inkwells || 0) + (rewards.inkwells || 0);
            
            // 2. 카드 지급
            let newInventory = [...(userData.inventory || [])];
            if (rewards.cardName) {
                // 새 카드 객체 생성
                const newCard = {
                    id: Date.now().toString(36) + Math.random().toString(36).substr(2),
                    name: rewards.cardName,
                    level: 0,
                    revision: 0
                };
                newInventory.push(newCard);
            }

            // 3. DB 업데이트
            transaction.update(userRef, {
                currency: newCurrency,
                fountainPens: newPens,
                inkwells: newInk,
                inventory: newInventory
            });

            // 4. 우편 삭제
            transaction.delete(mailRef);

            // 5. 로컬 데이터 동기화
            playerCurrency = newCurrency;
            playerFountainPens = newPens;
            playerInkwells = newInk;
            playerInventory = newInventory;
            if (rewards.cardName) {
                collectedCardNames.add(rewards.cardName);
                // saveGameToFirebase(); // 트랜잭션 밖에서 저장되므로 생략 가능하나 안전하게 호출 가능
            }
        });

        alert("보상을 수령했습니다!");
        updateUI(); 
        loadMailboxList(); 
        saveGame(); // 로컬 변경사항 최종 저장

    } catch (e) {
        console.error(e);
        alert("수령 실패: " + e);
    }
}

// 4. 모두 받기
async function claimAllMails() {
    const list = document.getElementById('mailbox-list');
    const buttons = list ? list.querySelectorAll('button') : [];
    
    if (buttons.length === 0) return alert("수령할 우편이 없습니다.");
    if (!confirm(`총 ${buttons.length}개의 우편을 모두 받으시겠습니까?`)) return;

    const snapshot = await db.collection('users').doc(currentUser.uid).collection('mailbox').get();
    
    let successCount = 0;
    for (const doc of snapshot.docs) {
        try {
            await claimMail(doc.id);
            successCount++;
        } catch(e) {
            console.error("개별 수령 실패", e);
        }
    }
}

// 5. 우편함 실시간 감시 (배지용)
function startMailListener(uid) {
    db.collection('users').doc(uid).collection('mailbox')
      .onSnapshot(snapshot => {
          const count = snapshot.size;
          const badge = document.getElementById('mail-badge');
          if (badge) {
              if (count > 0) {
                  badge.classList.remove('hidden');
                  badge.textContent = count > 99 ? '99+' : count;
              } else {
                  badge.classList.add('hidden');
              }
          }
          
          // 우편함 창이 열려있다면 목록도 갱신
          const modal = document.getElementById('mailbox-modal');
          if (modal && !modal.classList.contains('hidden')) {
              loadMailboxList(); 
          }
      });
}
window.openMailbox = openMailbox;
    window.claimMail = claimMail;
    window.claimAllMails = claimAllMails;

// ================== 📩 우편함 시스템 끝 ==================



async function checkAndProcessSystemMails(uid) {
    const now = new Date();
    const batch = db.batch();
    const userRef = db.collection('users').doc(uid);
    let newMailCount = 0;

    // 1. 시트에 있는 모든 메일을 순회
    systemMails.forEach(mail => {
        // (A) 기간 체크
        if (now < mail.startDate || now > mail.endDate) return;

        // (B) 타겟 체크 (ALL 이거나 내 UID여야 함)
        if (mail.target !== 'ALL' && mail.target !== uid) return;

        // (C) 이미 받은 메일인지 체크 (History 배열 확인)
        if (playerSystemMailHistory.includes(mail.id)) return;

        // --- 조건 만족! 받을 메일임 ---
        
        // 2. Firebase 우편함에 추가
        const newMailRef = userRef.collection('mailbox').doc(); // 자동 ID 생성
        batch.set(newMailRef, {
            title: mail.title,
            content: mail.content,
            rewards: mail.rewards,
            createdAt: firebase.firestore.FieldValue.serverTimestamp(),
            fromSystemId: mail.id // 추적용 ID
        });

        // 3. 로컬 기록 및 카운트 업데이트
        playerSystemMailHistory.push(mail.id);
        newMailCount++;
    });

    // 4. 받을 메일이 있다면 DB에 한꺼번에 저장 (Batch)
    if (newMailCount > 0) {
        // 유저 정보에 '수령 기록(systemMailHistory)' 업데이트
        batch.update(userRef, { 
            systemMailHistory: playerSystemMailHistory 
        });

        try {
            await batch.commit();
            console.log(`📭 시스템 우편 ${newMailCount}개가 도착했습니다!`);
            
            // 배지 알림 갱신을 위해 리스너가 작동하겠지만, 즉각 반응을 위해 알림 띄우기
            // (toastNotification이 있다면 활용)
            const toast = document.getElementById('toast-notification');
            if(toast) {
                toast.textContent = `📩 새로운 운영자 우편이 ${newMailCount}통 도착했습니다!`;
                toast.classList.remove('hidden');
                setTimeout(() => toast.classList.add('hidden'), 3000);
            }
        } catch (e) {
            console.error("시스템 우편 동기화 실패:", e);
        }
    }
}
// ✅ [신규] 1분마다 구글 시트를 확인해서 새 우편이 있으면 배달하는 함수
function startPeriodicMailCheck(uid) {
    // 이미 타이머가 돌고 있다면 중복 실행 방지
    if (window.mailCheckInterval) clearInterval(window.mailCheckInterval);

    console.log("📮 자동 우편 체크 시스템이 가동되었습니다. (1분 주기)");

    window.mailCheckInterval = setInterval(async () => {
        if (!uid) return;
        
        try {
            // 1. 구글 시트 데이터 몰래 새로고침
            const response = await fetch(GOOGLE_SHEET_URL);
            const data = await response.json();
            
            // 날짜 변환 헬퍼 (내부용)
            const parseDate = (dateStr) => {
                if (!dateStr) return null;
                return new Date(String(dateStr).replace(' ', 'T'));
            };

            // 2. 전역 변수 업데이트
            if (data.systemMails) {
                systemMails = data.systemMails.map(row => ({
                    id: row.id,
                    target: row.target,
                    title: row.title,
                    content: row.content,
                    rewards: row.rewards ? JSON.parse(row.rewards) : {},
                    startDate: parseDate(row.startDate),
                    endDate: parseDate(row.endDate)
                }));
            }

            // 3. 내 우편함과 비교해서 안 받은 거 넣기
            await checkAndProcessSystemMails(uid);
            
        } catch (e) {
            console.warn("자동 우편 체크 중 오류(네트워크 등):", e);
        }
    }, 60 * 1000); // 60초(1분) 마다 실행
}
// yumecan.html - <script> 섹션 (loadRaidRankingData 함수 근처에 추가)

// ✅ [수정됨] 레이드 랭킹 프리뷰 (Top 5, 현재 보스 시즌 필터링)
async function loadRaidRankingPreview() {
    // 현재 이벤트 ID가 없거나, 보스 데이터가 로드되지 않았으면 중단
    if (!CURRENT_EVENT_ID || !raidBossData) return;
    
    const container = document.getElementById('raid-ranking-preview-container');
    if (!container) return;

    container.innerHTML = '<p class="text-center text-gray-500 py-2">순위 불러오는 중...</p>';

    try {
        // ✨ [핵심] 현재 보스 ID(lastRaidSpawnId)와 일치하는 기록만 가져옴
        const snapshot = await db.collection('users')
            .where('currentEventId', '==', CURRENT_EVENT_ID)
            .where('lastRaidSpawnId', '==', raidBossData.spawnId) // 필터 추가
            .orderBy('raidCumulativeDamage', 'desc')
            .limit(5) 
            .get();
        
        container.innerHTML = '';

        if (snapshot.empty) {
            container.innerHTML = '<p class="text-center text-gray-500 text-sm py-2">아직 참여 기록이 없습니다.</p>';
            return;
        }

        let rank = 1;
        snapshot.forEach(doc => {
            const data = doc.data();
            const isMe = (currentUser && doc.id === currentUser.uid);
            
            const score = (data.raidCumulativeDamage || 0).toLocaleString();
            
            const div = document.createElement('div');
            
            // 랭킹별 스타일 설정
            const rankStyle = rank === 1 ? 'border-yellow-400 bg-yellow-900/30' : (isMe ? 'border-blue-500 bg-blue-900/30' : 'border-gray-700 bg-black/30');

            div.className = `flex justify-between items-center p-3 rounded-lg border ${rankStyle}`;
            
            // 랭크 배지 설정
            let rankBadge = rank === 1 ? '🥇' : (rank === 2 ? '🥈' : (rank === 3 ? '🥉' : rank));

            div.innerHTML = `
                <div class="flex items-center gap-3">
                    <span class="font-bold text-lg text-yellow-300 w-6 text-center">${rankBadge}</span>
                    <span class="font-bold text-white truncate max-w-[150px]">${data.nickname || '익명의 탐정'}</span>
                </div>
                <span class="font-bold text-red-300 text-sm">${score} DAM</span>
            `;
            container.appendChild(div);
            rank++;
        });

    } catch (e) {
        console.error("레이드 랭킹 프리뷰 로드 실패:", e);
        
        // 인덱스 에러가 발생해도 프리뷰 영역은 조용히 실패 메시지만 띄움
        if (e.message.includes('index')) {
            container.innerHTML = '<p class="text-center text-red-400 text-xs py-2">시스템: 인덱스 생성 필요 (F12 확인)</p>';
        } else {
            container.innerHTML = '<p class="text-center text-red-400 text-xs py-2">로딩 실패</p>';
        }
    }
}

// ================== 👇 레이드 시스템 로직 시작 👇 ==================


// 1. 이벤트 탭 전환 기능 (레이드 탭 포함)

// 레이드 탭 버튼 클릭 시
eventSubTabRaid.addEventListener('click', () => {
    // 탭 UI 전환
    displayEventView(); // 다른 뷰 숨기기 위한 헬퍼 함수 호출 (기존 함수 재활용)
    switchSubTab(document.getElementById('event-view'), eventSubTabRaid);
    
    // 레이드 뷰 보이기
    document.getElementById('event-raid-view').classList.remove('hidden');
    
    // 데이터 리스너 시작
    initRaidListener();
});

// 이벤트 홈 -> 레이드 입장 버튼 클릭 시
document.getElementById('goto-event-raid').addEventListener('click', () => {
    document.getElementById('event-home-view').classList.add('hidden');
    document.getElementById('event-view').classList.remove('hidden');
    
    // 레이드 탭 활성화
    displayEventView(); // 초기화
    switchSubTab(document.getElementById('event-view'), eventSubTabRaid);
    document.getElementById('event-raid-view').classList.remove('hidden');
    
    initRaidListener();
});

// 2. Firebase 실시간 리스너
function initRaidListener() {
    if (raidUnsubscribe) return; // 이미 실행 중이면 패스

    // 'system' 컬렉션의 'raid_boss' 문서를 구독
    raidUnsubscribe = db.collection('system').doc('raid_boss')
        .onSnapshot((doc) => {
            if (doc.exists) {
                raidBossData = doc.data();
                updateRaidUI();
            } else {
                console.log("보스 데이터가 없습니다.");
            }
        });
}

// 3. UI 업데이트
// yumecan.html - updateRaidUI 함수 전체를 이 코드로 교체하세요 (7979행 근처)
function updateRaidUI() {
    if (!raidBossData) return;
    
    const nameEl = document.getElementById('raid-boss-name');
    const imgEl = document.getElementById('raid-boss-image');
    const hpBar = document.getElementById('raid-boss-hp-bar');
    const hpText = document.getElementById('raid-boss-hp-text');
    // ✅ [수정] 버튼 ID를 raid-start-btn으로 변경
    const btn = document.getElementById('raid-start-btn'); 

    nameEl.textContent = `Lv.${raidBossData.level} ${raidBossData.name}`;
    imgEl.src = raidBossData.imageUrl;
    
    // HP 퍼센트 계산
    const percent = Math.max(0, (raidBossData.currentHp / raidBossData.maxHp) * 100);
    hpBar.style.width = `${percent}%`;
    hpText.textContent = `${raidBossData.currentHp.toLocaleString()} / ${raidBossData.maxHp.toLocaleString()}`;

    // 보스 처치 상태 처리
    if (btn) { // ✅ [안전장치] 버튼 요소가 존재하는지 먼저 확인
        if (raidBossData.currentHp <= 0) {
            btn.disabled = true;
            btn.textContent = "토벌 완료";
            btn.classList.add('bg-gray-600', 'cursor-not-allowed');
            btn.classList.remove('bg-red-600', 'hover:bg-red-700');
            imgEl.style.filter = "grayscale(100%) opacity(0.6)";
            nameEl.textContent += " (격파됨)";
        } else {
            // 레이드 횟수 제한 로직은 updateRaidDailyCountUI가 처리해야 하지만, 
            // 기본 스타일은 여기서 설정해 둡니다.
            if (!btn.disabled) {
                btn.classList.remove('bg-gray-600', 'cursor-not-allowed');
                btn.classList.add('bg-red-600', 'hover:bg-red-700');
                btn.textContent = "⚔️ 전투 개시";
            }
            imgEl.style.filter = "none";
        }
    }
    
    // ✅ [추가] 레이드 횟수 UI도 업데이트합니다.
    updateRaidDailyCountUI(); 
    loadRaidRankingPreview();
}

// 4. 전투 시작 트리거
function startRaidBattle() {
// 🔒 레이드 입장 제한
    // ✅ [수정] 제한 체크를 여기서 먼저 실행합니다.
    if (playerRaidDailyCount >= 5) { 
        alert("⚠️ 오늘의 레이드 참여 횟수를 모두 사용했습니다.\n내일 다시 도전해주세요!");
        return;
    }
    if (!raidBossData || raidBossData.currentHp <= 0) return alert("전투 가능한 보스가 없습니다.");
    if (playerDeck.length < 5) return alert("덱에 5명의 탐정을 모두 편성해야 합니다.");
    
    // 레이드 모드로 전투 시작
    startCombat(null, 'raid');
}
window.startRaidBattle = startRaidBattle;

// ✨ [신규] 이벤트 랭킹 보상 분배 함수 (종료된 이벤트 처리)
async function distributeEventRewards(eventId, eventTitle) {
    console.log(`🎁 [${eventTitle}] 랭킹 보상 분배 시작...`);
    
    try {
        // 1. 해당 이벤트의 참가자 명단 가져오기 (이벤트 포인트 순)
        // (주의: 이미 종료된 이벤트라 currentEventId가 바뀌었을 수 있지만, 
        //  DB에는 기록이 남아있다고 가정하고 쿼리합니다.)
        const snapshot = await db.collection('users')
            .where('currentEventId', '==', eventId)
            .orderBy('cumulativeEventPoints', 'desc') // 누적 포인트 기준
            .limit(500) 
            .get();

        if (snapshot.empty) {
            console.log("참여자가 없어 보상을 분배하지 않습니다.");
            return;
        }

        const batch = db.batch();
        let count = 0;
        let currentRank = 1; 

        // 2. 순위별 우편 생성
        snapshot.docs.forEach(doc => {
            const userData = doc.data();
            
            // 포인트가 없는 유저 제외
            if (!userData.cumulativeEventPoints || userData.cumulativeEventPoints <= 0) return;

            const rank = currentRank++;
            let rewardData = null;

            if (rank === 1) rewardData = EVENT_RANK_REWARDS[1];
            else if (rank === 2) rewardData = EVENT_RANK_REWARDS[2];
            else if (rank === 3) rewardData = EVENT_RANK_REWARDS[3];
            else if (rank <= 10) rewardData = EVENT_RANK_REWARDS.top10;
            else if (rank <= 50) rewardData = EVENT_RANK_REWARDS.top50;
            else rewardData = EVENT_RANK_REWARDS.participation;

            const mailRef = db.collection('users').doc(doc.id).collection('mailbox').doc();
            const scoreStr = userData.cumulativeEventPoints.toLocaleString();

            batch.set(mailRef, {
                title: `[이벤트 종료] ${eventTitle}`,
                content: `${eventTitle} 이벤트가 종료되었습니다.\n당신의 최종 순위는 ${rank}위 입니다.\n(누적 포인트: ${scoreStr} P)`,
                rewards: {
                    currency: rewardData.currency,
                    fountainPens: rewardData.fountainPens
                },
                createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                fromSystem: true
            });
            count++;
        });

        // 3. 일괄 전송
        await batch.commit();
        console.log(`✅ [${eventTitle}] 총 ${count}명에게 랭킹 보상 발송 완료.`);
        
        // (운영자/최초 접속자에게만 보이는 메시지)
        showMessage(`지난 이벤트 [${eventTitle}]의 보상 정산이 완료되었습니다.`, "text-yellow-300", messageArea);

    } catch (e) {
        console.error("이벤트 보상 분배 중 오류:", e);
        if (e.message.includes('index')) {
            alert("시스템 오류: 이벤트 랭킹 인덱스 생성 필요 (콘솔 확인)");
        }
    }
}

		// ✅ [신규] 유저의 대표 정보(이미지, 이름)를 결정하는 헬퍼 함수
// (프로필 설정 카드 우선 -> 없으면 메인 홈 캐릭터 사용)
function getUserRepInfo(userData) {
    let imgUrl = "https://placehold.co/50x50/333/fff?text=?";
    let cardName = "";

    // 1순위: 프로필 메뉴에서 설정한 카드 (repCardId)
    // 인벤토리 정보가 있어야 찾을 수 있습니다.
    if (userData.profile && userData.profile.repCardId && userData.inventory) {
        const profileCard = userData.inventory.find(c => c.id === userData.profile.repCardId);
        if (profileCard) {
            const charData = findCharacter(profileCard.name);
            if (charData) {
                return { 
                    imgUrl: charData.imageUrl, 
                    cardName: `[${charData.rarity}] ${charData.name}` 
                };
            }
        }
    }

    // 2순위: 메인 홈 캐릭터 (representative)
    if (userData.representative) {
        const charData = findCharacter(userData.representative);
        if (charData) {
            return { 
                imgUrl: charData.imageUrl, 
                cardName: `[${charData.rarity}] ${charData.name}` 
            };
        }
    }

    // 정보 없음
    return { imgUrl, cardName };
}

// ================== 💡 교배(영감) 시스템 로직 시작 ==================

function displayBreedingView() {
    renderBreedingSlots();
    renderBreedingInventory();
    updateBreedingUI();
}

// 슬롯 렌더링
function renderBreedingSlots() {
    ['a', 'b'].forEach(slot => {
        const container = document.getElementById(`breeding-slot-${slot}`);
        const cardId = breedingSlots[slot];
        
        container.innerHTML = '';
        
        if (cardId) {
            const cardInstance = playerInventory.find(c => c.id === cardId);
            if (!cardInstance) {
                breedingSlots[slot] = null; // 없는 카드면 초기화
                return renderBreedingSlots();
            }
            const charData = findCharacter(cardInstance.name);
            
            // 카드 생성 (버튼 없는 모드)
            const cardEl = createCard(charData, { instance: cardInstance, mode: 'default' });
			cardEl.classList.add('w-full', 'h-full', 'overflow-hidden');
            cardEl.style.pointerEvents = 'none'; // 클릭 이벤트 방지 (슬롯 클릭이 우선)
            
            container.appendChild(cardEl);
            container.classList.remove('border-dashed');
            container.classList.add('border-solid', 'bg-white/5');
            
            // 해제 안내
            const tip = document.createElement('div');
            tip.className = "absolute inset-0 flex items-center justify-center bg-black/60 text-red-400 font-bold opacity-0 hover:opacity-100 transition-opacity rounded-lg z-20";
            tip.innerText = "클릭하여 해제";
            container.appendChild(tip);
        } else {
            container.innerHTML = `<span class="text-gray-500 text-sm pointer-events-none">선택 대기</span>`;
            container.classList.add('border-dashed');
            container.classList.remove('border-solid', 'bg-white/5');
        }
    });
}

// 인벤토리 렌더링 (교배용)
function renderBreedingInventory() {
    const container = document.getElementById('breeding-inventory-container');
    container.innerHTML = '';

    // 필터링: 덱에 없고 & 이미 슬롯에 선택되지 않은 카드
    const availableCards = playerInventory.filter(card => {
        const inDeck = playerDeck.some(d => d.id === card.id);
        const isSelected = (breedingSlots.a === card.id || breedingSlots.b === card.id);
        return !inDeck && !isSelected;
    });

    // 정렬 (등급 > 레벨) + ✨[안전장치 추가]✨
    availableCards.sort((a, b) => {
        const charA = findCharacter(a.name);
        const charB = findCharacter(b.name);

        // 🛡️ 데이터가 없는 유령 카드는 맨 뒤로 보냄 (에러 방지)
        if (!charA && !charB) return 0;
        if (!charA) return 1;
        if (!charB) return -1;

        // 등급 가중치가 없으면 0으로 처리
        const rA = (RARITY_STATS_WEIGHT && RARITY_STATS_WEIGHT[charA.rarity]) ? RARITY_STATS_WEIGHT[charA.rarity] : 0;
        const rB = (RARITY_STATS_WEIGHT && RARITY_STATS_WEIGHT[charB.rarity]) ? RARITY_STATS_WEIGHT[charB.rarity] : 0;
        
        return (rB - rA) || (b.level - a.level);
    });

    if (availableCards.length === 0) {
        container.innerHTML = '<p class="col-span-full text-center text-gray-500 py-4">사용 가능한 원고가 없습니다.<br>(편찬에 등록된 카드는 제외됩니다)</p>';
        return;
    }

    availableCards.forEach(cardInstance => {
        const charData = findCharacter(cardInstance.name);
        
        // 🛡️ 데이터 없는 카드는 화면에 그리지 않음
        if (!charData) return;

        const cardEl = createCard(charData, { instance: cardInstance, mode: 'default' });
        
        // 클릭 시 빈 슬롯 등록
        cardEl.onclick = () => selectBreedingCard(cardInstance.id);
        cardEl.classList.add('hover:scale-105', 'transition-transform');
        
        container.appendChild(cardEl);
    });
}

// 카드 선택
function selectBreedingCard(cardId) {
    if (!breedingSlots.a) breedingSlots.a = cardId;
    else if (!breedingSlots.b) breedingSlots.b = cardId;
    else {
        // 둘 다 찼으면 A를 밀어내고 B->A, New->B (큐 방식) 또는 A 교체
        breedingSlots.a = breedingSlots.b;
        breedingSlots.b = cardId;
    }
    displayBreedingView();
}

// 슬롯 비우기
function clearBreedingSlot(slot) {
    if (breedingSlots[slot]) {
        breedingSlots[slot] = null;
        displayBreedingView();
    }
}

// UI 업데이트 (비용, 확률 표시)
function updateBreedingUI() {
    const btn = document.getElementById('btn-execute-breeding');
    const predictionEl = document.getElementById('breeding-prediction');
    // 비용 표시 요소 찾기 (HTML 구조에 맞춰 첫번째 p 태그 선택)
    const costTextEl = document.querySelector('#breeding-view .bg-black\\/40 p:first-child');
    
    const isReady = breedingSlots.a && breedingSlots.b;
    let costDisplayHtml = `필요한 영감: <span class="text-gray-500">등급별 상이</span>`;

    if (isReady) {
        const cardA = playerInventory.find(c => c.id === breedingSlots.a);
        const cardB = playerInventory.find(c => c.id === breedingSlots.b);
        const charA = findCharacter(cardA.name);
        const charB = findCharacter(cardB.name);
        
        // [규칙] 등급 체크
        if (charA.rarity !== charB.rarity) {
            predictionEl.textContent = "⚠️ 등급이 서로 다릅니다. 같은 등급만 가능합니다.";
            predictionEl.className = "text-red-400 text-sm font-bold mb-4";
            btn.disabled = true;
            btn.textContent = "조건 불충족";
            btn.classList.add('opacity-50', 'cursor-not-allowed');
            if(costTextEl) costTextEl.innerHTML = costDisplayHtml;
            return;
        }

        // 비용 계산
        const cost = BREEDING_COSTS[charA.rarity];
        costDisplayHtml = `필요한 영감 (${charA.rarity}): <span class="text-yellow-300 font-bold">💎 ${cost.gem}</span> + <span class="text-gray-300 font-bold">🖋️ ${cost.pen}</span>`;
        if(costTextEl) costTextEl.innerHTML = costDisplayHtml;

        // 확률 메시지
        const rarityIdx = RARITY_ORDER.indexOf(charA.rarity);
        let nextMsg = "";
        if (charA.rarity === 'N') {
            nextMsg = "100% 확률로 [N] 등급 유지";
        } else {
            const lowerRarity = RARITY_ORDER[rarityIdx - 1];
            nextMsg = `50% [${charA.rarity}] 유지 / 50% [${lowerRarity}] 하락`;
        }

        predictionEl.textContent = `📊 예상 결과: ${nextMsg}`;
        predictionEl.className = "text-green-400 text-sm font-bold mb-4";
        
        // 재화 체크
        const canAfford = playerCurrency >= cost.gem && playerFountainPens >= cost.pen;

        if (canAfford) {
            btn.disabled = false;
            btn.textContent = "💡 구상 시작";
            btn.classList.remove('opacity-50', 'cursor-not-allowed');
        } else {
            btn.disabled = true;
            btn.textContent = "재화 부족";
            btn.classList.add('opacity-50', 'cursor-not-allowed');
        }
    } else {
        predictionEl.textContent = "같은 등급의 모티브 두 가지를 선택해주세요.";
        predictionEl.className = "text-gray-500 text-sm mb-4";
        btn.disabled = true;
        btn.textContent = "모티브 선택 필요";
        btn.classList.add('opacity-50', 'cursor-not-allowed');
        if(costTextEl) costTextEl.innerHTML = costDisplayHtml;
    }
}

// [핵심] 교배 실행 함수
function executeBreeding() {
    if (!breedingSlots.a || !breedingSlots.b) return;

    const instanceA = playerInventory.find(c => c.id === breedingSlots.a);
    const instanceB = playerInventory.find(c => c.id === breedingSlots.b);
    const charA = findCharacter(instanceA.name);
    const charB = findCharacter(instanceB.name);

    // 등급 체크
    if (charA.rarity !== charB.rarity) return alert("같은 등급끼리만 가능합니다.");

    // 비용 체크
    const cost = BREEDING_COSTS[charA.rarity];
    if (playerCurrency < cost.gem || playerFountainPens < cost.pen) {
        return alert(`재화가 부족합니다.\n(필요: 💎${cost.gem}, 🖋️${cost.pen})`);
    }

    if (!confirm(`[${charA.rarity} 등급 구상]\n💎${cost.gem}, 🖋️${cost.pen}을 소모하여 진행하시겠습니까?`)) return;

    // 1. 재화 소모
    playerCurrency -= cost.gem;
    playerFountainPens -= cost.pen;

    // 2. 결과 등급 결정 (50% 확률로 하락)
    const parentRarity = charA.rarity;
    let childRarity = parentRarity;
    let statMultiplier = 1.0; 
    let rarityChangeMsg = "(등급 유지)";

    const rarityIdx = RARITY_ORDER.indexOf(parentRarity);
    if (rarityIdx > 0) { // N등급은 하락 없음
        if (Math.random() < 0.5) {
            childRarity = RARITY_ORDER[rarityIdx - 1];
            
            const parentWeight = RARITY_STATS_WEIGHT[parentRarity];
            const childWeight = RARITY_STATS_WEIGHT[childRarity];
            statMultiplier = childWeight / parentWeight; // 예: 45/70 = 0.64
            
            rarityChangeMsg = "📉 등급 하락 (능력치 조정됨)";
        }
    }

    // 3. 유전 적용
    // 법칙 1: 캐릭터(외형/대사)는 교배원1(A)
    const childName = charA.name;   
    
    // 법칙 2: 진영은 교배원2(B)
    const childFaction = charB.faction; 

    // 법칙 3: 스탯 유전 (HP/DEF: A우세, ATK: B우세)
    const HIGH_CHANCE = 0.7;
    const baseStatsA = charA.stats;
    const baseStatsB = charB.stats;

    let rawHp = (Math.random() < HIGH_CHANCE) ? baseStatsA.hp : baseStatsB.hp;
    let rawDef = (Math.random() < HIGH_CHANCE) ? baseStatsA.def : baseStatsB.def;
    let rawAtk = (Math.random() < HIGH_CHANCE) ? baseStatsB.atk : baseStatsA.atk;

    // 등급 하락 시 스탯 페널티 적용
    const childHp = Math.floor(rawHp * statMultiplier);
    const childDef = Math.floor(rawDef * statMultiplier);
    const childAtk = Math.floor(rawAtk * statMultiplier);

    // 법칙 4: 스킬 섞기
    const allSkills = [...charA.skills, ...charB.skills];
    const uniqueSkillsMap = new Map();
    allSkills.forEach(s => uniqueSkillsMap.set(s.name, s));
    const uniqueSkills = Array.from(uniqueSkillsMap.values());
    
    // 셔플
    for (let i = uniqueSkills.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [uniqueSkills[i], uniqueSkills[j]] = [uniqueSkills[j], uniqueSkills[i]];
    }
    const childSkills = uniqueSkills.slice(0, 2);

    // 4. 자식 카드 생성 (inherited 속성 추가)
    const newCard = {
        id: generateUniqueId(),
        name: childName,
        level: 0,
        revision: 0,
        inherited: {
            faction: childFaction,
            stats: { hp: childHp, atk: childAtk, def: childDef },
            skills: childSkills,
            originalRarity: childRarity,
            // ✨ [핵심 추가] 부모(모티브)의 이름을 족보에 기록합니다!
            parents: [charA.name, charB.name] 
        }
    };

    // 5. 저장
    playerInventory.push(newCard);
    if(typeof collectedCardNames !== 'undefined') collectedCardNames.add(childName);

    saveGame();
    updateUI();
    
    breedingSlots = { a: null, b: null };
    displayBreedingView();

    // 6. 결과 알림
    alert(`💡 구상 완료! ${rarityChangeMsg}\n\n[${childRarity}] ${childName}\n진영: ${childFaction}\nHP: ${childHp} / ATK: ${childAtk} / DEF: ${childDef}`);
    
    if(confirm("서고에서 확인하시겠습니까?")) {
        switchTab('inventory');
    }
}

		// [신규] 거래소 카드 상세 정보 보기 (미리보기 모드)
function openTradeCardDetail(tradeId) {
    // 1. 임시 저장된 데이터에서 카드 정보 가져오기
    const cardInstance = window.currentMarketTrades[tradeId];
    if (!cardInstance) {
        console.error("카드 정보를 찾을 수 없습니다.");
        return;
    }

    const character = findCharacter(cardInstance.name);
    // getEnhancedStats 함수는 원래 인벤토리에 있는 카드용이지만, 객체 구조가 같으므로 재사용 가능
    const currentStats = getEnhancedStats(cardInstance);

    // --- 기본 정보 표시 ---
    document.getElementById('detail-card-image').src = character.imageUrl;
    document.getElementById('detail-card-name').textContent = character.name;
    const rarityEl = document.getElementById('detail-card-rarity');
    
    // 등급 결정 (유전된 등급 우선)
    let displayRarity = character.rarity;
    if (cardInstance.inherited && cardInstance.inherited.originalRarity) {
        displayRarity = cardInstance.inherited.originalRarity;
    }
    
    rarityEl.textContent = displayRarity;
    const rarityColor = { 'N': 'text-gray-400', 'R': 'text-blue-400', 'SR': 'text-purple-400', 'SSR': 'text-yellow-400' }[displayRarity];
    rarityEl.className = `font-bold text-2xl ${rarityColor}`;
    
    // 진영 표시
    let displayFaction = character.faction;
    if (cardInstance.inherited && cardInstance.inherited.faction) {
        displayFaction = cardInstance.inherited.faction;
    }
    
    const factionEl = document.getElementById('detail-card-faction');
    factionEl.textContent = displayFaction;
    const factionColors = { 
        '탐정': 'bg-blue-500 text-white', '조수': 'bg-green-500 text-white', '범인': 'bg-red-500 text-white',
        '히어로': 'bg-indigo-600 text-white', '빌런': 'bg-gray-800 text-white', '마법사': 'bg-purple-600 text-white',
        '초대객': 'bg-orange-400 text-white', '도박사': 'bg-yellow-600 text-white', '사제': 'bg-teal-500 text-white', '악마': 'bg-rose-900 text-white'
    };
    factionEl.className = `font-bold text-lg px-3 py-1 rounded-full ${factionColors[displayFaction] || 'bg-gray-500'}`;

    // --- 부모 정보 표시 (자식 카드일 경우) ---
    const parentsWrapper = document.getElementById('detail-parents-wrapper');
    const parentsContainer = document.getElementById('detail-parents-container');
    
    if (cardInstance.inherited && cardInstance.inherited.parents && Array.isArray(cardInstance.inherited.parents)) {
        parentsContainer.innerHTML = '';
        cardInstance.inherited.parents.forEach((parentName, idx) => {
            const parentChar = findCharacter(parentName);
            const imgUrl = parentChar ? parentChar.imageUrl : 'https://placehold.co/50x50/333/fff?text=?';
            const rColor = parentChar ? ({ 'N':'border-gray-500', 'R':'border-blue-500', 'SR':'border-purple-500', 'SSR':'border-yellow-400' }[parentChar.rarity]) : 'border-gray-600';

            const parentHtml = `
                <div class="flex flex-col items-center group relative" title="부모 정보">
                    <div class="relative w-12 h-12">
                        <img src="${imgUrl}" class="w-full h-full rounded-full border-2 ${rColor} object-cover shadow-md">
                    </div>
                    <span class="text-[10px] text-gray-300 mt-1 font-bold">${parentName}</span>
                </div>
            `;
            
            if (idx > 0) {
                const plusSign = document.createElement('div');
                plusSign.className = "text-gray-500 text-xl font-bold";
                plusSign.innerText = "+";
                parentsContainer.appendChild(plusSign);
            }
            
            const wrapper = document.createElement('div');
            wrapper.innerHTML = parentHtml;
            parentsContainer.appendChild(wrapper.firstElementChild);
        });
        if(parentsWrapper) parentsWrapper.classList.remove('hidden');
    } else {
        if(parentsWrapper) parentsWrapper.classList.add('hidden');
    }

    // --- 능력치 표시 ---
    document.getElementById('detail-stat-hp').textContent = currentStats.hp;
    document.getElementById('detail-stat-atk').textContent = currentStats.atk;
    document.getElementById('detail-stat-def').textContent = currentStats.def;

    // --- 스킬 표시 (유전 스킬 포함) ---
    const skillsContainer = document.getElementById('detail-skills-container');
    skillsContainer.innerHTML = '';
    const displaySkills = (cardInstance.inherited && cardInstance.inherited.skills) ? cardInstance.inherited.skills : character.skills;

    displaySkills.forEach((skill, index) => {
        const isUltimate = displayRarity === 'SSR' && index === 1;
        const skillEl = document.createElement('div');
        skillEl.className = 'bg-black/20 p-3 rounded-lg';
        
        const description = skill.desc ? skill.desc : getSkillDescription(skill);

        skillEl.innerHTML = `
            <h4 class="font-bold ${isUltimate ? 'text-yellow-300' : 'text-white'}">
                ${isUltimate ? '궁극기' : '일반 스킬'}: ${skill.name}
            </h4>
            <p class="text-gray-300 italic">"${skill.dialogue || '...'}"</p>
            <p class="text-sm mt-1 text-green-300">${description}</p>
        `;
        skillsContainer.appendChild(skillEl);
    });

    // --- ✨ 거래소 미리보기 전용 UI 처리 (버튼 숨기기) ---
    // 내 카드가 아니므로 수정/강화 불가능하게 UI를 조정합니다.
    document.getElementById('enhancement-container').classList.add('hidden');
    document.getElementById('revision-container').classList.add('hidden');
    document.getElementById('publication-container').classList.add('hidden');
    document.getElementById('dismantle-container').classList.add('hidden');
    
    // 스토리 영역도 필요하다면 채워줍니다 (선택 사항)
    currentStoryPages = character.story ? character.story.split('[PAGE_BREAK]') : ['스토리가 없습니다.'];
    currentStoryPageIndex = 0;
    displayCardStoryPage();
    document.getElementById('detail-card-story-container').classList.remove('hidden');

    // 모달 열기
    document.getElementById('card-detail-modal').classList.remove('hidden');
}

// 전역 등록
window.openTradeCardDetail = openTradeCardDetail;

		// [수정됨] 도감으로 이동하여 해당 캐릭터 정보를 보여주는 함수
function showCollectionCardDetails(targetName) {
    // 1. 캐릭터 데이터 찾기
    const charData = findCharacter(targetName);
    
    if (!charData) {
        console.error("캐릭터를 찾을 수 없습니다:", targetName);
        return;
    }

    // 2. 도감 탭으로 화면 전환
    switchTab('collection');

    // 3. 해당 캐릭터의 그룹(기수)을 찾아서 탭 전환 (선택 사항)
    // 캐릭터 프로필에 그룹 정보가 있다면 해당 그룹 탭을 먼저 엽니다.
    const profile = characterProfiles[charData.baseName];
    if (profile && profile.group && typeof currentCollectionGroup !== 'undefined') {
        currentCollectionGroup = profile.group;
        // 도감 목록 갱신 (그룹 탭 반영을 위해)
        if (typeof displayCollectionView === 'function') {
            displayCollectionView();
        }
    }

    // 4. 도감 내부에서 해당 캐릭터의 상세 정보 열기
    // (기존에 작성된 displayCharacterDetail 함수 활용)
    if (typeof displayCharacterDetail === 'function') {
        // 약간의 지연을 주어 탭 전환 후 부드럽게 열리도록 함
        setTimeout(() => {
            displayCharacterDetail(charData.baseName);
        }, 100);
    } else {
        console.error("displayCharacterDetail 함수가 없습니다.");
    }
}

// ✨ [핵심] HTML onclick에서 찾을 수 있도록 window 객체에 등록
window.showCollectionCardDetails = showCollectionCardDetails;

window.clearBreedingSlot = clearBreedingSlot;
window.executeBreeding = executeBreeding;
window.selectBreedingCard = selectBreedingCard;
window.renderBreedingSlots = renderBreedingSlots; // 필요 시

// ✅ [수정됨] 레이드 보상 분배 함수 (NaN 오류 수정 + 안전한 랭킹 계산)
async function distributeRaidRewards(bossName, bossSpawnId) {
    console.log(`🎁 [${bossName}] (ID: ${bossSpawnId}) 보상 분배 시작...`);
    
    try {
        // ✨ [핵심 수정] 쿼리에 .where('lastRaidSpawnId', '==', bossSpawnId) 추가
        // 이제 "이번 보스를 때린 사람"만 정확하게 가져옵니다.
        const snapshot = await db.collection('users')
            .where('currentEventId', '==', CURRENT_EVENT_ID)
            .where('lastRaidSpawnId', '==', bossSpawnId) // 👈 이 줄이 유령 유저를 걸러냅니다!
            .orderBy('raidCumulativeDamage', 'desc')
            .limit(500) 
            .get();

        if (snapshot.empty) {
            console.log("이번 보스에 참여한 유저가 없어 보상을 분배하지 않습니다.");
            return;
        }

        const batch = db.batch();
        let count = 0;
        let currentRank = 1;

        snapshot.docs.forEach(doc => {
            const userData = doc.data();
            
            if (!userData.raidCumulativeDamage || userData.raidCumulativeDamage <= 0) return;

            const rank = currentRank++;
            let rewardData = null;

            if (rank === 1) rewardData = RAID_RANK_REWARDS[1];
            else if (rank === 2) rewardData = RAID_RANK_REWARDS[2];
            else if (rank === 3) rewardData = RAID_RANK_REWARDS[3];
            else if (rank <= 5) rewardData = RAID_RANK_REWARDS.top5;
            else rewardData = RAID_RANK_REWARDS.participation;

            const mailRef = db.collection('users').doc(doc.id).collection('mailbox').doc();
            const damageStr = (userData.raidCumulativeDamage || 0).toLocaleString();

            batch.set(mailRef, {
                title: `[토벌 성공] ${bossName}`,
                content: `${bossName} 토벌에 성공했습니다!\n당신의 기여도 순위는 ${rank}위 입니다.\n(누적 피해량: ${damageStr})`,
                rewards: {
                    currency: rewardData.currency,
                    fountainPens: rewardData.fountainPens
                },
                createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                fromSystem: true
            });
            count++;
        });

        await batch.commit();
        console.log(`✅ 총 ${count}명에게 레이드 보상 우편 발송 완료.`);
        
        showMessage(`보스 토벌 확인! ${count}명에게 보상이 지급되었습니다.`, "text-yellow-300", messageArea);

    } catch (e) {
        console.error("보상 분배 중 오류 발생:", e);
        if (e.message.includes('index')) {
            alert("시스템 오류: Firebase 색인(Index) 설정이 필요합니다.\n개발자 도구(F12) 콘솔의 링크를 확인하세요.");
        }
    }
}

// ✅ [수정됨] 레이드 공격 함수 (새 보스면 점수 리셋)
async function submitRaidDamage(damage) {
    if (damage <= 0) return;
    if (!currentUser) return alert("로그인 상태를 확인해주세요.");

    const DAILY_LIMIT = 5;           
    const bossRef = db.collection('system').doc('raid_boss');
    const userRef = db.collection('users').doc(currentUser.uid);
    
    let finalCount = null;
    let calculatedReward = 0;
    const REWARD_PER_100_DAMAGE = 1; 
    const MAX_REWARD = 50;           
    
    let triggerRewardDistribution = false;
    let bossNameForReward = "Unknown Boss";

    try {
        finalCount = await db.runTransaction(async (t) => {
            const bossDoc = await t.get(bossRef);
            const userDoc = await t.get(userRef);
            
            if (!bossDoc.exists) throw new Error("보스가 사라졌습니다.");
            if (!userDoc.exists) throw new Error("유저 데이터가 없습니다.");

            const bossData = bossDoc.data();
            const userData = userDoc.data();
            
            // ✨ [수정] 한국 시간(KST) 기준 오늘 날짜 구하기
            const todayStr = getTodayDateString(new Date());

            // 1. 날짜 체크 (일일 횟수 초기화)
            let countBeforeIncrement = userData.raidDailyCount || 0; 
            
            // 저장된 날짜를 KST 문자열로 변환
            let lastDateStr = '';
            if (userData.raidLastResetDate && userData.raidLastResetDate.toDate) {
                lastDateStr = getTodayDateString(userData.raidLastResetDate.toDate());
            }
            
            // 날짜 문자열이 다르면 0으로 초기화
            if (lastDateStr !== todayStr) countBeforeIncrement = 0;

            if (countBeforeIncrement >= DAILY_LIMIT) throw new Error("LIMIT_REACHED");
            if (bossData.currentHp <= 0) throw new Error("BOSS_DEAD");

            // 2. 기여도(데미지) 초기화 체크 (보스 시즌 변경 시)
            let myCurrentTotalDamage = userData.raidCumulativeDamage || 0;
            const currentBossId = bossData.spawnId || 0; 
            const myLastBossId = userData.lastRaidSpawnId || 0; 

            if (currentBossId !== myLastBossId) {
                myCurrentTotalDamage = 0; // 새 보스면 리셋
            }

            // 3. 데미지 적용
            const countAfterIncrement = countBeforeIncrement + 1; 
            const newHp = Math.max(0, bossData.currentHp - damage);
            const newTotalDamage = myCurrentTotalDamage + damage;
            
            // 4. 막타 체크
            if (newHp <= 0 && !bossData.isRewardDistributed) {
                triggerRewardDistribution = true;
                bossNameForReward = bossData.name;
                t.update(bossRef, { 
                    currentHp: newHp,
                    isRewardDistributed: true,
                    defeatedAt: firebase.firestore.FieldValue.serverTimestamp()
                });
            } else {
                t.update(bossRef, { currentHp: newHp });
            }
            
            // 5. 유저 정보 업데이트
            t.update(userRef, {
                raidDailyCount: countAfterIncrement, 
                raidLastResetDate: firebase.firestore.FieldValue.serverTimestamp(),
                raidCumulativeDamage: newTotalDamage,
                lastRaidSpawnId: currentBossId
            });

            return countAfterIncrement; 
        });
        
        // --- 트랜잭션 성공 후 처리 ---
        if (triggerRewardDistribution) {
            
            // ❌ 기존 코드: distributeRaidRewards(bossNameForReward);
            
            // ✅ [수정 코드] 보스 이름과 함께 '현재 보스의 ID(spawnId)'를 넘겨줍니다.
            // raidBossData는 전역 변수로 현재 보스 정보를 담고 있습니다.
            // (트랜잭션 안에서 bossData를 썼지만, 여기서는 전역 변수나 bossData를 활용해야 함)
            // 가장 확실한 건 트랜잭션 밖에서도 접근 가능한 raidBossData.spawnId를 쓰는 것입니다.
            // (주의: 트랜잭션이 성공했으므로 raidBossData도 최신화 되었다고 가정하거나, 안전하게 가져와야 함)
            
            // 여기서 raidBossData.spawnId를 쓰면 됩니다.
            distributeRaidRewards(bossNameForReward, raidBossData.spawnId); 
            
            alert(`🎉 결정타!! [${bossNameForReward}] 처치!\n잠시 후 보상 우편이 발송됩니다.`);
        } else {
            calculatedReward = Math.min(MAX_REWARD, Math.floor(damage * REWARD_PER_100_DAMAGE)); 
            const rewardMsg = calculatedReward > 0 ? `기여 보상: 💎${calculatedReward}` : `(보상 없음)`;
            alert(`🎉 ${damage} 피해를 입혔습니다! (오늘 ${finalCount}회)\n${rewardMsg}`);
        }

        playerRaidDailyCount = finalCount;
        updateRaidDailyCountUI();
        
        if (calculatedReward > 0) playerCurrency += calculatedReward;
        playerRaidDamage += damage; // UI용 임시 갱신
        
        updateUI(); 

    } catch (error) {
        if (error.message === "LIMIT_REACHED") return; // 횟수 제한 시 조용히 리턴 (UI에서 막힘)
        if (error.message === "BOSS_DEAD") {
            alert("이미 토벌된 보스입니다.");
            updateRaidUI();
        } else {
            console.error(error);
            alert(`오류: ${error.message}`);
        }
    }
}
window.startRaidBattle = startRaidBattle;

// yumecan.html - loadEventRankingData 함수 근처에 추가

// ✅ [수정됨] 메인 레이드 랭킹 로드 (현재 보스 시즌만 필터링)
async function loadRaidRankingData() {
    const listContainer = document.getElementById('ranking-list');
    
    // 모달이나 보스 데이터가 없으면 중단
    if (!listContainer || !raidBossData) {
        if(listContainer) listContainer.innerHTML = '<p class="text-center text-gray-500 py-4">진행 중인 레이드 정보가 없습니다.</p>';
        return;
    }
    
    listContainer.innerHTML = '<p class="text-center text-gray-500 py-4">최신 랭킹 불러오는 중...</p>';
    
    try {
        // ✨ [핵심 수정] .get({ source: 'server' }) 옵션 추가
        // 브라우저 캐시를 무시하고 무조건 서버의 최신 데이터를 가져옵니다.
        const snapshot = await db.collection('users')
            .where('currentEventId', '==', CURRENT_EVENT_ID) 
            .where('lastRaidSpawnId', '==', raidBossData.spawnId) 
            .orderBy('raidCumulativeDamage', 'desc')
            .limit(20)
            .get({ source: 'server' }); // 👈 여기가 수정된 부분입니다!

        listContainer.innerHTML = '';
        
        if (snapshot.empty) {
            listContainer.innerHTML = '<p class="col-span-full text-center text-gray-500 py-4">아직 기록이 없습니다.</p>';
            return;
        }

        let rank = 1;
        snapshot.forEach(doc => {
            const data = doc.data();
            const isMe = (currentUser && doc.id === currentUser.uid);
            const { imgUrl } = getUserRepInfo(data);
            const score = (data.raidCumulativeDamage || 0).toLocaleString();
            
            // 스타일 설정
            let rankStyle = 'bg-gray-700 border-gray-600';
            let rankBadge = `<span class="font-bold w-6 text-center text-gray-400">${rank}</span>`;
            
            if (rank === 1) { rankStyle = 'bg-yellow-900/40 border-yellow-500'; rankBadge = '🥇'; }
            else if (rank === 2) { rankStyle = 'bg-gray-400/20 border-gray-400'; rankBadge = '🥈'; }
            else if (rank === 3) { rankStyle = 'bg-orange-900/40 border-orange-500'; rankBadge = '🥉'; }

            if (isMe) rankStyle += ' ring-2 ring-blue-500';

            const div = document.createElement('div');
            div.className = `flex items-center gap-3 p-2 rounded border ${rankStyle} cursor-pointer hover:bg-white/10 transition-colors relative group`;
            div.onclick = () => openOtherUserProfile({ ...data, uid: doc.id });
            
            div.innerHTML = `
                <div class="text-xl">${rankBadge}</div>
                <img src="${imgUrl}" class="w-10 h-10 rounded object-cover bg-black border border-white/10">
                <div class="flex-grow">
                    <p class="text-sm font-bold text-white truncate max-w-[120px]">${data.nickname || '익명의 탐정'}</p>
                    ${isMe ? '<span class="text-[10px] bg-blue-600 text-white px-1 rounded">ME</span>' : ''}
                </div>
                <div class="text-right">
                    <p class="text-red-300 font-bold text-sm">${score} Dmg</p>
                </div>
            `;
            listContainer.appendChild(div);
            rank++;
        });

    } catch (error) {
        console.error("레이드 랭킹 로드 실패:", error);
        listContainer.innerHTML = '<p class="text-center text-red-400 text-xs">랭킹 로드 실패 (인덱스 확인 필요)</p>';
    }
}

// ✨ [신규] 종료된 이벤트 확인 및 보상 트리거
async function checkEndedEvents() {
    if (!allEventInfos || allEventInfos.length === 0) return;

    const now = new Date();
    const statusRef = db.collection('system').doc('event_status');

    try {
        await db.runTransaction(async (t) => {
            const doc = await t.get(statusRef);
            // 문서가 없으면 빈 객체로 시작
            const statusData = doc.exists ? doc.data() : {};
            
            // 모든 이벤트 목록을 순회하며 '종료되었으나 보상이 안 나간' 건을 찾음
            for (const info of allEventInfos) {
                // 1. 이미 종료된 이벤트인가?
                if (now > info.endDate) {
                    // 2. 이미 보상이 지급되었는가? (statusData에 기록 확인)
                    if (!statusData[info.id]) {
                        console.log(`📢 [${info.title}] 이벤트가 종료되었습니다. 보상 분배를 시도합니다.`);
                        
                        // 3. '지급 완료' 플래그를 먼저 설정 (중복 실행 방지 락)
                        // 주의: 여기서는 플래그만 찍고, 실제 분배(distributeEventRewards)는
                        // 트랜잭션 밖에서 실행하거나 비동기로 호출합니다.
                        t.set(statusRef, { [info.id]: true }, { merge: true });
                        
                        // 4. 분배 함수 실행 (await 없이 호출하여 트랜잭션 지연 방지)
                        distributeEventRewards(info.id, info.title);
                    }
                }
            }
        });
    } catch (e) {
        console.error("이벤트 종료 체크 중 오류:", e);
    }
}

// yumecan.html - <script> 태그 내부

/// yumecan.html - <script> 태그 내부 (레이드 로직 부분)

// ✨ [신규] 시트 데이터를 Firebase와 비교하여 보스가 없으면 스폰합니다.
// ✅ [수정됨] 보스 생성/확인 함수 (고유 spawnId 부여)
async function checkAndSpawnRaidBoss() {
    console.log("---------- [DEBUG: RAID SPAWN START] ----------");

    if (!raidBossDataSheet) return;
    if (!currentUser) return;

    const bossRef = db.collection('system').doc('raid_boss');
    
    try {
        const doc = await bossRef.get();
        
        // 1. 보스가 아예 없거나, 레벨이 다르면 새로 생성
        if (!doc.exists || doc.data().level !== raidBossDataSheet.level) {
             console.log("[DEBUG] 새로운 레이드 보스 데이터를 생성합니다.");
             
             const newBossData = {
                ...raidBossDataSheet, 
                currentHp: raidBossDataSheet.maxHp, 
                isDead: false,
                isRewardDistributed: false, // 보상 초기화
                spawnedAt: firebase.firestore.FieldValue.serverTimestamp(),
                spawnId: Date.now() // ✨ [핵심] 이번 보스의 고유 주민번호 (생성 시간)
             };
             
             await bossRef.set(newBossData);
             raidBossData = newBossData;
             updateRaidUI();
             return;
        }

        // 2. 이미 존재하는 경우 데이터 로드
        raidBossData = doc.data();
        
        // (안전장치) 옛날 데이터라 spawnId가 없으면 강제로 넣어줌
        if (!raidBossData.spawnId) {
            await bossRef.update({ spawnId: Date.now() });
            raidBossData.spawnId = Date.now();
        }
        
        updateRaidUI();

    } catch (error) {
        console.error("보스 스폰 체크 중 오류:", error);
    }
}

// ✅ [수정됨] 가챠 획득 가능 목록 모달 열기 함수 (3열 고정)
function openGachaPoolModal(gachaType) {
    const modal = document.getElementById('gacha-pool-modal');
    const titleEl = document.getElementById('pool-modal-title');
    const listContainer = document.getElementById('pool-list-container');
    
    if (!modal || !listContainer) return;
    
    // 1. 제목 설정
    const typeName = gachaType === 'normal' ? '일반 서가' : '이벤트 서가';
    titleEl.textContent = `[${typeName}] 획득 가능 등장인물`;
    listContainer.innerHTML = '<p class="text-center text-gray-500 py-4">목록 로딩 중...</p>';
    
    // 2. 캐릭터 필터링 (이벤트 ID 비교 로직 적용됨)
    const obtainableCharacters = characters.filter(char => {
        const poolInfo = gachaPool[char.name];
        if (!poolInfo) return false; // 데이터 없으면 제외
        
        // 일반 서가인 경우
        if (gachaType === 'normal') {
            return poolInfo.normal;
        }
        
        // 이벤트 서가인 경우
        if (gachaType === 'event') {
            // 1) 픽업 주인공이면 등장
            if (char.name === EVENT_CHARACTER_NAME) return true;
            // 2) 현재 이벤트 ID와 타겟 ID가 일치하면 등장
            if (poolInfo.targetEventId === CURRENT_EVENT_ID) return true;
            // 3) 'ALL'로 설정되어 있으면 모든 이벤트에 등장
            if (poolInfo.targetEventId === 'ALL') return true;
            
            return false;
        }
        
        return false;
    });

    // 3. 등급별 그룹화
    const grouped = obtainableCharacters.reduce((acc, char) => {
        const rarity = char.rarity || 'N';
        if (!acc[rarity]) acc[rarity] = [];
        acc[rarity].push(char);
        return acc;
    }, {});
    
    // 4. 화면 렌더링 (SSR > SR > R > N 순서)
    const rarityOrder = ['SSR', 'SR', 'R', 'N'];
    listContainer.innerHTML = ''; 

    rarityOrder.forEach(rarity => {
        const charList = grouped[rarity];
        if (charList && charList.length > 0) {
            
            const colorClass = { 
                'SSR': 'text-yellow-400', 
                'SR': 'text-purple-400', 
                'R': 'text-blue-400', 
                'N': 'text-gray-400' 
            }[rarity];
            
            const section = document.createElement('div');
            
            // 픽업 표시 배지
            let pickupBadge = '';
            if (gachaType === 'event') {
                 // 현재 리스트에 픽업캐릭터가 포함되어 있는지 확인
                 const pickupCount = charList.filter(c => c.name === EVENT_CHARACTER_NAME).length;
                 if (pickupCount > 0) {
                     pickupBadge = `<span class="ml-2 text-red-400 bg-red-900/30 px-2 py-0.5 rounded-full text-sm font-medium">✨ 픽업 대상</span>`;
                 }
            }

            section.innerHTML = `
                <h4 class="text-xl font-bold ${colorClass} mb-2 flex items-center">
                    ${rarity} (${charList.length}종)${pickupBadge}
                </h4>
                <div class="grid grid-cols-2 md:grid-cols-3 gap-3 border-b border-gray-700 pb-4 mb-4">
                    ${charList.map(char => {
                        return `
                            <div class="bg-gray-700/50 p-2 rounded-lg flex flex-col items-center text-center justify-center gap-1">
                                <img src="${char.cardImageUrl}" class="w-16 h-16 rounded object-cover">
                                <span class="text-xs text-white text-center font-medium">${char.name}</span>
                            </div>
                        `;
                    }).join('')}
                </div>
            `;
            listContainer.appendChild(section);
        }
    });

 

    // 5. 모달 표시
    modal.classList.remove('hidden');
}
window.openGachaPoolModal = openGachaPoolModal;

let raidBossData = null;
let raidUnsubscribe = null;

function getTodayDateString(dateObj = new Date()) {
    // dateObj가 null이거나 유효하지 않으면 오늘 날짜 사용
    if (!dateObj) dateObj = new Date();
    
    // 한국 시간(Asia/Seoul) 기준으로 변환
    return dateObj.toLocaleDateString('ko-KR', {
        timeZone: 'Asia/Seoul',
        year: 'numeric',
        month: '2-digit',
        day: '2-digit'
    }).replace(/\. /g, '-').replace('.', ''); // "2025. 10. 19." -> "2025-10-19" 형태로 통일
}

// ✅ [신규] 항복/도주 로직 함수
// ✅ [수정됨] 항복/도주 로직 함수 (확실한 종료 처리)
function fleeCombat() {
    // 이미 전투가 끝난 상태라면 무시
    if (!isCombatRunning) return;

    if (!window.currentCombatIndices || !window.currentCombatType) {
        console.error("전투 정보가 유실되었습니다. 홈으로 돌아갑니다.");
        isCombatRunning = false;
        switchTab('home'); 
        return;
    }

    // 1. 전투 진행 플래그를 먼저 끕니다. (이게 runCombatLoop를 멈추는 신호가 됩니다)
    isCombatRunning = false; 
    
    // 2. 패배 처리로 전투 종료 함수 호출
    // (totalDamageDealt는 0으로 처리)
    endCombat(false, {
        indices: window.currentCombatIndices,
        type: window.currentCombatType
    }, 0); 
}

function startIntroTutorial() {
    console.log("🎬 튜토리얼(메인스토리 0장) 시작 시도...");
    
    // 1. 데이터가 아예 없는 경우 방어
    if (!mainStories || mainStories.length === 0) {
        alert("❌ 메인 스토리 데이터가 로드되지 않았습니다.\n잠시 후 다시 시도해주세요.");
        finishIntroTutorial();
        return;
    }

    // 2. ID가 0인 챕터 찾기
    let introIndex = mainStories.findIndex(story => story.id === 0);
    
    // 3. [안전장치] 만약 ID 0을 못 찾았다면? -> 그냥 목록의 맨 처음(0번 인덱스) 스토리를 실행!
    if (introIndex === -1) {
        console.warn("⚠️ ID가 0인 스토리를 못 찾았습니다. 자동으로 첫 번째 스토리를 재생합니다.");
        introIndex = 0; 
    }

    console.log(`▶ 스토리 인덱스 [${introIndex}]번 실행`);

    // 4. 스토리 모달의 콜백을 '튜토리얼 종료 함수'로 설정
    document.getElementById('interactive-story-modal').dataset.callback = "finishIntroTutorial()";
    
    // 5. 스토리 실행
    startInteractiveStory(introIndex, 'main');
}

// 2. 튜토리얼 종료 후 처리 함수 (10회 뽑기 유도)
function finishIntroTutorial() {
    // 상태 변경 및 저장
    playerTutorialFinished = true;
    saveGame(); // Firebase에 저장

    // '소환(Gacha)' 탭으로 강제 이동
    switchTab('gacha');
    
    // 알림 메시지 띄우기
    setTimeout(() => {
        alert("📖 프롤로그 완료!\n신규 유저님을 위해 [보석 100개]가 지급되었습니다.\n\n지금 바로 '10회 뽑기'를 진행하여 등장인물을 모아보세요!");
        
        // 10회 뽑기 버튼 강조 효과
        const tenPullBtn = document.getElementById('pull-ten');
        if (tenPullBtn) {
            tenPullBtn.classList.add('ring-4', 'ring-yellow-400', 'animate-pulse');
            // 한번 클릭하면 효과 제거
            const originalOnClick = tenPullBtn.onclick;
            tenPullBtn.onclick = (e) => {
                tenPullBtn.classList.remove('ring-4', 'ring-yellow-400', 'animate-pulse');
                handlePull(10, PULL_TEN_COST, 'normal'); // 원래 기능 실행
            };
        }
    }, 500);
}


// ... (다른 함수들)

// yumecan.html - updateRaidDailyCountUI 함수 전체를 이 코드로 교체하세요 (7894행 근처)
// ✅ [수정] 레이드 횟수 UI를 업데이트하고 버튼을 활성화/비활성화하는 함수
function updateRaidDailyCountUI() {
    const maxCount = 5;
    // playerRaidDailyCount는 loadGameFromFirebase에서 로드되거나 0으로 초기화됨
    const currentCount = playerRaidDailyCount || 0; 
    const remaining = Math.max(0, maxCount - currentCount);

    const display = document.getElementById("raid-count-display");
    // ✅ [확인] HTML에서 변경한 ID와 일치시켜야 합니다.
    const btn = document.getElementById("raid-start-btn"); 

    if (display) {
        display.textContent = `오늘의 레이드: ${currentCount} / ${maxCount}회`;
    }

    // ⭐ [핵심 수정] 버튼이 null이 아닐 때만 접근
    if (btn) {
        if (remaining <= 0) {
            btn.disabled = true;
            btn.classList.add('opacity-50', 'cursor-not-allowed', 'bg-gray-600');
            btn.classList.remove('bg-red-600', 'hover:bg-red-700');
            btn.textContent = "횟수 제한";
        } else {
            btn.disabled = false;
            // ⭐ [핵심 수정] 횟수 제한이 풀려도 보스가 죽었는지 최종 확인 후 스타일 적용
            if (raidBossData && raidBossData.currentHp > 0) {
                btn.classList.remove('opacity-50', 'cursor-not-allowed', 'bg-gray-600');
                btn.classList.add('bg-red-600', 'hover:bg-red-700');
                btn.textContent = "⚔️ 전투 개시";
            }
        }
    }
}

// ... (다른 함수들)
// ================== 👆 레이드 시스템 로직 끝 👆 ==================
	

    }); // <--- DOMContentLoaded 닫는 괄호 (절대 지우지 마세요!)
	
    </script>
</body>
</html>























